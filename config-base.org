#+TITLE: Config: Base
#+DESCRIPTION: Configuration options loaded at Emacs startup.
#+AUTHOR: Chris Barrett
#+OPTIONS: toc:3 num:nil ^:nil

This is the main customisation file for this Emacs config. =org-babel= is used
to generate the elisp file that will actually be loaded by Emacs.

* Remove all GUI elements except the mode line
#+begin_src emacs-lisp
(when (fboundp 'scroll-bar-mode)   (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode)     (tool-bar-mode -1))
(when (fboundp 'blink-cursor-mode) (blink-cursor-mode -1))
(when (fboundp 'menu-bar-mode)     (menu-bar-mode (if (display-graphic-p) +1 -1)))
#+end_src
* Increase GC threshold
This is recommended to prevent extensions like =flx= from triggering excessive
GCs during normal operation.
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 1024 1024 20))
#+end_src
* Add additional directories to the Emacs load-path
#+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(add-to-list 'load-path (concat (getenv "HOME") "/Dropbox/"))
(add-to-list 'load-path (concat user-emacs-directory "lisp"))
(add-to-list 'load-path (concat user-emacs-directory "lib"))
#+end_src
* Install core packages
These packages are utilities required by the configuration infrastructure.
#+begin_src emacs-lisp
(defun cb:install-package (pkg &optional require?)
  "Install PKG unless it has already been installed.
Also require the package when REQUIRE? is set."
  (unless (package-installed-p pkg) (package-install pkg))
  (when require? (require pkg nil t)))

(cb:install-package 'dash t)
(cb:install-package 'dash-functional t)
(cb:install-package 's t)
(cb:install-package 'f t)
(cb:install-package 'async t)
(cb:install-package 'noflet t)
(cb:install-package 'diminish t)
(cb:install-package 'bind-key t)
#+end_src
* dash.el extensions
** combinator aliases
#+begin_src emacs-lisp
(defalias 'AP 'funcall)
(defalias 'K '-const)
(defalias 'I 'identity)
#+end_src
** dash-functional extension macros
#+begin_src emacs-lisp
(eval-and-compile
  (defun cblib:quote-if-fn (fn)
    (if (symbolp fn) `',fn fn)))

(defmacro N (fn)
  "Like `-not', but does not require FN to be quoted."
  `(-not ,(cblib:quote-if-fn fn)))

(defmacro ~ (fn &rest args)
  "Like `-partial', but does not require FN to be quoted."
  `(-partial ,(cblib:quote-if-fn fn) ,@args))

(defmacro ~R (fn &rest args)
  "Like `-rpartial', but does not require FN to be quoted."
  `(-partial ,(cblib:quote-if-fn fn) ,@args))

(defmacro π (&rest fns)
  "Like `-juxt', but does not require FNS to be quoted."
  `(-juxt ,@(-map 'cblib:quote-if-fn fns)))

(defmacro C (&rest fns)
  "Like `-compose', but does not require FNS to be quoted."
  `(-compose ,@(-map 'cblib:quote-if-fn fns)))

(defmacro <> (fn)
  "Like `-flip', but does not require FN to be quoted."
  `(-flip ,(cblib:quote-if-fn fn)))

(defmacro & (&rest fns)
  "Like `-andfn', but does not require FNS to be quoted."
  `(-andfn ,@(-map 'cblib:quote-if-fn fns)))

(defmacro | (&rest fns)
  "Like `-orfn', but does not require FNS to be quoted."
  `(-orfn ,@(-map 'cblib:quote-if-fn fns)))

(defmacro @ (fn)
  "Like `-applify', but does not require FN to be quoted."
  `(-applify ,(cblib:quote-if-fn fn)))

(defun -true-fn (&rest _)
  "Always return t."
  t)

(defun -nil-fn (&rest _)
  "Always return nil."
  nil)
#+end_src
** list extensions
#+begin_src emacs-lisp
(defun -listify (x)
  "Wrap X in a list if it is not a list."
  (if (listp x)
      x
    (list x)))

(defun -uniq-by (selector-fn list)
  "Remove duplicates in the given sequence using a function.

- SELECTOR-FN takes the current element and returns the item to compare.

- LIST is the sequence to transform."
  ;; Cache the items compared using selector-fn for later comparisons. This
  ;; alleviates the need for an additional traversal.
  (let (transformed)
    (--reduce-r-from
     (let ((cur (funcall selector-fn it)))
       (if (-contains? transformed cur)
           acc
         (push cur transformed)
         (cons it acc)))
     nil
     list)))

(defun -non-null (list)
  "Return the non-nil elements in LIST."
  (-keep 'identity list))
#+end_src
* s.el extensions
#+begin_src emacs-lisp
(defun s-alnum-only (s)
  "Remove non-alphanumeric characters from S."
  (with-temp-buffer
    (insert s)
    (goto-char (point-min))
    (while (search-forward-regexp (rx (not alnum)) nil t)
      (replace-match ""))
    (buffer-string)))

(defun s-unlines (&rest strs)
  "Join STRS with newlines."
  (s-join "\n" strs))

(defmacro s-lex-cat (&rest format-strs)
  "Concatenate FORMAT-STRS then pass them to `s-lex-format'."
  `(s-lex-format ,(apply 'concat format-strs)))

(defmacro s-with-temp-buffer (&rest body)
  "Evaluate BODY in a temporary buffer and return the buffer string."
  (declare (indent 0) (debug t))
  `(with-temp-buffer
     ,@body
     (buffer-string)))

(defalias 's-no-props 'substring-no-properties)

(defun s-split-sexps (str)
  "Split STR by sexp boundaries."
  (with-temp-buffer
    (insert str)
    (goto-char (point-min))
    ;; Collect sexps in buffer.
    (let (acc (pt (point-min)))
      (until (eobp)
        (forward-sexp)
        (setq acc (cons (s-trim (buffer-substring pt (point)))
                        acc))
        (setq pt (point)))

      (-remove 's-blank? (nreverse acc)))))
#+end_src
* Convenience macros
** define =until=, the logical opposite of =while=
#+begin_src emacs-lisp
(defmacro until (test &rest body)
  "If TEST yields nil, eval BODY... and repeat.
The order of execution is thus TEST, BODY, TEST, BODY and so on
until TEST returns non-nil."
  (declare (indent 1))
  `(while (not ,test)
     ,@body))
#+end_src
** Lambda-function with destructuring args
#+begin_src emacs-lisp
(defmacro lambda+ (arglist &rest body)
  "A lambda function supporting argument destructuring.

ARGLIST is a full Common Lisp arglist.  Its bindings are availabe
in BODY.

\(fn ARGS [DOCSTRING] [INTERACTIVE] BODY)"
  (declare (doc-string 2) (indent defun)
           (debug (&define lambda-list
                           [&optional stringp]
                           [&optional ("interactive" interactive)]
                           def-body)))
  `(lambda (&rest args)
     (cl-destructuring-bind ,arglist args
       ,@body)))
#+end_src
** Macros for defining hooks
#+begin_src emacs-lisp
(defun cb-lib:format-message (category desc body)
  (format "[%s]: %s\n%s\n" category desc body))

(cl-defmacro hook-fn (hook &rest body
                           &key local append (arglist '(&rest _args))
                           &allow-other-keys)
  "Execute forms when a given hook is called.

- HOOK is the name of the hook.

- BODY is a list of forms to evaluate when the hook is run.

- APPEND and LOCAL are passed to the underlying call to `add-hook'.

- ARGLIST overrides the default arglist for the hook's function.

\(fn hook &rest body &key local append arglist)"
  (declare (indent 1) (doc-string 2))

  (cl-assert (symbolp (eval hook)))

  (let ((bod
         ;; Remove keyword args from body.
         `(progn ,@(->> body
                     (-partition-all-in-steps 2 2)
                     (--drop-while (keywordp (car it)))
                     (apply '-concat))))
        (file (or byte-compile-current-file load-file-name)))
    `(progn
       (add-hook ,hook
                 (lambda ,arglist
                   ;; Do not allow errors to propagate from the hook.
                   (condition-case-unless-debug err
                       ,bod
                     (error
                      (message
                       (cb-lib:format-message
                        ,(if file
                             (format "%s in %s" (eval hook) file)
                           hook)
                        "Error raised in hook"
                        (error-message-string err))))))
                 ,append ,local)
       ,hook)))

(defmacro hook-fns (hooks &rest args)
  "A wrapper for `hook-fn', where HOOKS is a list of hooks.

\(fn hooks &rest body &key local append arglist)"
  (declare (indent 1) (doc-string 2))
  `(progn
     ,@(--map `(hook-fn ',it ,@args)
              (eval hooks))))
#+end_src
** Define a wrapper for the eval-after-load+progn idiom
#+begin_src emacs-lisp
(defmacro after (features &rest body)
  "Like `eval-after-load' - once all FEATURES are loaded, execute the BODY.
FEATURES may be a symbol or list of symbols."
  (declare (indent 1))
  ;; Wrap body in a descending list of `eval-after-load' forms.
  ;; The last form is eval'd to remove its quote.
  (eval (->> (-listify (eval features))
          (--map `(eval-after-load ',it))
          (--reduce-from `'(,@it ,acc)
                         `'(progn ,@body)))))

#+end_src
** define a shorthand for anonymous interactive commands
#+begin_src emacs-lisp
(defmacro command (&rest body)
  "Declare an `interactive' command with BODY forms."
  `(lambda (&optional _arg &rest _args)
     (interactive)
     ,@body))
#+end_src
** test if a symbol is bound and not nil
#+begin_src emacs-lisp
(defmacro true? (sym)
  "Test whether SYM is bound and non-nil."
  `(and (boundp ',sym) (eval ',sym)))
#+end_src
** Key binding commands
#+begin_src emacs-lisp
(cl-defmacro bind-keys (&rest
                        bindings
                        &key map hook overriding?
                        &allow-other-keys)
  "Variadic form of `bind-key'.
- MAP is an optional keymap.  The bindings will only be enabled
  when this keymap is active.

- OVERRIDING? prevents other maps from overriding the binding.  It
  uses `bind-key*' instead of the default `bind-key'.

- HOOK is a hook or list of hooks. The bindings will be made to
  the specified keymap MAP, or using `local-set-key' is no keymap
  is specified.

- BINDINGS are alternating strings and functions to use for
  keybindings."
  (declare (indent 0))
  (cl-assert (not (and map overriding?)))
  (let ((bs (->> bindings (-partition-all 2) (--remove (keywordp (car it))))))
    `(progn
       ,@(cl-loop for (k f) in bs collect
                  (cond
                   (overriding?
                    `(bind-key* ,k ,f))
                   (hook
                    `(hook-fns ',(-listify hook)
                       ;; If there is a map specified, bind to that
                       ;; map. Otherwise fall back on `local-set-key' for
                       ;; bindings.
                       (if (true? ,map)
                           (bind-key ,k ,f ,map)
                         (local-set-key ,k ,f))))
                   (t
                    `(bind-key ,k ,f ,map)))))))

(defmacro define-keys (keymap &rest bindings)
  "Variadic form of `define-key'.

- KEYMAP is a keymap to add the bindings to.

- BINDINGS are the bindings to add to the keymap."
  (declare (indent 1))
  (let ((bs (->> bindings (-partition-all 2) (--remove (keywordp (car it))))))
    `(progn
       ,@(cl-loop for (k f) in bs
                  collect `(define-key
                             ,keymap
                             ,(if (stringp k) `(kbd ,k) k)
                             ,f)))))

(defun buffer-local-set-key (key command)
  "Map KEY to COMMAND in this buffer alone."
  (interactive "KSet key on this buffer: \naCommand: ")
  (let ((mode-name (intern (format "%s-magic" (buffer-name)))))
    (eval
     `(define-minor-mode ,mode-name
        "Automagically built minor mode to define buffer-local keys."))
    (let* ((mapname (format "%s-map" mode-name))
           (map (intern mapname)))
      (unless (boundp (intern mapname))
        (set map (make-sparse-keymap)))
      (eval
       `(define-key ,map ,key ',command)))
    (funcall mode-name t)))
#+end_src
** define a command to install packages when visiting certain file types
#+begin_src emacs-lisp
(cl-defmacro cb:declare-package-installer (group &key match packages)
  "Declare a command to install packages when visiting certain files.

GROUP is a symbol naming the group of packages. It will be used
to create an interactive installation command.

MATCH is a regular expression matched against file names. The
listed packages will be installed automatically when navigating
to a matching file.

PACKAGES is a list of packages that will be installed."
  (declare (indent 1))
  (let ((sym (intern (format "cb:install-%s-packages" group)))
        (n-pkgs (length packages)))
    `(progn
       (defun ,sym ()
         (interactive)

         ;; Prompt the user for confirmation.
         (when (and (called-interactively-p)
                    (not
                     (y-or-n-p
                      ,(format "%s package%s will be installed (%s). Continue? "
                               n-pkgs
                               (if (= 1 n-pkgs) "" "s")
                               (s-join ", " (-map 'symbol-name packages))))))
           (user-error "Aborted"))

         (save-window-excursion
           (--each ',packages
             (with-demoted-errors
                 (cb:install-package it t)))))

       ;; Install automatically on hooks when buffer or file name is a match.
       (hook-fns '(find-file-hook after-change-major-mode-hook)
         (when (s-matches? ,match (buffer-name))
           (funcall ',sym))))))
#+end_src
* Convenience functions
** current region
#+begin_src emacs-lisp
(defun current-region (&optional no-properties)
  "Return the current active region, or nil if there is no region active.
If NO-PROPERTIES is non-nil, return the region without text properties."
  (when (region-active-p)
    (funcall (if no-properties 'buffer-substring-no-properties 'buffer-substring)
             (region-beginning)
             (region-end))))
#+end_src
** current line's contents
#+begin_src emacs-lisp
(cl-defun current-line (&optional (move-n-lines 0))
  "Return the line at point, or another line relative to this line.
MOVE-N-LINES is an integer that will return a line forward if
positive or backward if negative."
  (save-excursion
    (forward-line move-n-lines)
    (buffer-substring (line-beginning-position) (line-end-position))))
#+end_src
** collapse vertical whitespace
#+begin_src emacs-lisp
(cl-defun collapse-vertical-whitespace (&optional (to-n-lines 1))
  "Collapse blank lines around point.
TO-N-LINES is the number of blank lines to insert afterwards."
  (interactive "*nCollapse to N blanks: ")
  (save-excursion
    ;; Delete blank lines.
    (search-backward-regexp (rx (not (any space "\n"))) nil t)
    (forward-line 1)
    (while (s-matches? (rx bol (* space) eol) (current-line))
      (forward-line)
      (join-line))
    ;; Open a user-specified number of blanks.
    (open-line to-n-lines)))
#+end_src
* Convenience aliases for interactive functions
#+begin_src emacs-lisp
(defalias 'qrr 'query-replace-regexp)

(defalias 'kb 'kill-buffer)
(defalias 'bb 'bury-buffer)

(defalias 'dfb 'delete-file-and-buffer)
(defalias 'dbf 'delete-file-and-buffer)
(defalias 'rfb 'rename-file-and-buffer)
(defalias 'rbf 'rename-file-and-buffer)

(defalias 'plp 'package-list-packages)
#+end_src
* Path variables
Define important paths that should be global throughout the configuration.
** Define special paths
These paths should be named.
#+begin_src emacs-lisp
(defconst user-home-directory    (concat (getenv "HOME") "/"))
(defconst user-dropbox-directory (concat user-home-directory "Dropbox/"))
(defconst user-mail-directory    (f-join user-home-directory "Mail"))
#+end_src
These common paths should be named and created if necessary.
#+begin_src emacs-lisp
(defmacro define-path (sym path)
  "Define a subfolder of the `user-emacs-directory'.
SYM is declared as a special variable set to PATH.
This directory tree will be added to the load path if ADD-PATH is non-nil."
  `(defconst ,sym
     (let ((dir (f-join user-emacs-directory ,path)))
       (unless (file-exists-p dir) (make-directory dir))
       dir)))

(define-path cb:assets-dir    "assets/")
(define-path cb:autosaves-dir "tmp/autosaves/")
(define-path cb:backups-dir   "backups/")
(define-path cb:bin-dir       "bin/")
(define-path cb:el-get-dir    "el-get")
(define-path cb:elpa-dir      "elpa/")
(define-path cb:etc-dir       "etc/")
(define-path cb:src-dir       "src")
(define-path cb:tmp-dir       "tmp/")
(define-path cb:yasnippet-dir "snippets/")
(define-path cb:info-dir      "info")
(define-path cb:scripts-dir   "scripts/")
(define-path cb:lib-dir       "lib/")
(define-path cb:lisp-dir      "lisp/")
#+end_src
** Add subdirs for lisp src directories to load path
#+begin_src emacs-lisp
(-each (->> (list cb:lib-dir cb:lisp-dir)
         (--mapcat (f-directories it nil t)))
       (~ add-to-list 'load-path))
#+end_src
** Use the version of emacs in ./src for C sources
#+begin_src emacs-lisp
(setq source-directory
      (f-join cb:src-dir (format "emacs-%s.%s"
                                 emacs-major-version
                                 emacs-minor-version)))
#+end_src
** Add downloaded sources to the info path
#+begin_src emacs-lisp
(setq Info-additional-directory-list
      (-flatten (list cb:info-dir
                      (f-join source-directory "info/")
                      (f-directories cb:info-dir))))
#+end_src
** Define org directory and default notes file
#+begin_src emacs-lisp
(setq org-directory (f-join user-home-directory "org")
      org-default-notes-file (f-join org-directory "notes.org"))
#+end_src
** Define path to ledger file
#+begin_src emacs-lisp
(defvar ledger-file (f-join org-directory "accounts.ledger"))
#+end_src
** Add scripts dir to the exec-path
#+begin_src emacs-lisp
(add-to-list 'exec-path cb:scripts-dir)
#+end_src
* Modal view macros
Define macros for creating /modal views/. These are commands that, when invoked,
show a particular buffer and delete all other windows. They restore the previous
window state when closed.
** Define a macro that allows window restoration
#+begin_src emacs-lisp
(defun deep-replace (target rep tree)
  "Replace TARGET with REP in TREE."
  (cond ((equal target tree) rep)
        ((atom tree)         tree)
        (t
         (--map (deep-replace target rep it) tree))))

(defmacro with-window-restore (&rest body)
  "Declare an action that will eventually restore window state.
The original state can be restored by calling (restore) in BODY."
  (declare (indent 0))
  (let ((register (cl-gensym)))
    `(progn
       (window-configuration-to-register ',register)
       ,@(deep-replace '(restore)
                       `(ignore-errors
                          (jump-to-register ',register))
                       body))))
#+end_src
** Define a way to decorate a function to make it behave modally
#+begin_src emacs-lisp
(cl-defmacro declare-modal-view (command &optional (quit-key "q"))
  "Advise a given command to restore window state when finished."
  `(defadvice ,command (around
                        ,(intern (format "%s-wrapper" command))
                        activate)
     "Auto-generated window restoration wrapper."
     (with-window-restore
       ad-do-it
       (delete-other-windows)
       (buffer-local-set-key (kbd ,quit-key) (command (kill-buffer) (restore))))))
#+end_src
** Define a high-level way to declare modal commands
#+begin_src emacs-lisp
(cl-defmacro declare-modal-executor
    (name &optional &key command bind restore-bindings)
  "Execute a command with modal window behaviour.

- NAME is used to name the executor.

- COMMAND is a function or sexp to evaluate.

- BIND is a key binding or list thereof used to globally invoke the command.

- RESTORE-BINDINGS are key commands that will restore the buffer
  state. If none are given, BIND will be used as the restore
  key."
  (declare (indent defun))
  (let ((fname (intern (format "executor:%s" name)))
        (bindings (if (listp bind) bind `'(,bind))))
    `(progn
       (defun ,fname ()
         ,(format "Auto-generated modal executor for %s" name)
         (interactive)
         (with-window-restore
           ;; Evaluate the command.
           ,(cond ((interactive-form command) `(call-interactively ',command))
                  ((functionp command)        `(funcall #',command))
                  (t                           command))
           (delete-other-windows)
           ;; Configure restore bindings.
           (--each (or ,restore-bindings ,bindings)
             (buffer-local-set-key (kbd it) (command (bury-buffer) (restore))))))

       ;; Create global hotkeys
       (--each ,bindings
         (eval `(bind-key* ,it ',',fname))))))
#+end_src
* Option pickers
** Define face for keys in option pickers
#+begin_src emacs-lisp
(defface option-key
  `((t (:foreground "red")))
  "Face for key highlight in search method prompt"
  :group 'options)

#+end_src
** Define utilities for formatting options
#+begin_src emacs-lisp
(defun cb-lib:columnate-lines (lines column-width)
  "Columnate LINES by splitting the lines into two lists then
zipping them together again, such that:

  '(A B C D)

becomes:

  A C
  B D

COLUMN-WIDTH sets the width of each column."
  (let* ((mid (ceiling (/ (length lines) 2.0)))
         (xs (-slice lines 0 mid))
         (ys (-slice lines mid)))
    (->>
        ;; Add an extra line to YS if there is an odd number of options so
        ;; the zip does not discard an option.
        (if (/= (length xs) (length ys))
            (-concat ys '(""))
          ys)
      (-zip-with
       (lambda (l r) (concat (s-pad-right column-width " " l) r)) xs)
      (s-join "\n"))))

(defun cb-lib:maybe-columnate-lines (thresh-hold column-width lines)
  "Return a formatted string that may columnate the input.
The columnation will occur if LINES exceeds THRESH-HOLD in length.
COLUMN-WIDTH specifies the width of columns if columnation is used."
  (if (< (length lines) thresh-hold)
      (s-join "\n" lines)
    (cb-lib:columnate-lines lines column-width)))
#+end_src
** Define utilities for reading options from the user
#+begin_src emacs-lisp
(defun cb-lib:read-opt (option-key-fn options)
  "Read an option from the user.
Returns the element in OPTIONS matching the key event. The \"q\"
key will abort the loop if there is no option bound to \"q\"."
  (let ((c (read-char-choice "" (-concat
                                 (-map (-compose 'string-to-char option-key-fn) options)
                                 (list ?\q)))))
    (or
     ;; Return option with the read key.
     (-first (-compose (~ equal c) 'string-to-char option-key-fn)
             options)
     ;; Cancel if the user had entered \q\ and no option was matched.
     (user-error ""))))

(defun window-bounds ()
  "The width of the selected window, minus the fringe."
  (- (window-width)
     (fringe-columns 'left)
     (fringe-columns 'right)))

(defun read-option (title option-key-fn option-name-fn options)
  "Prompt the user to select from a list of choices.
Return the element in a list of options corresponding to the user's selection.

- TITLE is the name of the buffer that will be displayed.

- OPTION-KEY-FN is a function that returns the key (as a string)
  to use for a given option.

- OPTION-NAME-FN is a function that returns a string describing a given option.

- OPTIONS is a list of items to present to the user."
  (save-excursion
    (save-window-excursion
      ;; Split the window and create a buffer containing the options.

      (let ((win (split-window-below)))
        (select-window win)
        (with-current-buffer (get-buffer-create title)
          (set-window-buffer win (current-buffer))

          ;; 1. Format the options for insertion.

          (let* ((longest-key
                  (-max (-map (-compose 'length option-key-fn) options)))
                 ;; Transform the options list into a list of lines of
                 ;; "[key] desc"
                 (lines
                  (->> options
                    (-sort (-on 'string< (-compose 's-downcase option-key-fn)))
                    (--map
                     (let ((key
                            (propertize (funcall option-key-fn it) 'face 'option-key)))
                       (format " %s %s"
                               (s-pad-right
                                (+ 2 longest-key) ; Offset by length of square brackets.
                                " " (concat "[" key "]"))
                               (funcall option-name-fn it)))))))

            (erase-buffer)
            (insert
             ;; Show small numbers of options in a single column. If the number
             ;; of lines exceeds 3, split into 2 columns.
             (cb-lib:maybe-columnate-lines 3
                                           (/ (window-bounds) 2)
                                           lines))

            ;; 2. Prepare window.

            (goto-char (point-min))
            (fit-window-to-buffer)

            ;; 3. Read selection from user.
            (unwind-protect
                (cb-lib:read-opt option-key-fn options)
              (kill-buffer title))))))))

#+end_src
** Define high-level macro for declaring an option picker
#+begin_src emacs-lisp
(cl-defmacro define-command-picker (name &key title options)
  "Define a command that will display an option picker for the user.

- NAME is the name of the command.

- TITLE is the name of the options buffer to display.

- OPTIONS is a list of options.

Each option is a list of the form (KEY LABEL COMMAND [&key MODES WHEN UNLESS]), where:

- KEY is a string representing the key sequence for the option

- LABEL is a string describing the option

- COMMAND is the command that will be called if this option is selected

- The optional predicates MODES, WHEN and UNLESS control whether
  an option should be displayed. MODES is a symbol or list of
  symbols naming the modes in which the option is available. WHEN
  and UNLESS are nullary functions.

If the predicates are omitted the option will always be shown."
  (cl-assert (not (null options)))
  (cl-assert (stringp title))
  (let ((varname (intern (format "%s-options" name))))
    `(progn

       (defvar ,varname nil ,(format "The list of options shown by `%s'" name))
       (setq ,varname ,options)

       (defun ,name ()
         "Auto-generated option picker."
         (interactive)
         (cl-destructuring-bind (_ _ fn &rest rst)
             (read-option ,title 'car 'cadr
                          ;; Call the predicates for each option to determine
                          ;; whether to display it.
                          (-filter (lambda+
                                     ((&key modes
                                            (when '-true-fn)
                                            (unless '-nil-fn)
                                            &allow-other-keys))
                                     (and
                                      (if modes
                                          (apply 'derived-mode-p (-listify modes))
                                        t)
                                      (funcall when)
                                      (not (funcall unless))))
                                   ,varname))
           ;; Call the option selected by the user.
           (if (commandp fn)
               (call-interactively fn)
             (funcall fn)))))))
#+end_src
* Shell convenience functions
#+begin_src emacs-lisp
(defvar %-sudo-liftable-commands '(%-sh
                                   %-async
                                   %-string
                                   shell-command
                                   async-shell-command
                                   shell-command-to-string)
  "A list of commands that may be escalated using the `%-sudo' macro.

`%-sudo' operates by modifying the string passed to the shell.
For this to work, all commands in this list must accept a string
as their first parameter.")

(defalias '%-quote 'shell-quote-argument)

(defun %-sh (command &rest arguments)
  "Run COMMAND with ARGUMENTS, returning the exit code."
  (shell-command (concat command " " (s-join " " arguments))))

(defun %-string (command &rest arguments)
  "Run COMMAND with ARGUMENTS, returning its output as a string."
  (s-trim-right
   (shell-command-to-string (concat command " " (s-join " " arguments)))))

(defun %-async (command &rest arguments)
  "Run COMMAND with ARGUMENTS asynchronously."
  (save-window-excursion
    (async-shell-command (concat command " " (s-join " " arguments)))))

(defun %-can-sudo-without-passwd? ()
  "Test whether we are currently able to sudo without entering a password."
  (zerop (shell-command "sudo -n true")))

(defmacro %-sudo (command)
  "Execute a shell command with escalated privileges.

COMMAND must be a direct call to one of the forms listed in
`sudo-liftable-commands'.

The sudo command will likely be configured with a timeout on your
system.  The user will be interactively prompted for their
password if necessary.  Subsequent calls to sudo within the
timeout period will not require the password again."
  (cl-assert command)
  (cl-assert (listp command))
  (cl-assert (-contains? %-sudo-liftable-commands (car command)))

  ;; Reach into the command and replace the direct shell command argument,
  ;; wrapping it with a call to sudo.
  ;;
  ;; There are two execution paths, depending on whether the user is currently
  ;; authenticated with sudo.
  (cl-destructuring-bind (fn cmd &rest args) command
    (let ((g-passwd (cl-gensym))
          (g-result (cl-gensym)))
      `(-if-let (,g-passwd (unless (%-can-sudo-without-passwd?)
                             (read-passwd "Password: ")))

           ;; Path 1. The password is required: Consume the password and
           ;; tidy the shell output. Finally, delete the password string from
           ;; memory.
           (unwind-protect
               (let ((,g-result
                      (,fn
                       (format "echo %s | sudo -S %s"
                               (shell-quote-argument ,g-passwd) ,cmd)
                       ,@args)))
                 ;; Annoyingly, the password prompt gets prepended to string
                 ;; output and must be stripped.
                 (if (stringp ,g-result)
                     (s-chop-prefix "Password:" ,g-result)
                   ,g-result))
             ;; Clear the password from memory.
             (clear-string ,g-passwd))

         ;; Path 2. We are within the sudo timeout period: The password is not
         ;; required and we can call the command with sudo prefixed.
         (,fn (format "sudo %s" ,cmd) ,@args)))))
#+end_src
* Buffer and window list commands
** Filter buffer list
#+begin_src emacs-lisp
(cl-defmacro --filter-buffers (pred-form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-filter-buffers'"
  `(--filter (with-current-buffer it ,pred-form) ,bufs))
#+end_src
** Map over buffer list
#+begin_src emacs-lisp
(cl-defmacro --map-buffers (form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-map-buffers'"
  `(--map (with-current-buffer it ,form) ,bufs))
#+end_src
** Find first buffer matching predicate
#+begin_src emacs-lisp
(cl-defmacro --first-buffer (pred-form &optional (bufs '(buffer-list)))
  "Anaphoric form of `-first-buffer'"
  `(--first (with-current-buffer it ,pred-form) ,bufs))
#+end_src
** Find first window matching predicate
#+begin_src emacs-lisp
(defalias '-first-window 'get-window-with-predicate)

(defmacro --first-window (pred-form)
  "Anaphoric form of `-first-window'.
Find the first window where PRED-FORM is not nil."
  `(-first-window (lambda (it) ,pred-form)))
#+end_src
** Display a list of buffers, Exposé-style
#+begin_src emacs-lisp
(cl-defun expose-buffers
    (buffers &optional (sort-fn (-on 'string< 'buffer-file-name)))
  "Show an Exposé-style arrangement of BUFFERS."
  (when buffers
    (delete-other-windows)
    (let* ((live (-filter 'buffer-live-p (-sort sort-fn buffers)))
           (padded (if (cl-evenp (length live)) live (nreverse (cons nil (nreverse live)))))
           (bs (apply '-zip (-partition (/ (length padded) 2) padded))))

      (when live
        (switch-to-buffer (caar bs) t))

      ;; Split sensibly for 2-up view, otherwise show a grid.
      (cond
       ((= 1 (length bs))
        (-when-let (bot (cdar bs))
          (select-window (split-window-sensibly))
          (switch-to-buffer bot)))

       (t
        (-each (cdr bs)
               (lambda+ ((top . bot))
                 (select-window (split-window-horizontally))
                 (switch-to-buffer top)
                 (balance-windows)))
        (-each bs
               (lambda+ ((top . bot))
                 (select-window (get-buffer-window top))
                 (when bot
                   (select-window (split-window-vertically))
                   (switch-to-buffer bot)))))))))
#+end_src
* Define commands to filter the list of interned symbols
#+begin_src emacs-lisp
(defun filter-atoms (predicate)
  "Return the elements of the default obarray that match PREDICATE."
  (let (acc)
    (mapatoms (lambda (atom)
                (when (funcall predicate atom)
                  (push atom acc))))
    acc))

(defmacro --filter-atoms (predicate)
  "Anaphoric form of `filter-atoms'.
Return the elements of the default obarray that match PREDICATE."
  `(filter-atoms (lambda (it) ,predicate)))
#+end_src
* Always use y-or-n-p
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
* Define an alias for make-local-hook to prevent errors
#+begin_src emacs-lisp
(defalias 'make-local-hook 'ignore)
#+end_src
* Set default directory
When starting up, set the default dir to the home directory on OS X. This
prevents the app bundle from being used as the default dir.
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (unless (ignore-errors (emacs-init-time))
    (setq default-directory user-home-directory)))
#+end_src
* Don't ring the bell on errors
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src
* Don't show startup message
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
#+end_src
* Don't add anything to the default scratch buffer
#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src
* Highlight active regions, like most editors
#+begin_src emacs-lisp
(setq-default transient-mark-mode t)
#+end_src
* Add commands for asynchronously installing packages
** Define an icon for package-related growl notifications
#+begin_src emacs-lisp
(defvar cbpkg:package-icon (f-join cb:assets-dir "package.png"))
#+end_src
** Define a command for updating packages in the background
#+begin_src emacs-lisp
(defun cbpkg:install-packages (pkgs)
  ;; Show summary of packages to be installed.
  (-when-let (len (and pkgs (length pkgs)))
    (growl "Installing Packages"
           (format "%s package%s will be installed or updated:\n%s"
                   len
                   (if (= 1 len) "" "s")
                   (s-join ", " (-map 'pp-to-string pkgs)))
           cbpkg:package-icon)
    ;; Perform installation.
    (-each pkgs 'package-install)))

(defun cbpkg:updateable-packages ()
  "Return the packages with available updates."
  ;; The easiest way to get this info is from the package menu.
  (-keep 'car
         (save-window-excursion
           (save-excursion
             (package-list-packages t)
             (package-menu--find-upgrades)))))

(defun update-packages ()
  "Update all installed packages in the background."
  (interactive)
  (growl "Starting Updates"
         "Updating packages in the background."
         cbpkg:package-icon)
  (async-start

   `(lambda ()
      (load-file ,user-init-file)
      (package-refresh-contents)
      (let ((pkgs (cbpkg:updateable-packages)))
        (cbpkg:install-packages pkgs)
        (length pkgs)))

   (lambda (len)
     (package-initialize)
     (if (zerop len)
         (growl "Updates Finished"
                "No packages needed to be updated."
                cbpkg:package-icon)

       (growl "Updates Finished"
              (concat
               (format "%s package%s %s updated " len
                       (if (= 1 len) "" "s")
                       (if (= 1 len) "was" "were"))
               "and will be loaded next time Emacs is started.")
              cbpkg:package-icon)))))
#+end_src
* OS X
** CONDITIONAL
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
#+end_src
** Invoke login shells, so that .profile is read
#+begin_src emacs-lisp
(setq shell-command-switch "-lc")
#+end_src
** Set exec path
Emacs.app does not inherit the PATH set by shell config files. Set the path
manually as a workaround.
#+begin_src emacs-lisp
(cb:install-package 'exec-path-from-shell t)
(exec-path-from-shell-initialize)
#+end_src
** Override shell
Most packages assume the shell is POSIX-compliant. If the shell is fish, change
to bash to prevent shell commands from borking.
#+begin_src emacs-lisp
(when (s-ends-with? "fish" (getenv "SHELL"))
  (setq shell-file-name "/bin/bash" explicit-shell-file-name shell-file-name)
  (setenv "SHELL"  shell-file-name))
#+end_src
** Use =osx-bbdb= to keep BBDB up-to-date with the OS X Address Book
#+begin_src emacs-lisp
(unless noninteractive
  (after 'bbdb
    (require 'osx-bbdb)))
#+end_src
** Create terminfo so ansi-term displays shells correctly
#+begin_src emacs-lisp
(let ((terminfo (expand-file-name "~/.terminfo")))
  (unless (file-exists-p terminfo)
    (start-process
     "tic" " tic" "tic"
     "-o" terminfo
     "/Applications/Emacs.app/Contents/Resources/etc/e/eterm-color.ti")))
#+end_src
** Use GNU coreutils version of ls if available
#+begin_src emacs-lisp
(setq insert-directory-program (or (executable-find "gls") "ls"))
#+end_src
** Use gnutls when sending emails
#+begin_src emacs-lisp
(setq starttls-gnutls-program (executable-find "gnutls-cli")
      starttls-use-gnutls t)
#+end_src
** Define utilities for playing system sounds
#+begin_src emacs-lisp
(defun osx-find-system-sound (name)
  "Find a system alert matching NAME."
  (when (equal system-type 'darwin)
    (-first (~ s-matches? name) (f-files "/System/Library/Sounds"))))

(defun osx-play-system-sound (name)
  "Play alert matching NAME."
  (when (equal system-type 'darwin)
    (-when-let (snd (osx-find-system-sound name))
      (start-process "appt alert" " appt alert" "afplay" snd))))
#+end_src
** Use system clipboard
#+begin_src emacs-lisp
(defun cb:osx-paste ()
  (shell-command-to-string "pbpaste"))

(defun cb:osx-copy (text &optional _push)
  (let ((process-connection-type nil))
    (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
      (process-send-string proc text)
      (process-send-eof proc))))

(unless window-system
  (setq interprogram-cut-function   'cb:osx-copy
        interprogram-paste-function 'cb:osx-paste))
#+end_src
** Enable printing to postscript
#+begin_src emacs-lisp
(defun ps-print-with-faces-dwim ()
  "Perform a context-sensitive printing command."
  (interactive)
  (call-interactively
   (if (region-active-p)
       'ps-print-region-with-faces
     'ps-print-buffer-with-faces)))
#+end_src
*** Set a key binding for the above command
#+begin_src emacs-lisp
(bind-key* "s-p" 'ps-print-with-faces-dwim)
#+end_src
** Open
*** Open the current directory in the Finder
#+begin_src emacs-lisp
(defun mac-reveal-in-finder ()
  "Open the current directory in the Finder."
  (interactive)
  (%-sh "open ."))
#+end_src
*** Open the thing at point
Define a command that runs =open= in a context-sensitive way.
#+begin_src emacs-lisp
(autoload 'thing-at-point-url-at-point "thingatpt")

(defun cb:visual-url-at-point ()
  "Find a URL at point."
  (or
   ;; Find urls at point.
   (thing-at-point-url-at-point)
   (get-text-property (point) 'shr-url)
   ;; Extract org-mode links.
   (when (and (fboundp 'org-in-regexp)
              (boundp 'org-bracket-link-regexp)
              (org-in-regexp org-bracket-link-regexp 1))
     (org-link-unescape (org-match-string-no-properties 1)))))

(defun mac-open-dwim (open-arg)
  "Pass OPEN-ARG to OS X's open command.
When used interactively, makes a guess at what to pass."
  (interactive
   (list
    (ido-read-file-name
     "Open: " nil (or
                   (cb:visual-url-at-point)
                   (and (boundp 'w3m-current-url) w3m-current-url)
                   (and (derived-mode-p 'dired-mode)
                        (read-file-name(dired-get-file-for-visit)))
                   (buffer-file-name)))))

  (%-sh (format "open '%s'" open-arg)))
#+end_src
*** Evil
Set evil-mode bindings for the previous commands.
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal (kbd "g o") 'mac-open-dwim)
  (evil-global-set-key 'normal (kbd "g O") 'mac-reveal-in-finder))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Notifications
#+begin_src emacs-lisp
(cl-defun growl (title
                 message
                 &optional (icon "/Applications/Emacs.app/Contents/Resources/Emacs.icns"))
  "Display a growl notification.
Fall back to `message' if growlnotify is not installed.
The notification will have the given TITLE and MESSAGE."
  (let ((growl-program "growlnotify"))
    (if (executable-find growl-program)
        ;; Call growl
        (let ((proc (start-process "growl" nil
                                   growl-program
                                   title
                                   "-n" "Emacs"
                                   "-a" "Emacs"
                                   "--image" icon)))
          (process-send-string proc message)
          (process-send-string proc "\n")
          (process-send-eof proc))
      ;; Fall back to message.
      (message "%s. %s" title message))))
#+end_src
* Display-related variables
#+begin_src emacs-lisp
(setq redisplay-dont-pause t
      echo-keystrokes 0.02
      truncate-partial-width-windows nil)
#+end_src
* Use org-mode as the default mode
#+begin_src emacs-lisp
(setq          initial-major-mode 'org-mode)
(setq-default  major-mode         'org-mode)
#+end_src
* File handling
** Don't prompt the user to continue when visiting a file that does not exist
#+begin_src emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)
#+end_src
** Don't use the trash when deleting files--just delete immediately
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash nil)
#+end_src
** Automatically decompress files to read and recompress on write
#+begin_src emacs-lisp
(auto-compression-mode +1)
#+end_src
** Make scripts executable on save
#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src
* Whitespace handling
** Perform whitespace cleanup on save
#+begin_src emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Fix `whitespace-cleanup' bug in Emacs 24
When using `indent-tabs-mode', whitespace cleanup will untabify the buffer,
breaking makefiles.
#+begin_src emacs-lisp
(defadvice whitespace-cleanup (around whitespace-cleanup-indent-tab activate)
  (let ((whitespace-indent-tabs-mode indent-tabs-mode)
        (whitespace-tab-width tab-width))
    ad-do-it))
#+end_src
** Add a space after opening a new comment line
#+begin_src emacs-lisp
(defadvice comment-indent-new-line (after add-space activate)
  (when (and comment-start
             (thing-at-point-looking-at (regexp-quote comment-start)))
    (unless (or (thing-at-point-looking-at (rx (+ space))))
      (just-one-space))))
#+end_src
** Remove trailing whitespace after yanking text
#+begin_src emacs-lisp
(defadvice insert-for-yank (after clean-whitespace)
  (whitespace-cleanup)
  (delete-trailing-whitespace))
#+end_src
* Buffer formatting
** By default, ensure each saved file ends with a newline
#+begin_src emacs-lisp
(setq require-final-newline t)
#+end_src
** Don't require two spaces at the end of a sentence
This is a wacky American convention that can't die fast enough.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
** Hide DOS eol characters
#+begin_src emacs-lisp
(hook-fn 'find-file-hook
  "Hide DOS EOL chars."
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M [])
  (aset buffer-display-table ?\^L []))
#+end_src
* Tabs
** Always use spaces instead of tabs
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src
** Set tab width for buffers that use tabs for indentation
#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src
* Fill
** Use auto-fill-mode for org-mode, which is the default text editing mode
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
** Increase the fill column
This defines the maximum column before the line will be wrapped by fill commands
or auto-fill-mode.
#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src
* Bookmarks
I don't actually use this feature, but make sure the bookmarks file is created
in a subdir of the Emacs directory to keep things clean.
#+begin_src emacs-lisp
(setq bookmark-default-file (f-join cb:tmp-dir "bookmarks"))
#+end_src
* Save position in files between sessions
#+begin_src emacs-lisp
(setq save-place-file (f-join cb:tmp-dir "saved-places"))
(setq-default save-place t)

(unless noninteractive
  (require 'saveplace)
  (add-hook 'kill-emacs-hook   'save-place-kill-emacs-hook)
  (add-hook 'kill-buffer-hook  'save-place-to-alist)
  (add-hook 'find-file-hook    'save-place-find-file-hook t)
  (add-hook 'server-visit-hook 'save-place-find-file-hook)
  (add-hook 'server-done-hook  'save-place-kill-emacs-hook))
#+end_src
* Save backup files to a special directory
#+begin_src emacs-lisp
(require 'backup-dir)
(setq auto-save-file-name-transforms `((".*" ,(concat cb:autosaves-dir "\\1") t))
      backup-by-copying        t
      bkup-backup-directory-info `((".*" ,cb:backups-dir ok-create))
      auto-save-list-file-name (concat cb:autosaves-dir "autosave-list")
      delete-old-versions      t
      kept-new-versions        6
      kept-old-versions        2
      version-control          t)
#+end_src
* Initialise recent files list
Recentf adds a recent files list. It is also used by helm and other packages to
show recent files.
#+begin_src emacs-lisp
(require 'recentf)
#+end_src
** Keep the recentf file in tmp
#+begin_src emacs-lisp
(setq recentf-save-file (f-join cb:tmp-dir "recentf"))
#+end_src
** Set limits on the number of files to save with recentf
#+begin_src emacs-lisp
(setq recentf-max-saved-items 50
      recentf-max-menu-items  10)
#+end_src
** Automatically remove deleted files
#+begin_src emacs-lisp
(setq recentf-keep '(file-remote-p file-readable-p))
#+end_src
** Define the files to exclude from recentf
#+begin_src emacs-lisp
(setq recentf-exclude '(
                        ;; Filetypes
                        "\\.elc$"
                        "TAGS"
                        "\\.gz$"
                        "#$"
                        ;; Special directories
                        "/elpa/"
                        "/tmp/"
                        "/temp/"
                        ".emacs.d/url/"
                        "/\\.git/"
                        "/Emacs.app/"
                        "/var/folders/"
                        ;; Tramp
                        "^/?sudo"
                        ;; Special files
                        "\\.bbdb"
                        "\\.newsrc"
                        "/gnus$"
                        "/gnus.eld$"
                        "\\.ido\\.last"
                        "\\.org-clock-save\\.el$"
                        ))
#+end_src
** Suppress messages when cleaning recent files list
#+begin_src emacs-lisp
(defadvice recentf-cleanup (around hide-messages activate)
  (noflet ((message (&rest args))) ad-do-it))
#+end_src
** Enable recentf
#+begin_src emacs-lisp
(recentf-mode +1)
#+end_src
* Save command history between sessions
** Configure variables
#+begin_src emacs-lisp
(setq savehist-additional-variables '(search ring regexp-search-ring)
      savehist-autosave-interval    60
      savehist-file                 (f-join cb:tmp-dir "savehist"))
#+end_src
** Safely enable savehist
This can sometimes fail with a void-variable error. In such a
case, just delete the cache and start afresh.
#+begin_src emacs-lisp
(condition-case _
    (savehist-mode +1)
  (void-variable
   (delete-file savehist-file)
   (savehist-mode +1)))
#+end_src
* Tramp
Ensure tramp resources are released properly on exit. This prevents certain
crashes in Emacs 24.
#+begin_src emacs-lisp
(hook-fn 'kill-emacs-hook
  (ignore-errors
    (when (fboundp 'tramp-cleanup-all-buffers)
      (tramp-cleanup-all-buffers))))
#+end_src
* Define command for generating passwords
#+begin_src emacs-lisp
(defun generate-password (length)
  "Generate a password with a given LENGTH."
  (interactive (list (read-number "Password length: " 32)))
  (let ((pass
         (--> (%-string "openssl" "rand" "-base64" (number-to-string length))
           ;; The encoding process will pad with '=' characters to reach a
           ;; length divisible by 4 bytes. Drop this padding.
           (substring it 0 length))))
    (cond
     ((called-interactively-p 'any)
      (kill-new pass)
      (message "Password copied to kill ring."))
     (t
      pass))))
#+end_src
* Use UTF-8 for all text encodings
#+begin_src emacs-lisp
(setq locale-coding-system   'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system        'utf-8)
#+end_src
* Keyboard macros
** Define a way to prompt for input in keyboard macros
#+begin_src emacs-lisp
(defun minibuffer-macro-query (arg)
  "Prompt for input using minibuffer during kbd macro execution.
With prefix ARG, allows you to select what prompt string to use.
If the input is non-empty, it is inserted at point."
  (interactive "P")
  (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
         (input (minibuffer-with-setup-hook (lambda () (kbd-macro-query t))
                  (read-from-minibuffer prompt))))
    (unless (string= "" input) (insert input))))
#+end_src
** Bind the above command during macro definitions
#+begin_src emacs-lisp
(define-key kmacro-keymap (kbd "C-/") 'minibuffer-macro-query)
#+end_src
* Clipboard
#+begin_src emacs-lisp
(setq x-select-enable-clipboard t)
#+end_src
* Input methods
** Use TeX as the default alternative input method
This allows you to enter mathematical symbols easily.
#+begin_src emacs-lisp
(setq default-input-method "TeX")
#+end_src
** Define a key command for setting method
#+begin_src emacs-lisp
(bind-key "C-x C-\\" 'set-input-method)
#+end_src
* Global key bindings
** When on a comment, RET creates a new line that continues the comment
#+begin_src emacs-lisp
(bind-key "RET" 'comment-indent-new-line)
#+end_src
** Define a more ergonomic M-x
#+begin_src emacs-lisp
(bind-key* "S-SPC" 'execute-extended-command)
#+end_src
** Kill buffer and delete window on C-backspace
#+begin_src emacs-lisp
(bind-key* "C-<backspace>"
           (command (cond ((< 1 (length (window-list)))
                           (kill-current-buffer)
                           (delete-window))
                          (t
                           (kill-current-buffer)))))
#+end_src
** Enable debugging
#+begin_src emacs-lisp
(bind-key "C-c e e" 'toggle-debug-on-error)
#+end_src
** Use custom indentation command
#+begin_src emacs-lisp
(define-key prog-mode-map (kbd "M-q") 'indent-dwim)
#+end_src
* Buffer killing
** Define a custom kill command
Buries certain buffers rather than killing them.
#+begin_src emacs-lisp
(defvar cb:kill-buffer-ignored-list
  '("*scratch*" "*Messages*" "*Group*"
    "*shell*" "*eshell*" "*ansi-term*"
    "diary.org" "notes.org"))

(defun kill-current-buffer ()
  "Kill the current buffer.
If this buffer is a member of `cb:kill-buffer-ignored-list, bury it rather than killing it."
  (interactive)
  (if (member (buffer-name (current-buffer)) cb:kill-buffer-ignored-list)
      (bury-buffer)
    (kill-buffer (current-buffer))))

(bind-key* "C-x <backspace>" 'kill-current-buffer)
#+end_src
** Define a command that cleans the buffer list
Does not delete terminals, org buffers, or buffers with a running process.
*** Impl
#+begin_src emacs-lisp
(defun clean-buffers ()
  "Close all buffers not in the ignore list."
  (interactive)
  (delete-other-windows)
  (-each (--filter-buffers
          (not (or (-contains? cb:kill-buffer-ignored-list (buffer-name it))
                   (get-buffer-process it))))
         'kill-buffer))
#+end_src
*** Set key binding
#+begin_src emacs-lisp
(bind-key* "C-c k b"  'clean-buffers)
#+end_src
* Show autoloads in file
#+begin_src emacs-lisp
(defun cb:find-autoloads (buffer)
  (->> (with-current-buffer buffer
         (buffer-substring-no-properties (point-min) (point-max)))
    (s-match-strings-all (rx ";;;###autoload" "\n"
                             (* space) "("(+ (not space)) (+ space) (? "'")
                             (group (+ (not space)))))
    (-map 'cadr)))

(cl-defun show-autoloads (&optional (buffer (current-buffer)))
  "Find the autoloaded definitions in BUFFER"
  (interactive)
  (-if-let (results (-map (~ s-append "\n") (cb:find-autoloads buffer)))
    (with-output-to-temp-buffer "*autoloads*"
      (-each results 'princ))

    (error "No autoloads found in current buffer")))
#+end_src
* Window management
** Expose buffers
#+begin_src emacs-lisp
(defun expose-buffers-by-mode (&optional mode arg)
  "Show all buffers with major mode MODE.
With a prefix ARG, show all buffers"
  (interactive (list
                (->> (--filter-buffers
                      (and (derived-mode-p 'prog-mode 'text-mode)
                           (or current-prefix-arg (buffer-file-name))))
                  (--map-buffers (symbol-name major-mode))
                  (-sort 'string<)
                  (-uniq)
                  (ido-completing-read "Mode: ")
                  (intern))

                current-prefix-arg))
  (expose-buffers (--filter-buffers (and (derived-mode-p mode)
                                         (or arg (buffer-file-name))))))
#+end_src
** Rotate buffers in windows
#+begin_src emacs-lisp
(defun cb:rotate-buffers ()
  "Rotate active buffers, retaining the window layout.
Changes the selected buffer."
  (interactive)
  ;; Bail if there are not enough windows to rotate.
  (unless (> (count-windows) 1)
    (user-error "Cannot rotate single window"))
  ;; Perform rotation.
  (let ((i 1)
        (n-windows (count-windows)))
    (while  (< i n-windows)
      (let* (
             (w1 (elt (window-list) i))
             (w2 (elt (window-list) (+ (% i n-windows) 1)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2))
             )
        (set-window-buffer w1  b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)
        (setq i (1+ i))))))

(bind-key* "s-f" 'cb:rotate-buffers)
#+end_src
* Transpose lines
** Define commands to transpose lines
#+begin_src emacs-lisp
(defun move-line-up ()
  "Move the current line up."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (org-move-item-up)

    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode)))

(defun move-line-down ()
  "Move the current line up."
  (interactive)
  (if (derived-mode-p 'org-mode)
      (org-move-item-down)

    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode)))
#+end_src
** Define global key bindings
#+begin_src emacs-lisp
(bind-key* "C-<up>" 'move-line-up)
(bind-key* "C-<down>" 'move-line-down)
#+end_src
* Version Control (VC)
** Do not prompt to follow symlinks
Do not prompt for confirmation when opening a symlink to a file under version
control.
#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
#+end_src
** Use Git only
Only enable Git by default, since all the projects I work on use Git these days.
#+begin_src emacs-lisp
(setq vc-handled-backends '(Git))
#+end_src
** Autoload functions that are used throughout this config
#+begin_src emacs-lisp
(autoload 'vc-git-root "vc-git")
#+end_src
* Enable commands
Enable commands that are disabled by default.
#+begin_src emacs-lisp
(put 'downcase-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
#+end_src
* Exiting Emacs
** Define custom commands for exiting Emacs
Makes exiting Emacs and killing emacsclient instances consistent.
#+begin_src emacs-lisp
(defun cb:exit-emacs ()
  (interactive)
  (when (yes-or-no-p "Kill Emacs? ")
    (save-buffers-kill-emacs)))

(defun cb:exit-emacs-dwim ()
  (interactive)
  (when (yes-or-no-p "Kill Emacs? ")
    (if (daemonp)
        (server-save-buffers-kill-terminal nil)
      (save-buffers-kill-emacs))))
#+end_src
** Suppress "Active processes exist" query when exiting Emacs
#+begin_src emacs-lisp
(defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
  (noflet ((process-list () nil))
    ad-do-it))
#+end_src
** Rebind exit keys to prevent accidental exits when using org-mode
#+begin_src emacs-lisp
(bind-key* "C-x C-c" (command (message "Type <C-c k k> to exit Emacs")))
(bind-key* "C-c k k" 'cb:exit-emacs-dwim)
(bind-key* "C-c k e" 'cb:exit-emacs)
#+end_src
* Narrowing
** Enable narrowing commands
#+begin_src emacs-lisp
(put 'narrow-to-defun  'disabled nil)
(put 'narrow-to-page   'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src
** Define a narrowing command picker
#+begin_src emacs-lisp
(define-command-picker narrowing-picker
  :title "*Narrowing*"
  :options
  '(("d" "Defun" narrow-to-defun :modes prog-mode)
    ("r" "Region" narrow-to-region :when region-active-p)
    ("w" "Widen" widen :when buffer-narrowed-p)
    ("b" "Block (org)" org-narrow-to-block :modes org-mode)
    ("e" "Element (org)" org-narrow-to-element :modes org-mode)
    ("s" "Subtree (org)" org-narrow-to-subtree :modes org-mode)))
#+end_src
** Create a binding for the narrowing picker
#+begin_src emacs-lisp
(bind-key* "C-x n" 'narrowing-picker)
#+end_src
* Insertion commands
** Insert time stamp with helm
#+begin_src emacs-lisp
(defun insert-timestamp ()
  "Read a timestamp from the user and insert it at point."
  (interactive)
  (let ((time (current-time)))
    (helm :prompt "Timestamp: "
          :buffer "*Helm Timestamp*"
          :sources
          `(((name . "Dates")
             (candidates . ,(list
                             (format-time-string "%d-%m-%y" time)
                             (format-time-string "%d-%m-%Y" time)
                             (format-time-string "%d-%m-%Y %H:%M" time)
                             (format-time-string "%d-%m-%Y %I:%M %p" time)))
             (action . insert)
             (volatile))

            ((name . "Times")
             (candidates . ,(list
                             (format-time-string "%X" time)
                             (format-time-string "%I:%M %p" time)
                             (format-time-string "%I:%M:%S %p" time)))
             (action . insert)
             (volatile))

            ((name . "Special")
             (candidates . ,(list
                             (format-time-string "%d %B, %Y" time)
                             (format-time-string "%Y-%m-%dT%H%M%S%z")))
             (action . insert)
             (volatile))))))
#+end_src
** Insert shebang
#+begin_src emacs-lisp
(defun cb:filename->interpreter (filename)
  (cdr
   (assoc (file-name-extension filename)
          '(("el" . "emacs")
            ("hs" . "runhaskell")
            ("py" . "python")
            ("rb" . "ruby")
            ("sh" . "bash")))))

(defun insert-shebang (cmd)
  "Insert a shebang line at the top of the current buffer.
Prompt for a command CMD if one cannot be guessed."
  (interactive
   (list (or (cb:filename->interpreter buffer-file-name)
             (read-string "Command name: " nil t))))
  (require 'emr)
  (emr-reporting-buffer-changes "Inserted shebang"
    (save-excursion
      (goto-char (point-min))
      (open-line 2)
      (insert (concat "#!/usr/bin/env " cmd)))))
#+end_src
** Insert variable
#+begin_src emacs-lisp
(defun insert-variable (variable)
  "Insert the value of VARIABLE at point."
  (interactive
   (list
    (intern
     (ido-completing-read
      "Variable: "
      (-map 'symbol-name
            (filter-atoms (-orfn 'custom-variable-p 'special-variable-p)))))))
  (insert (pp-to-string (eval variable))))
#+end_src
** Insert GUID
#+begin_src emacs-lisp
(defun make-uuid ()
  "Generate a UUID using the uuid utility."
  (%-string "uuidgen"))

(defun insert-uuid ()
  "Insert a GUID at point."
  (interactive "*")
  (insert (make-uuid)))

(defalias 'insert-guid 'insert-uuid)
#+end_src
** Insert lorem ipsum text
#+begin_src emacs-lisp
(defun insert-lorem-ipsum (n-paragraphs paragraph-length)
  "Insert N-PARAGRAPHS of lorem ipsum text into the current buffer.
PARAGRAPH-LENGTH is one of short, medium, long or verylong."
  (interactive
   (list (read-number "Number of paragraphs: " 3)
         (ido-completing-read "Paragraph length: "
                              '("short" "medium" "long" "verylong"))))
  (let ((url (format "http://loripsum.net/api/%s/%s/plaintext"
                     n-paragraphs paragraph-length)))
    (insert (with-current-buffer (url-retrieve-synchronously url)
              ;; Skip HTTP header.
              (goto-char (point-min))
              (search-forward "\n\n")
              (s-trim (buffer-substring (point) (point-max)))))))
#+end_src
** Command picker
*** Define a command picker for insertion commands
#+begin_src emacs-lisp
(define-command-picker insertion-picker
  :title "*Insert*"
  :options
  '(("F" "File" insert-file)
    ("L" "Lorem Ipsum" insert-lorem-ipsum)
    ("T" "Timestamp" insert-timestamp)
    ("U" "UUID" insert-uuid)
    ("V" "File Local Var" add-file-local-variable)
    ("P" "File Local Var (prop line)" add-file-local-variable-prop-line)))
#+end_src
*** Bind insertion picker to a global key
#+begin_src emacs-lisp
(bind-key* "C-c i" 'insertion-picker)
#+end_src
* Indentation commands
** Define command to remove indentation
*** Impl
#+begin_src emacs-lisp
(defun outdent ()
  "Remove indentation on the current line."
  (interactive "*")
  (save-excursion
    (goto-char (line-beginning-position))
    (delete-horizontal-space)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(global-set-key (kbd "<backtab>") 'outdent)
#+end_src
** Define command to indent whole buffer
#+begin_src emacs-lisp
(defun indent-buffer ()
  "Indent the whole buffer."
  (interactive)
  (ignore-errors
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (indent-for-tab-command)
        (forward-line)))))
#+end_src
** Define a dwim command that indents, fills paragraphs, etc
#+begin_src emacs-lisp
(defun indent-dwim (&optional arg)
  "Perform a context-sensitive indentation action.
With prefix argument ARG, justify text."
  (interactive "P")
  (cond
   ((region-active-p)
    (indent-region (region-beginning) (region-end))
    (message "Indented region."))

   ((-contains? '(font-lock-comment-face
                  font-lock-string-face
                  font-lock-doc-face)
                (face-at-point))
    (if (apply 'derived-mode-p cb:lisp-modes)
        (lisp-fill-paragraph arg)
      (fill-paragraph arg))
    (message "Filled paragraph."))

   (t
    (indent-buffer)
    (message "Indented buffer."))))
#+end_src

Use for all programming modes
#+begin_src emacs-lisp
(define-key prog-mode-map (kbd "M-q") 'indent-dwim)
#+end_src
* Editing commands
** Insert comma, then space
#+begin_src emacs-lisp
(defun cb:comma-then-space ()
  (interactive)
  (atomic-change-group
    (insert-char ?\,)
    (just-one-space)))
#+end_src
* Buffer file commands
** Delete current buffer and file
#+begin_src emacs-lisp
(defun delete-buffer-and-file ()
  "Delete a file and its associated buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defalias 'delete-file-and-buffer 'delete-buffer-and-file)
#+end_src
** Rename current buffer and file
#+begin_src emacs-lisp
(defun rename-buffer-and-file ()
  "Rename the current buffer and file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (message "Buffer is not visiting a file!")
      (let ((new-name (read-file-name "New name: " filename)))
        (cond
         ((vc-backend filename) (vc-rename-file filename new-name))
         (t
          (rename-file filename new-name t)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))))

(defalias 'rename-file-and-buffer 'rename-buffer-and-file)
#+end_src
* Sorting commands
** Define a command picker for sorting
#+begin_src emacs-lisp
(define-command-picker sorting-picker
  :title "*Sorting*"
  :options
  '(("a" "Alpha" sort-lines)
    ("A" "Alpha (reverse)" (lambda () (sort-lines t (region-beginning) (region-end))))
    ("r" "Reverse" reverse-region)))
#+end_src
** Org-mode compatibility
Define a command that will use the appropriate sorting picker for the current
mode. In org-mode, use the built-in picker. Otherwise use the picker defined
above.
#+begin_src emacs-lisp
(defun cb:sort-dispatch ()
  "Open the appropriate sorting picker for the current mode."
  (interactive)
  (cond
   ((derived-mode-p 'org-mode)
    (call-interactively 'org-sort))
   ((region-active-p)
    (call-interactively 'sorting-picker))
   (t
    (user-error "Sort commands require a region to be active"))))
#+end_src
** Set global key binding
#+begin_src emacs-lisp
(bind-key* "C-c ^" 'cb:sort-dispatch)
#+end_src
* Viewing commands
** Define a picker for showing certain buffers
#+begin_src emacs-lisp
(define-command-picker viewing-picker
  :title "*Viewing*"
  :options
  '(("i" "IRC" show-irc)
    ("m" "Exposé (mode)" expose-buffers-by-mode)))
#+end_src
** Key binding
#+begin_src emacs-lisp
(bind-key* "C-c v" 'viewing-picker)
#+end_src
* Search commands
Define a search picker.
** Implementation
*** Define a data structure to represent a search method
#+begin_src emacs-lisp
(cl-defun cbs-search-method (&key
                             name key command
                             (when (lambda () t))
                             (unless (lambda () nil)))
  (list name key command
        `(lambda ()
           (and (funcall ',when)
                (not (funcall ',unless))))))

(cl-defun cbs-search-method-name ((n _ _ _)) n)
(cl-defun cbs-search-method-key  ((_ k _ _)) k)
(cl-defun cbs-search-method-func ((_ _ f _)) f)
(cl-defun cbs-search-method-pred ((_ _ _ p)) p)
#+end_src
*** Define a variable to maintain a global list of search methods
#+begin_src emacs-lisp
(defvar cbs:search-methods nil
  "The list of search methods used by `cbs-search'.")
#+end_src
*** Define a command to add a search method
#+begin_src emacs-lisp
(defun cbs-read (source-name &optional default)
  "Read a query for SOURCE-NAME with an optional DEFAULT."
  (let ((prompt (if default
                    (format "%s (default: %s): " source-name default)
                  (format "%s: " source-name))))
    (read-string prompt nil t default)))

(cl-defun cbs-define-search-method (&rest spec)
  "Define a new search method.
NAME is the user-facing description.
KEY is used to select it from the menu.
SEARCH-FUNC is a unary function that will be passed the query string.
PRED is a predicate to determine whether search method is currently available.

\(fn &key name key command when unless)"
  (add-to-list 'cbs:search-methods (apply 'cbs-search-method spec)))

(defun cbs-search ()
  "Submit a query to a selected search provider."
  (interactive)
  (message "Select search method")
  (let ((default-search-term
          (-when-let (s (or (current-region) (thing-at-point 'symbol)))
            (substring-no-properties s)))
        (m
         (read-option
          "*Select Search*"
          'cbs-search-method-key 'cbs-search-method-name
          (->> cbs:search-methods
            ;; Use methods without a predicate or where the
            ;; predicate returns non-nil.
            (--filter
             (-if-let (p (cbs-search-method-pred it))
                 (funcall p)
               t))
            ;; Drop duplicated options.
            (-uniq-by (π cbs-search-method-name cbs-search-method-key))
            ;; Sort by key.
            (-sort (-on 'string< (C s-upcase cbs-search-method-key)))))))
    (funcall (cbs-search-method-func m) default-search-term)))
#+end_src

*** Create a global key binding for the search picker
#+begin_src emacs-lisp
(bind-key* "M-s" 'cbs-search)
#+end_src
** Define search methods
#+begin_src emacs-lisp
(cbs-define-search-method
 :name "Dictionary"
 :key "d"
 :command
 (lambda (q)
   (dictionary-search (cbs-read "Dictionary" q))))

(cbs-define-search-method
 :name "Org Files"
 :key "o"
 :command (lambda (_)
            (call-interactively 'org-search-view)))

(cbs-define-search-method
 :name "Web Search"
 :key "s"
 :command
 (lambda (q)
   (browse-url
    (concat "https://duckduckgo.com/?q="
            (url-hexify-string (cbs-read "Duck Duck Go" q))))))

(cbs-define-search-method
 :name "Image Search"
 :key "i"
 :command
 (lambda (q)
   (browse-url
    (concat "https://www.google.co.nz/search?tbm=isch&q="
            (url-hexify-string (cbs-read "Google Images" q))))))

(cbs-define-search-method
 :name "YouTube"
 :key "y"
 :command
 (lambda (q)
   (browse-url
    (concat "http://www.youtube.com/results?search_query="
            (url-hexify-string (cbs-read "YouTube" q))))))

(cbs-define-search-method
 :name "Wikipedia"
 :key "w"
 :command
 (lambda (q)
   (browse-url
    (concat "http://en.wikipedia.org/w/index.php?search="
            (url-hexify-string (cbs-read "Wikipedia" q))))))

(cbs-define-search-method
 :name "BBDB"
 :key "b"
 :command
 (lambda (_)
   (call-interactively 'bbdb)))

(cbs-define-search-method
 :name "Man Page"
 :key "m"
 :command
 (lambda (q)
   (require 'helm-man)
   (helm :sources 'helm-source-man-pages
         :buffer "*Helm man woman*"
         :input q)))

(cbs-define-search-method
 :name "Notmuch (mail)"
 :key "n"
 :when (lambda () (executable-find "notmuch"))
 :command
 (lambda (q)
   (notmuch-search (cbs-read "Mail" q))))

(cbs-define-search-method
 :name "GitHub"
 :key "g"
 :command
 (lambda (q)
   (browse-url
    (concat "https://github.com/search?q="
            (url-hexify-string (cbs-read "GitHub Search" q))))))

(cbs-define-search-method
 :name "Info"
 :key "e"
 :command
 (lambda (_)
   (call-interactively 'helm-info-at-point)))
#+end_src
* Help picker
** Define a picker for help commands
#+begin_src emacs-lisp
(define-command-picker help-picker
  :title "*Help Commands*"
  :options
  '(("m" "Messages" view-echo-area-messages)
    ("f" "Find Function" find-function)
    ("l" "Find Library" find-library)
    ("v" "Find Variable" find-variable)
    ("a" "Apropos" apropos)
    ("A" "Apropos (value)" apropos-value)))
#+end_src
** Bind help picker to a key
#+begin_src emacs-lisp
(bind-key "C-h e" 'help-picker)
#+end_src
* Sudo editing
** Define a command to edit files with sudo
#+begin_src emacs-lisp
(cl-defun sudo-edit (&optional (file (buffer-file-name)))
  "Edit FILE with sudo if permissions require it."
  (interactive)
  (when file
    (cond
     ((f-dir? file)
      (error "%s is a directory" file))

     ((file-writable-p file)
      (error "%s: sudo editing not needed" file))

     ;; Prompt user whether to escalate. Ensure the tramp connection is cleaned
     ;; up afterwards.
     ((and (yes-or-no-p "Edit file with sudo?  ")
           (find-alternate-file (concat "/sudo:root@localhost:" file)))
      (add-hook 'kill-buffer-hook 'tramp-cleanup-this-connection nil t)))))
#+end_src
** Offer to edit files with sudo when necessary
#+begin_src emacs-lisp
(defun maybe-sudo-edit ()
  (let ((dir (file-name-directory (buffer-file-name))))
    (when (or (and (not (file-writable-p (buffer-file-name)))
                   (file-exists-p (buffer-file-name)))

              (and dir
                   (file-exists-p dir)
                   (not (file-writable-p dir))))
      (sudo-edit))))

(add-hook 'find-file-hook 'maybe-sudo-edit)
#+end_src
** Add a global key to edit the current file with sudo
#+begin_src emacs-lisp
(bind-key* "C-x e" 'sudo-edit)
#+end_src
* Mode groups
/Mode groups/ are ad-hoc families of modes. They provide hooks for modes that
have commonalities but are not directly related through mode inheritance.

Given the following macro definitions:

#+begin_src emacs-lisp
(defmacro define-combined-hook (name hooks)
  "Create a hook bound as NAME that is run after each hook in HOOKS."
  (declare (indent 1))
  `(progn
     (defvar ,name nil "Auto-generated combined hook.")
     (hook-fns ',(eval hooks)
       (run-hooks ',name))))

(defmacro define-mode-group (name modes)
  "Create an ad-hoc relationship between language modes.
Creates a special var with NAME to contain the grouping.
Declares a hook NAME-hook that runs after any of MODES are initialized."
  (declare (indent 1))
  (let ((hook (intern (format "%s-hook" name))))
    `(progn
       ;; Define modes variable.
       (defconst ,name ,modes "Auto-generated variable for language grouping.")
       ;; Create a combined hook for MODES.
       (define-combined-hook ,hook
         (--map (intern (concat (symbol-name it) "-hook"))
                ,modes)))))
#+end_src

We define the following mode groups:

#+begin_src emacs-lisp
(define-mode-group cb:scheme-modes
  '(scheme-mode
    inferior-scheme-mode
    geiser-repl-mode))

(define-mode-group cb:clojure-modes
  '(clojure-mode
    clojurescript-mode
    cider-repl-mode))

(define-mode-group cb:elisp-modes
  '(emacs-lisp-mode
    inferior-emacs-lisp-mode))

(define-mode-group cb:slime-modes
  '(slime-mode
    slime-repl-mode))

(define-mode-group cb:lisp-modes
  `(,@cb:scheme-modes
    ,@cb:clojure-modes
    ,@cb:elisp-modes
    ,@cb:slime-modes
    common-lisp-mode
    inferior-lisp-mode
    lisp-mode
    repl-mode))

(define-mode-group cb:haskell-modes
  '(haskell-mode
    inferior-haskell-mode
    haskell-interactive-mode
    haskell-c-mode
    haskell-cabal-mode))

(define-mode-group cb:idris-modes
  '(idris-mode
    idris-repl-mode))

(define-mode-group cb:python-modes
  '(python-mode
    inferior-python-mode))

(define-mode-group cb:ruby-modes
  '(inf-ruby-mode
    ruby-mode))

(define-mode-group cb:rails-modes
  `(,@cb:ruby-modes
    erb-mode))

(define-mode-group cb:xml-modes
  '(sgml-mode
    nxml-mode))

(define-mode-group cb:org-minor-modes
  '(orgtbl-mode
    org-indent-mode
    orgstruct-mode
    orgstruct++-mode))

(define-mode-group cb:conf-modes
  '(conf-unix-mode
    conf-windows-mode
    conf-javaprop-mode))

(define-mode-group cb:prompt-modes
  '(comint-mode
    inf-ruby-mode
    inferior-python-mode
    ielm-mode
    erc-mode
    utop-mode
    slime-repl-mode
    inferior-scheme-mode
    inferior-haskell-mode
    sclang-post-buffer-mode))

(define-mode-group cb:whitespace-sensitive-languages
  '(python-mode
    haskell-mode
    fsharp-mode
    idris-mode))
#+end_src

* Server
#+begin_src emacs-lisp
(require 'server)
#+end_src
** Start the server after Emacs has been initialised
#+begin_src emacs-lisp
(hook-fn 'after-init-hook
  (unless (or noninteractive (server-running-p))
    (server-start)))
#+end_src
** Disable colour themes for console frames
Using emacsclient with colour themes can be flaky in terminals, especially on OS
X. This code tweaks the colours when creating frames in a terminal.
#+begin_src emacs-lisp
  (after 'server
    (defun cb-server:configure-frame (&rest frame)
      "Disable themeing for console emacsclient."
      (unless (display-graphic-p)
        (let ((fm (or (car frame) (selected-frame)))
              (tranparent "ARGBBB000000")
              (blue "#168DCC")
              )
          (set-face-foreground 'default nil fm)
          (set-face-background 'default tranparent fm)
          (set-face-background 'menu blue fm)
          (set-face-foreground 'menu "white" fm)

          (when (featurep 'hl-line)
            (set-face-background 'hl-line tranparent fm))

          (set-face-background 'fringe tranparent fm)
          (set-face-background 'cursor "#2F4F4F" fm)
          ;; Modeline
          (set-face-foreground 'mode-line-filename "white" fm)
          (set-face-foreground 'mode-line-position "white" fm)
          (set-face-foreground 'mode-line-mode "black" fm)
          (set-face-bold 'mode-line-mode t fm)
          (set-face-background 'mode-line blue fm)
          (set-face-background 'mode-line blue fm)

          (when (featurep 'smartparens)
            (set-face-background 'sp-pair-overlay-face "green" fm))
          (when (featurep 'org)
            (set-face-background 'org-block-begin-line tranparent fm)
            (set-face-background 'org-block-end-line tranparent fm)
            (set-face-background 'org-block-background tranparent fm)))))

    (defadvice server-create-window-system-frame (after configure-frame activate)
      "Set custom frame colours when creating the first frame on a display"
      (cb-server:configure-frame))

    (add-hook 'after-make-frame-functions 'cb-server:configure-frame t))
#+end_src
* Font lock
** Use maximum font-lock prettiness
#+begin_src emacs-lisp
(setq font-lock-maximum-decoration t)
#+end_src
** Do not perform font-locking on killed buffers
#+begin_src emacs-lisp
(defadvice jit-lock-force-redisplay (around ignore-killed-buffers activate)
  (let ((buf (ad-get-arg 0)))
    (when (buffer-live-p buf)
      ad-do-it)))
#+end_src
* Typefaces
Provide support for rich typefaces.
** Ignore font changes in terminal
#+begin_src emacs-lisp
(defadvice set-face-font (around ignore-in-term activate)
  "Ignore attempts to change the font in terminals."
  (when (display-graphic-p) ad-do-it))
#+end_src
** Define face families
Define face families. This should work on most OSes, though I haven't tested on
anything other than OS X.

Define function for finding serif, sans-serif and monospace fonts appropriate to
this system.

#+begin_src emacs-lisp
(defun first-font (&rest fonts)
  "Return the first available font in FONTS."
  (--first (find-font (font-spec :name it)) fonts))

(defun serif-font ()
  "Retun the serif type-face name to use for this Emacs session."
  (first-font "Palatino" "Cambria" "Times New Roman"))

(defun sans-serif-font ()
  "Retun the sans-serif type-face name to use for this Emacs session."
  (first-font "Lucida Grande" "Ubuntu Regular" "Segoe UI"
              "Helvetica Neue" "Calibri" "Helvetica" "Verdana" "Arial"))

(defun monospace-font ()
  "Retun the monospace type-face name to use for this Emacs session."
  (or (first-font "Menlo" "Consolas" "Inconsolata" "DejaVu Sans Mono"
                  "Ubuntu Mono Regular" "Courier")
      "Menlo"))
#+end_src
** Set default font
*** Manually set the default font
#+begin_src emacs-lisp
(set-frame-font (format "%s 11" (monospace-font)) t)
#+end_src
*** Ensure that any further frames use this font too
#+begin_src emacs-lisp
(hook-fn 'after-make-frame-functions
  (set-frame-font (format "%s 11" (monospace-font)) t
                  (list (car (frame-list)))))
#+end_src
* Colours and themes
** Compatibility
Define an alias for =set-face-bold=, which was introduced in 24.3
#+begin_src emacs-lisp
(when (and (<= emacs-major-version 24)
           (< emacs-minor-version 3))
  (defalias 'set-face-bold 'set-face-bold-p))
#+end_src
** Solarized colours
Define global variables for Solarized accent colours so they can be used in
other places in the configuration.
#+begin_src emacs-lisp
(defvar solarized-hl-yellow    "#b58900")
(defvar solarized-hl-orange    "#cb4b16")
(defvar solarized-hl-red       "#dc322f")
(defvar solarized-hl-magenta   "#d33682")
(defvar solarized-hl-violet    "#6c71c4")
(defvar solarized-hl-blue      "#268bd2")
(defvar solarized-hl-cyan      "#2aa198")
(defvar solarized-hl-green     "#859900")
#+end_src
** Flash theme
#+begin_src emacs-lisp
(defface intense-flash
  `((((class color) (background dark))
     (:bold t :background "#073642" :foreground ,solarized-hl-cyan))
    (((class color) (background light))
     (:bold t :background "#eee8d5" :foreground ,solarized-hl-cyan)))
  "Face for intense highlighted text."
  :group 'cb-faces)
#+end_src
** CONDITIONAL
Do not load if we're running Emacs in a terminal.
#+begin_src emacs-lisp
(when (or (daemonp) (display-graphic-p))
#+end_src
** Saving themes between sessions
Define a utility for saving the current theme. This allows the theme that was
last used to be selected when Emacs is started.
#+begin_src emacs-lisp
(defconst cbcl:saved-theme-file (f-join cb:tmp-dir "last-theme")
  "Filepath to a file containing the last selected colour theme.")

(defun cbcl:save-theme-settings (theme)
  "Save THEME to a file at `cbcl:saved-theme-file'."
  (when after-init-time
    (f-write (format "(%s)" theme) 'utf-8 cbcl:saved-theme-file)))
#+end_src
** Solarized
The Solarized theme is a popular colour theme. It comes in two variants--light
and dark.
*** Install package
#+begin_src emacs-lisp
(unless noninteractive
  (cb:install-package 'solarized-theme))
#+end_src
*** Define common settings
Define a function for applying settings common to both the light and dark
themes.
#+begin_src emacs-lisp
(defun cb-colour:common-setup ()
  "Perform customisation common to all themes."

  (when (featurep 'hl-line)
    (set-face-underline 'hl-line nil))

  (set-face-font 'default (format "%s 11" (monospace-font)))

  (after 'eval-sexp-fu
    (set-face-background 'eval-sexp-fu-flash-error solarized-hl-orange))

  (after 'helm
    (set-face-underline   'helm-selection nil))

  (after 'smartparens
    (set-face-foreground  'sp-show-pair-match-face "#002b36")
    (set-face-background  'sp-show-pair-match-face "white")
    (set-face-bold        'sp-show-pair-match-face t))

  (after 'iedit
    (set-face-attribute 'iedit-occurrence nil :underline solarized-hl-orange))

  (after 'org
    (set-face-underline  'org-block-begin-line t)
    (set-face-attribute  'org-block-end-line nil :overline t)
    (set-face-background 'org-hide 'unspecified)
    (set-face-foreground 'org-document-info-keyword 'unspecified)
    (set-face-italic 'org-meta-line nil)
    (set-face-attribute 'org-document-info-keyword nil :inherit 'org-meta-line)
    (--each (--filter-atoms (and (s-starts-with? "org-level-" (symbol-name it))
                                 (facep it)))
      (unless (equal 'org-level-1 it)
        (set-face-bold it nil))
      (set-face-font it (monospace-font)))))
#+end_src
*** Configure Solarized Light
#+begin_src emacs-lisp
(defun solarized-light ()
  (interactive)
  (cbcl:save-theme-settings 'solarized-light)
  (load-theme 'solarized-light 'no-confirm)
  (cb-colour:common-setup)

  (after 'org
    (set-face-background 'org-block-begin-line "#f8f1dc")
    (set-face-background 'org-block-end-line "#f8f1dc")
    (set-face-background 'org-block-background "#f8f1dc"))

  (after 'ledger-fonts
    (set-face-background 'ledger-font-xact-highlight-face "#eee8d5")
    (set-face-background 'ledger-occur-xact-face "#eee8d5"))

  (after 'shm
    (set-face-background 'shm-current-face  "#e9f2c5")
    (set-face-background 'shm-quarantine-face  "#fee8e5"))

  (after 'helm
    (set-face-background  'helm-selection "white")
    (set-face-foreground  'helm-selection "black"))

  (after 'parenface-plus
    (set-face-foreground  'paren-face "grey80")))
#+end_src
*** Configure Solarized Dark
#+begin_src emacs-lisp
(defun solarized-dark ()
  (interactive)
  (cbcl:save-theme-settings 'solarized-dark)
  (load-theme 'solarized-dark 'no-confirm)
  (cb-colour:common-setup)

  (after 'helm
    (set-face-background  'helm-selection "black")
    (set-face-foreground  'helm-selection "white"))

  (after 'ledger-fonts
    (set-face-background 'ledger-font-xact-highlight-face "#073642")
    (set-face-background 'ledger-occur-xact-face "#073642"))

  (after 'parenface-plus
    (set-face-foreground  'paren-face "#505070"))

  (after 'shm
    (set-face-background 'shm-current-face "#01304b")
    (set-face-background 'shm-quarantine-face "#51202b"))

  (after 'org
    (set-face-background 'org-block-end-line "#11303b")
    (set-face-background 'org-block-begin-line "#11303b")
    (set-face-background 'org-block-background "#11303b")))
#+end_src
*** Make convenience aliases for the above functions
#+begin_src emacs-lisp
(defalias 'light 'solarized-light)
(defalias 'dark 'solarized-dark)
#+end_src
** Load theme on startup
Write current theme to disk whenever the colour theme is changed so it can be
reloaded on startup.
#+begin_src emacs-lisp
(defun cb-colour:load-last-theme ()
  (condition-case _
      (load cbcl:saved-theme-file nil t t)
    (error (solarized-light))))

(unless (true? after-init-time) (cb-colour:load-last-theme))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Highlight FIXMEs and TODOs in comments
#+begin_src emacs-lisp
(hook-fn 'prog-mode-hook
  (font-lock-add-keywords
   nil '(("\\<\\(FIX\\|TODO\\|FIXME\\|HACK\\|REFACTOR\\):"
          1 font-lock-warning-face t))))
#+end_src
* Comint
#+begin_src emacs-lisp
(setq comint-prompt-read-only t)
#+end_src
** Configure common key bindings for comint and prompt modes
#+begin_src emacs-lisp
(defun cb:clear-scrollback ()
  "Erase all but the last line of the current buffer."
  (interactive)
  (let ((inhibit-read-only t)
        (last-line (save-excursion
                     (goto-char (point-max))
                     (forward-line -1)
                     (line-end-position))))
    (delete-region (point-min) last-line)
    (goto-char (point-max))))

(hook-fn 'cb:prompt-modes-hook
  (local-set-key (kbd "C-a") 'move-beginning-of-line)
  (local-set-key (kbd "C-e") 'move-end-of-line)
  (local-set-key (kbd "C-l") 'cb:clear-scrollback)
  (local-set-key (kbd "M->") 'cb:append-buffer)
  (cb:append-buffer))
#+end_src
* Hippie-expand
=Hippie-expand= provides keyword completion.
** Expand liberally
#+begin_src emacs-lisp
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
#+end_src
** Bind globally
#+begin_src emacs-lisp
(bind-key* "M-/" 'hippie-expand)
#+end_src
* Indirect buffers
Define a command for creating indirect buffers from a region.
** Impl
#+begin_src emacs-lisp
(defvar-local indirect-mode-name nil
  "Mode to set for indirect buffers.")

(defun indirect-region (start end)
  "Edit the current region from START to END in another buffer.
If the buffer-local variable `indirect-mode-name' is not set, prompt
for mode name to choose for the indirect buffer interactively.
Otherwise, use the value of said variable as argument to a funcall."
  (interactive "r")
  (let ((buffer-name (generate-new-buffer-name "*indirect*"))
        (mode
         (if (not indirect-mode-name)
             (setq indirect-mode-name
                   (intern
                    (completing-read
                     "Mode: "
                     (mapcar (lambda (e)
                               (list (symbol-name e)))
                             (apropos-internal "-mode$" 'commandp))
                     nil t)))
           indirect-mode-name)))
    (pop-to-buffer (make-indirect-buffer (current-buffer) buffer-name))
    (funcall mode)
    (narrow-to-region start end)
    (goto-char (point-min))
    (shrink-window-if-larger-than-buffer)))
#+end_src
** Key binding
#+begin_src emacs-lisp
(bind-key "C-c C" 'indirect-region)
#+end_src
* Calc
** Define a command that invokes calc and performs a context-sensitive action
#+begin_src emacs-lisp
(defun calc-dwim ()
  "Run calc or grab the current region."
  (interactive)
  (if (region-active-p)
      (condition-case err
          (let ((opt (read-option
                      "Calc Grab" 'car 'cadr
                      '(("v" "Grab as Vector" calc-grab-region)
                        ("m" "Grab as Matrix" calc-grab-rectangle)
                        ("c" "Sum Cols" calc-grab-sum-down)
                        ("r" "Sum Rows" calc-grab-sum-across)))))
            (call-interactively (nth 2 opt)))

        (error
         (message "Malformed region. %s" (error-message-string err))))

    (call-interactively 'calc)))
#+end_src
** Create global key bindings for calc
#+begin_src emacs-lisp
(bind-key* "<f2>" 'calc-dwim)
(bind-key* "C-/"  'quick-calc)
#+end_src
** Define additional units
#+begin_src emacs-lisp
(after 'calc-units
  (setq math-additional-units
        '((bit nil "*Bit")
          (B   "8 * bit" "Byte")
          (KiB "1024 * B"   "Kebibyte")
          (MiB "1024 * KiB" "Mebibyte")
          (GiB "1024 * MiB" "Gibibyte")
          (TiB "1024 * GiB" "Tebibyte")
          (PiB "1024 * TiB" "Pebibyte")
          (EiB "1024 * PiB" "Exbibyte")
          (ZiB "1024 * EiB" "Zebibyte")
          (YiB "1024 * ZiB" "Yobibyte")
          )
        math-units-table nil))
#+end_src
* hl-line
Highlight the current line.
#+begin_src emacs-lisp
(require 'hl-line)
(when (display-graphic-p)
  (global-hl-line-mode t))
#+end_src
** Do not use in certain modes
#+begin_src emacs-lisp
(make-variable-buffer-local 'global-hl-line-mode)

(defun hl-line-disable ()
  (setq global-hl-line-mode nil))

(--each '(eshell-mode-hook
          Man-mode-hook
          haskell-mode-hook
          Info-mode-hook)
  (add-hook it 'hl-line-disable))
#+end_src
* fringe
Set fringe width.
#+begin_src emacs-lisp
(require 'fringe)
(fringe-mode '(2 . 0))
#+end_src
* ansi-color
Enable ANSI colour codes in terminals and compilation buffers.
#+begin_src emacs-lisp
(add-hook 'comint-mode-hook 'ansi-color-for-comint-mode-on)
(add-hook 'compilation-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src
** Process ANSI colours in shell output
#+begin_src emacs-lisp
(defadvice display-message-or-buffer (before ansi-color activate)
  "Process ANSI color codes in shell output."
  (let ((buf (ad-get-arg 0)))
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src
* Ido
** Ido
#+begin_src emacs-lisp
(require 'ido)
(ido-mode +1)
#+end_src
** Define a macro to decorate a command to use ido
#+begin_src emacs-lisp
(defmacro declare-ido-wrapper (command)
  "Make COMMAND use ido for file and directory completions."
  `(defadvice ,command (around read-with-ido activate)
     (noflet
         ((read-directory-name
           (&rest args) (apply 'ido-read-directory-name args))
          (read-file-name
           (&rest args) (apply 'ido-read-file-name args))
          (read-buffer
           (&rest args) (apply 'ido-read-buffer)))
       ad-do-it)))
#+end_src
** Configure variables
#+begin_src emacs-lisp
(setq ido-enable-prefix nil
      ido-save-directory-list-file (f-join cb:tmp-dir "ido.last")
      ido-enable-flex-matching t
      ido-create-new-buffer 'always
      ido-use-filename-at-point 'guess
      ido-max-prospects 10
      ido-default-file-method 'selected-window)
#+end_src
** Ignore certain patterns
#+begin_src emacs-lisp
(add-to-list 'ido-ignore-buffers "\\*helm.*")
(add-to-list 'ido-ignore-buffers "\\*Minibuf.*")
(add-to-list 'ido-ignore-files "\\.swp")
(add-to-list 'ido-ignore-files "\\.DS_Store")
#+end_src
** Set key bindings
#+begin_src emacs-lisp
(bind-keys
  "C-x C-f" 'ido-find-file
  "C-x d"   'ido-dired
  "C-x i"   'ido-insert-file
  "C-x C-w" 'ido-write-file
  "C-x k"   'ido-kill-buffer
  "C-x b"   'ido-switch-buffer)
#+end_src
** Typing '~' goes immediately to home folder
#+begin_src emacs-lisp
(hook-fn 'ido-setup-hook
  (define-key ido-common-completion-map (kbd "~") (command (insert "~/"))))
#+end_src
** Use self insert command for typing spaces
This stops ido from trying to complete when typing spaces, which appears to be
broken anyway.
#+begin_src emacs-lisp
(defalias 'ido-complete-space 'self-insert-command)
#+end_src
** Ido vertical mode
Shows ido menus using a vertical layout.
#+begin_src emacs-lisp
(cb:install-package 'ido-vertical-mode t)
(noflet ((message (&rest _) nil)) (ido-vertical-mode +1))
#+end_src
** Ido hacks
Extends ido to more places.
#+begin_src emacs-lisp
(cb:install-package 'ido-hacks t)
(ido-hacks-mode +1)
#+end_src
** Flx-ido
Adds improved matching algorithm for ido.
#+begin_src emacs-lisp
(cb:install-package 'flx-ido t)
(flx-ido-mode +1)
#+end_src
*** Override ido faces with flx ones
#+begin_src emacs-lisp
(setq ido-use-faces nil)
#+end_src
* Projectile
Projectile provides project-level commands such as finding files in the current
project, performing searches and replacements, etc.

Forward-declare vars to prevent creation of tmp files at top of =.emacs.d=.
#+begin_src emacs-lisp
(defvar projectile-known-projects-file
  (f-join cb:tmp-dir "projectile-bookmarks.eld"))

(defvar projectile-cache-file (f-join cb:tmp-dir "projectile.cache"))
#+end_src

Install packages.

#+begin_src emacs-lisp
(cb:install-package 'projectile t)
(cb:install-package 'ack-and-a-half t)
(projectile-global-mode +1)

(after 'projectile (diminish 'projectile-mode))
#+end_src
** Advise tag searches to make sure we're searching the right tags file
#+begin_src emacs-lisp
(defadvice find-tag (before set-tags-directory activate)
  "Ensure the TAGS path is set before searching for tags."
  (setq-local tags-file-name (concat (projectile-project-root) "TAGS")))
#+end_src
* Helm
Helm provides a general UI for searching through lists of items interactively.
#+begin_src emacs-lisp
(cb:install-package 'helm t)
#+end_src
** Save the history file to the tmp dir
#+begin_src emacs-lisp
(setq helm-adaptive-history-file (f-join cb:tmp-dir "helm-adaptive-history"))
#+end_src
** Evil
#+begin_src emacs-lisp
(after 'evil
  (bind-keys
    :overriding? t
    "C-SPC" 'helm-mini
    "C-x C-b" 'helm-buffers-list
    "M-b" 'helm-buffers-list)

  (evil-global-set-key 'normal (kbd "C-e") 'helm-etags-select)
  (evil-global-set-key 'normal (kbd "C-t") 'helm-imenu))
#+end_src
** Hide boring files in helm files lists
#+begin_src emacs-lisp
  (setq helm-ff-skip-boring-files t)
  (setq helm-boring-file-regexp-list '("\\.DS_Store" "\\.elc$"))
#+end_src
** Typing '~' in helm find files goes back to home directory
#+begin_src emacs-lisp
(after 'helm-files
  (define-key helm-find-files-map
    (kbd "~")
    (command
     (if (looking-back "/")
         (helm-insert-in-minibuffer "~/" t)
       (call-interactively 'self-insert-command)))))
#+end_src
** Set a global key binding for helm-find-files
#+begin_src emacs-lisp
(bind-key* "C-x SPC" 'helm-find-files)
#+end_src
** Helm projectile
Provides helm sources for projectile.
#+begin_src emacs-lisp
(cb:install-package 'helm-projectile)
(bind-key "M-j" 'helm-projectile)
#+end_src
* Evil
Evil-mode adds modal editing to emulate vim. Since this drastically changes
Emacs' key bindings, the =cb:use-vim-keybindings?= var can be set to nil to
prevent Evil from being loaded.
** Define a commands to enter insert state only if evil-mode-is-on
#+begin_src emacs-lisp
(defun cb:maybe-evil-insert-state ()
  "Only enter insert state if evil-mode is active."
  (interactive)
  (when (and (fboundp 'evil-insert-state)
             (true? evil-mode))
    (evil-insert-state)))

(defun cb:maybe-evil-append-line ()
  "Go to the end of the line. Enter insert state if evil-mode is active."
  (if (and (fboundp 'evil-append-line)
           (true? evil-mode))
      (evil-append-line 1)
    (end-of-line)))

(defun cb:append-buffer ()
  "Enter insertion mode at the end of the current buffer."
  (interactive)
  (goto-char (point-max))
  (cb:maybe-evil-insert-state))
#+end_src
** CONDITIONAL
#+begin_src emacs-lisp
(when cb:use-vim-keybindings?
#+end_src
** Evil-mode
Activate evil-mode unless it has been disabled at the start of the config.
#+begin_src emacs-lisp
(cb:install-package 'evil t)
#+end_src
*** Use ESC as quit command in most situations
#+begin_src emacs-lisp
(--each '(evil-normal-state-map
          evil-visual-state-map
          minibuffer-local-map
          minibuffer-local-ns-map
          minibuffer-local-completion-map
          minibuffer-local-must-match-map
          minibuffer-local-isearch-map)
  (define-key (eval it) [escape] 'keyboard-quit))
#+end_src
*** Customise variables
#+begin_src emacs-lisp
(setq evil-want-visual-char-semi-exclusive t
      evil-toggle-key (kbd "M-z")
      evil-default-cursor t)
(setq-default evil-shift-width 2)
(setq-default evil-symbol-word-search 'symbol)
#+end_src
*** Define a convenience macro for settings evil keys globally
#+begin_src emacs-lisp
(defmacro evil-global-set-keys (state &rest defs)
  "Variadic version of `evil-global-set-key'
Creates STATE bindings for DEFS. DEFS are comprised of alternating string-symbol pairs."
  (declare (indent 1))
  `(after 'evil
     ,@(-map (lambda+ ((key fn))
               `(evil-global-set-key ,state (kbd ,key) ,fn))
             (-partition-all 2 defs))))
#+end_src
*** Enable evil-mode
#+begin_src emacs-lisp
(evil-mode +1)
#+end_src
** Custom key definitions
*** Define a command to unset evil keys
#+begin_src emacs-lisp
(defun evil-undefine ()
  (interactive)
  (let (evil-mode-map-alist)
    (call-interactively (key-binding (this-command-keys)))))
#+end_src
*** Customise key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "TAB" 'indent-according-to-mode
  "<backtab>" 'outdent
  "M-z" 'evil-emacs-state
  "C-z" 'evil-undefine
  "SPC" 'evil-toggle-fold
  "K"   'cbevil:get-documentation
  "u"   'undo-tree-undo
  "C-R" 'undo-tree-redo)

(define-key evil-insert-state-map (kbd "C-z") 'evil-undefine)
(define-key evil-emacs-state-map  (kbd "M-z") 'evil-normal-state)
(define-key evil-visual-state-map (kbd "C-z") 'evil-undefine)
#+end_src
** Add custom commands to emulate vim's dictionary editing commands
*** Impl
#+begin_src emacs-lisp
(autoload 'ispell-add-to-dict "cb-spelling")
(autoload 'ispell-add-per-file-word-list "ispell")

(defun evil-mark-word-as-good (word)
  "Add WORD at point to the Ispell dictionary."
  (interactive (list (thing-at-point 'word)))
  (ispell-add-to-dict word)
  (message "%s added to dictionary" (s-upcase word)))

(defun evil-correct-word (arg)
  "Corect the word at point with Ispell.
With a number ARG, select the nth replacement."
  (interactive "*P")
  (if (numberp arg)
      (dotimes (_ (1+ arg))
        (flyspell-auto-correct-word))
    (ispell-word)))

(defun evil-mark-word-as-locally-good (word)
  "Add WORD at point to the list of locally-defined words."
  (interactive (list (thing-at-point 'word)))
  (when word
    (ispell-add-per-file-word-list word)
    (message "%s added to local word list" (s-upcase word))))

(defun cbevil:error-backward-search-start-pos (pos)
  "Wrap the search to the end of the buffer if there are no
errors before POS."
  (if (and (eq (current-buffer) flyspell-old-buffer-error)
           (eq pos flyspell-old-pos-error))
      (cond
       ((= flyspell-old-pos-error (point-min))
        (message "Restarting from end of buffer")
        (point-max))
       (t
        (save-excursion
          (forward-word -1)
          (point))))
    (point)))

(defun cbevil:prev-spelling-error-pos ()
  (let ((pos (cbevil:error-backward-search-start-pos (point))))
    (while (and (> pos (point-min))
                (-none? 'flyspell-overlay-p (overlays-at pos)))
      (cl-decf pos))
    pos))

(defun evil-previous-spelling-error ()
  "Go to the previous flyspell error."
  (interactive)
  (let ((pos (cbevil:prev-spelling-error-pos)))
    ;; save the current location for next invocation
    (setq flyspell-old-pos-error pos)
    (setq flyspell-old-buffer-error (current-buffer))
    (goto-char pos)
    (when (= pos (point-min))
      (message "No more spelling errors"))))

(defun cbevil:error-forward-search-start-pos (pos)
  "Wrap the search to the beginning of the buffer if there are no
errors forward of POS."
  (if (and (eq (current-buffer) flyspell-old-buffer-error)
           (eq pos flyspell-old-pos-error))
      (cond
       ((= flyspell-old-pos-error (point-max))
        (message "Restarting from beginning of buffer")
        (point-min))
       (t
        (save-excursion
          (forward-word 1)
          (point))))
    (point)))

(defun cbevil:next-spelling-error-pos ()
  (let ((pos (cbevil:error-forward-search-start-pos (point))))
    (while (and (< pos (point-max))
                (-none? 'flyspell-overlay-p (overlays-at pos)))
      (cl-incf pos))
    pos))

(defun evil-next-spelling-error ()
  "Go to the next flyspell error."
  (interactive)
  (let ((pos (cbevil:next-spelling-error-pos)))
    ;; save the current location for next invocation
    (setq flyspell-old-pos-error pos)
    (setq flyspell-old-buffer-error (current-buffer))
    (goto-char pos)
    (when (= pos (point-max))
      (message "No more spelling errors"))))
#+end_src
*** Key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "[s"  'evil-previous-spelling-error
  "]s"  'evil-next-spelling-error
  "z g" 'evil-mark-word-as-good
  "z G" 'evil-mark-word-as-locally-good
  "z =" 'evil-correct-word
  "z u" 'flyspell-auto-correct-word)
#+end_src
** Documentation search
Extend the 'K' key to support documentation searches using mode-specific search
commands.
#+begin_src emacs-lisp
(autoload 'Man-getpage-in-background "man")
(autoload 'woman-file-name-all-completions "woman")

(defvar evil-find-doc-hook nil
  "Hook run when finding documentation for the symbol at point.
Each handler should take the search string as an argument.")

(defmacro define-evil-doc-handler (modes &rest body)
  "Register a doc lookup function for MODES.

- MODES is a quoted symbol or list of symbols representing the
  modes in which this handler will be used.

- BODY are the forms to execute to show documentation."
  (let* ((modes (-listify (eval modes)))
         (fname (intern (format "cbevil:doc-search-%s" (car modes)))))
    (cl-assert modes nil "Must provide a mode or list of modes")
    (cl-assert (-all? 'symbolp modes))
    `(progn

       (defun ,fname ()
         ,(concat "Documentation search function for the following modes:"
                  "\n\n  - "
                  (s-join "\n\n  - " (-map 'symbol-name modes)))

         (when (apply 'derived-mode-p ',modes)
           ,@body
           major-mode))

       (add-hook 'evil-find-doc-hook ',fname))))

(defun get-manpage (candidate)
  "Show the manpage for CANDIDATE."
  (let ((wfiles (mapcar 'car (woman-file-name-all-completions candidate))))
    (condition-case _
        (if (> (length wfiles) 1)
            (woman-find-file
             (helm-comp-read
              "ManFile: " wfiles :must-match t))
          (woman candidate))
      ;; If woman is unable to format correctly use man instead.
      (error
       (kill-buffer)
       (Man-getpage-in-background candidate)))
    t))

(defun cbevil:get-documentation ()
  "Get documentation for string CANDIDATE.
Runs each handler added to `evil-find-doc-hook' until one of them returns non-nil."
  (interactive)
  (condition-case-unless-debug _
      (or (run-hook-with-args-until-success 'evil-find-doc-hook)
          (get-manpage (thing-at-point 'symbol)))
    (error
     (user-error "No documentation available"))))
#+end_src
** Use evil window shortcuts in Emacs state
Make evil emacs-state use the same window management bindings for consistency.
This makes switching to a buffer in Emacs state more tolerable.
#+begin_src emacs-lisp
(define-prefix-command 'cb:evil-window-emu)
(global-set-key (kbd "C-w") 'cb:evil-window-emu)
(bind-keys
  :overriding? t
  "C-w C-w" 'evil-window-prev
  "C-w C-s" 'split-window-vertically
  "C-w C-v" 'split-window-horizontally
  "C-w C-o" 'delete-other-windows
  "C-w C-c" 'delete-window
  "C-w w" 'evil-window-prev
  "C-w s" 'split-window-vertically
  "C-w v" 'split-window-horizontally
  "C-w o" 'delete-other-windows
  "C-w c" 'delete-window)
#+end_src
** Mode-specific key bindings
#+begin_src emacs-lisp
(evil-add-hjkl-bindings tar-mode-map)
(evil-add-hjkl-bindings occur-mode-map)
(evil-add-hjkl-bindings archive-mode-map)
(evil-add-hjkl-bindings package-menu-mode-map)

(after 'man
  (evil-define-key 'normal Man-mode-map (kbd "q") 'Man-kill))

(add-hook 'message-mode-hook 'cb:maybe-evil-append-line)

(after 'undo-tree
  ;; Ensure undo-tree commands are remapped. The referenced keymap in
  ;; evil-integration is incorrect.
  (define-keys undo-tree-visualizer-mode-map
    [remap evil-backward-char] 'undo-tree-visualize-switch-branch-left
    [remap evil-forward-char]  'undo-tree-visualize-switch-branch-right
    [remap evil-next-line]     'undo-tree-visualize-redo
    [remap evil-previous-line] 'undo-tree-visualize-undo))

(evil-global-set-key 'insert (kbd "S-TAB") 'tab-to-tab-stop)
#+end_src
** Surround
Adds commands to manipulate braces and XML tags.
#+begin_src emacs-lisp
(cb:install-package 'surround t)
#+end_src
*** Remove padding around pairs
#+begin_src emacs-lisp
(setq-default surround-pairs-alist
              '((?\( . ("(" . ")"))
                (?\[ . ("[" . "]"))
                (?\{ . ("{" . "}"))

                (?\) . ("(" . ")"))
                (?\] . ("[" . "]"))
                (?\} . ("{" . "}"))

                (?# . ("#{" . "}"))
                (?b . ("(" . ")"))
                (?B . ("{" . "}"))
                (?> . ("<" . ">"))
                (?t . surround-read-tag)
                (?< . surround-read-tag)
                (?f . surround-function)))
#+end_src
*** Define a specific set of pairs for emacs-lisp-mode
#+begin_src emacs-lisp
(hook-fn 'cb:elisp-modes-hook
  (make-local-variable 'surround-pairs-alist)
  (push '(?\` . ("`" . "'")) surround-pairs-alist))
#+end_src
*** Enable surround mode
#+begin_src emacs-lisp
(global-surround-mode +1)
#+end_src
** Evil numbers
Provides commands for incrementing and decrementing numbers at point.
#+begin_src emacs-lisp
(cb:install-package 'evil-numbers t)
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(define-keys evil-normal-state-map
  "C--" 'evil-numbers/dec-at-pt
  "C-+" 'evil-numbers/inc-at-pt)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Auto-complete
Provides intellisense-style completion popops.
#+begin_src emacs-lisp
(cb:install-package 'auto-complete t)
(global-auto-complete-mode +1)
#+end_src
** Start with default configuration
#+begin_src emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
#+end_src
** Customise vars
#+begin_src emacs-lisp
(setq ac-auto-show-menu t
      ac-dwim t
      ac-use-menu-map t
      ac-quick-help-delay 0.4
      ac-quick-help-height 60
      ac-disable-inline t
      ac-show-menu-immediately-on-auto-complete t
      ac-auto-start 3
      ac-candidate-menu-min 0
      ac-comphist-file (f-join cb:tmp-dir "ac-comphist.dat"))
#+end_src
** Fix issues with flyspell
#+begin_src emacs-lisp
(ac-flyspell-workaround)
#+end_src
** Define user dictionary directory
#+begin_src emacs-lisp
(add-to-list 'ac-dictionary-directories (concat user-emacs-directory "ac-dict"))
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'auto-complete-mode)
#+end_src
** Ignore errors when showing help popups
#+begin_src emacs-lisp
(defadvice ac-quick-help (around ignore-errors activate)
  "Ignore errors when showing help popups."
  (ignore-errors ad-do-it))
#+end_src
** Define keys for auto-complete popups
#+begin_src emacs-lisp
(define-keys ac-completing-map
  "<escape>" 'ac-stop
  "C-n" 'ac-next
  "C-p" 'ac-previous)
#+end_src
* Yasnippet
Provides textmate-style snippets.
#+begin_src emacs-lisp
(cb:install-package 'yasnippet)
(add-hook 'prog-mode-hook 'yas-minor-mode)
(add-hook 'text-mode-hook 'yas-minor-mode)
#+end_src
** Override yasnippet faces
#+begin_src emacs-lisp
(defface yas-field-highlight-face
  `((t :underline ,solarized-hl-cyan
       :italic t))
  "The face used to highlight the currently active field of a snippet"
  :group 'yasnippet)
#+end_src
** Use only my snippet dir, since the built-in snippets are crappy
#+begin_src emacs-lisp
(setq-default yas-snippet-dirs (list cb:yasnippet-dir))
#+end_src
** Load yasnippet, suppressing most of the startup messages
#+begin_src emacs-lisp
(noflet ((message (&rest _) nil)) (yas-global-mode t))
#+end_src
** Customise vars
#+begin_src emacs-lisp
(setq yas-prompt-functions '(yas-ido-prompt)
      yas-wrap-around-region t
      yas-verbosity 1)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'yas-minor-mode)
#+end_src
** Auxiliary commands
#+begin_src emacs-lisp
(defun cbyas:reload-all ()
  (interactive)
  (yas-recompile-all)
  (yas-reload-all))
#+end_src
** Define a command picker for yasnippet actions
#+begin_src emacs-lisp
(define-command-picker yasnippet-picker
  :title "*Yasnippet Commands*"
  :options
  '(("e" "Expand" yas-expand)
    ("f" "Visit File" yas-visit-snippet-file)
    ("i" "Insert" yas-insert-snippet)
    ("n" "New" yas-new-snippet)
    ("r" "Reload All" cbyas:reload-all)
    ("q" "Exit Snippets" yas-exit-all-snippets)
    ("t" "Show Tables" yas-describe-tables)))

(bind-key* "C-c y" 'yasnippet-picker)
#+end_src
** Snippet utilities
#+begin_src emacs-lisp
(defun cbyas:bol? ()
  "Non-nil if point is on an empty line or at the first word."
  (s-matches? (rx bol (* space) (* word) eol)
              (buffer-substring (line-beginning-position)
                                (point))))

(defun cbyas:msg (fmt &rest args)
  "Like `message', but returns the empty string.
Embed in elisp blocks to trigger messages within snippets."
  (apply 'message (s-prepend "[yas] " fmt) args)
  "")
#+end_src
** Define command for inserting snippet by name
#+begin_src emacs-lisp
(defun yas-insert-first-snippet (predicate)
  "Choose a snippet to expand according to PREDICATE."
  (setq yas--condition-cache-timestamp (current-time))
  (let ((yas-buffer-local-condition 'always))
    (-if-let (yas--current-template
              (-first predicate (yas--all-templates (yas--get-snippet-tables))))
        (let ((where (if (region-active-p)
                         (cons (region-beginning) (region-end))
                       (cons (point) (point)))))
          (yas-expand-snippet (yas--template-content yas--current-template)
                              (car where)
                              (cdr where)
                              (yas--template-expand-env yas--current-template)))
      (error "No snippet matching predicate"))))
#+end_src
** Utilities for yasnippet advice
#+begin_src emacs-lisp
(defun cbyas:current-field ()
  "Return the current active field."
  (and (boundp 'yas--active-field-overlay)
       yas--active-field-overlay
       (overlay-buffer yas--active-field-overlay)
       (overlay-get yas--active-field-overlay 'yas--field)))

(defun cbyas:beginning-of-field ()
  (-when-let (field (cbyas:current-field))
    (marker-position (yas--field-start field))))

(defun cbyas:end-of-field ()
  (-when-let (field (cbyas:current-field))
    (marker-position (yas--field-end field))))

(defun cbyas:current-field-text ()
  "Return the text in the active snippet field."
  (-when-let (field (cbyas:current-field))
    (yas--field-text-for-display field)))
#+end_src
** Blank field trimming
Advise yasnippet to trim blank fields when moving between fields in a snippet.
#+begin_src emacs-lisp
(defun cbyas:clear-blank-field ()
  "Clear the current field if it is blank."
  (-when-let* ((beg (cbyas:beginning-of-field))
               (end (cbyas:end-of-field))
               (str (cbyas:current-field-text)))
    (when (s-matches? (rx bos (+ space) eos) str)
      (delete-region beg end)
      t)))

(defadvice yas-next-field (before clear-blank-field activate)
  (cbyas:clear-blank-field))

(defadvice yas-prev-field (before clear-blank-field activate)
  (cbyas:clear-blank-field))
#+end_src
** Cursor positioning
advise yasnippet to position the cursor at the end of fields when switching
fields in a snippet.
#+begin_src emacs-lisp
(defun cbyas:maybe-goto-field-end ()
  "Move to the end of the current field if it has been modified."
  (-when-let (field (cbyas:current-field))
    (when (and (yas--field-modified-p field)
               (yas--field-contains-point-p field))
      (goto-char (cbyas:end-of-field)))))

(defadvice yas-next-field (after goto-field-end activate)
  (cbyas:maybe-goto-field-end))

(defadvice yas-prev-field (after goto-field-end activate)
  (cbyas:maybe-goto-field-end))
#+end_src
** Backspace clears unmodified fields or deletes backwards
#+begin_src emacs-lisp
(defun cbyas:backspace ()
  "Clear the current field if the current snippet is unmodified.
Otherwise delete backwards."
  (interactive "*")
  (let ((field (cbyas:current-field)))
    (cond ((and field
                (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((true? smartparens-mode)
           (call-interactively 'sp-backward-delete-char))
          (t
           (call-interactively 'backward-delete-char)))))

(bind-key "<backspace>" 'cbyas:backspace yas-keymap)
#+end_src
** Typing space clears and skips unmodified fields
#+begin_src emacs-lisp
(defun cbyas:space ()
  "Clear and skip this field if it is unmodified. Otherwise insert a space."
  (interactive "*")
  (let ((field (cbyas:current-field)))
    (cond ((and field
                (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          (t
           (insert " ")))))

(bind-key "SPC" 'cbyas:space yas-keymap)
#+end_src
** Define command for restricting the buffer to the current field
#+begin_src emacs-lisp
(defmacro yas-with-field-restriction (&rest body)
  "Narrow the buffer to the current active field and execute BODY.
If no field is active, no narrowing will take place."
  (declare (indent 0))
  `(save-restriction
     (when (cbyas:current-field)
       (narrow-to-region (cbyas:beginning-of-field) (cbyas:end-of-field)))
     ,@body))
#+end_src
** Evil
Customise yasnippet behaviour to work better with evil-mode.
#+begin_src emacs-lisp
(defadvice yas-prev-field (after insert-state activate)
  (cb:maybe-evil-insert-state))

(defadvice yas-prev-field (after insert-state activate)
  (cb:maybe-evil-insert-state))

(add-hook 'yas-before-expand-snippet-hook 'cb:maybe-evil-insert-state)
#+end_src
* Flycheck
#+begin_src emacs-lisp
(cb:install-package 'flycheck)
(global-flycheck-mode)
#+end_src
** Ignore thrown errors when checking a buffer
#+begin_src emacs-lisp
(defadvice flycheck-buffer (around ignore-errors activate)
  (ignore-errors ad-do-it))
#+end_src
** Bind M-N and M-P to navigate errors
#+begin_src emacs-lisp
(bind-key "M-P" 'flycheck-previous-error flycheck-mode-map)
(bind-key "M-N" 'flycheck-next-error flycheck-mode-map)
#+end_src
** Always use flycheck faces for compilation errors
#+begin_src emacs-lisp
(add-to-list 'face-remapping-alist '(compilation-error . flycheck-error))
(add-to-list 'face-remapping-alist '(compilation-warning . flycheck-warning))
#+end_src
** Enable flycheck in Cask buffers
#+begin_src emacs-lisp
(cb:install-package 'flycheck-cask)
(defun cb-flycheck:init-flycheck-cask ()
  "Use the correct Emacs version, in case this Emacs is a dev build."
  (cl-destructuring-bind (maj min &optional build point &rest _)
      (s-split "\\." emacs-version)
    (let ((emacs-version (if point
                             (format "%s.%s.%s" maj min point)
                           emacs-version)))
      (flycheck-cask-setup))))

(add-hook 'flycheck-mode-hook 'cb-flycheck:init-flycheck-cask)
#+end_src
* Spelling
** Ispell
#+begin_src emacs-lisp
(unless noninteractive (require 'ispell))
#+end_src
*** Use aspell where available
#+begin_src emacs-lisp
(setq ispell-program-name "aspell")
#+end_src
*** Use British English dictionary
#+begin_src emacs-lisp
(setq ispell-dictionary "en_GB")
#+end_src
*** Add words to dictionary without confirmation
#+begin_src emacs-lisp
(setq ispell-silently-savep t)
#+end_src
*** Define a command to programatically add a word to the dictionary
#+begin_src emacs-lisp
(defun ispell-add-to-dict (word)
  "Add WORD to the user's dictionary."
  (ispell-send-string (concat "*" word "\n"))
  (setq ispell-pdict-modified-p '(t))
  (ispell-pdict-save ispell-silently-savep))
#+end_src
** Flyspell
Checks spelling in the background and highlights mispelled words.
#+begin_src emacs-lisp
(unless noninteractive (require 'flyspell))
#+end_src
*** Check after 1 second of idle delay
#+begin_src emacs-lisp
(setq flyspell-delay 1)
#+end_src
*** Enable flyspell
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
(add-hook 'cb:xml-modes-hook 'flyspell-prog-mode)
#+end_src
*** Set key bindings
#+begin_src emacs-lisp
(after 'flyspell
  (define-key flyspell-mouse-map [down-mouse-3] 'flyspell-correct-word)
  (define-key flyspell-mouse-map [mouse-3] 'undefined)
  (define-key flyspell-mode-map (kbd "C-c $") nil))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'flyspell-mode-hook
  (diminish 'flyspell-mode))
#+end_src
** Flyspell-lazy
Improves the performance of flyspell.
#+begin_src emacs-lisp
(cb:install-package 'flyspell-lazy)
(add-hook 'flyspell-mode-hook 'flyspell-lazy-mode)
#+end_src
*** Fix errors when buffer is narrowed
#+begin_src emacs-lisp
(defadvice flyspell-lazy-check-pending (around ignore-errors activate)
  (ignore-errors
    (save-restriction
      (widen)
      ad-do-it)))
#+end_src
* Tags
ctags-related commands. Adapted from [[http://mattbriggs.net/blog/2012/03/18/awesome-emacs-plugins-ctags/][Awesome Emacs Plugins: CTags]]
** Set ctags program
#+begin_src emacs-lisp
(setq ctags-update-command (executable-find "ctags"))
#+end_src
** Make tags searches case-sensitive
#+begin_src emacs-lisp
(setq tags-case-fold-search nil)
#+end_src
** Install library used for tag searching
#+begin_src emacs-lisp
(cb:install-package 'etags-select)
#+end_src
** Define patterns to exclude
#+begin_src emacs-lisp
(defvar ctags-exclude-patterns '("db" "test" ".git" "public" "flycheck-"))
#+end_src
** Define a command for building tags
#+begin_src emacs-lisp
(defun cb:format-tags-excludes ()
  (let ((sep " --exclude="))
    (concat sep (s-join sep ctags-exclude-patterns))))

(defun cbtags:project-root ()
  (or (projectile-project-p) default-directory))

(defun build-ctags ()
  "Create a tags file at the root of the current project."
  (interactive)
  (message "Building project tags...")
  (let* ((dir (cbtags:project-root))
         (tags (concat dir "TAGS")))
    ;; Confirm when creating tags outside the home dir, or at the root of the
    ;; home dir.
    (unless (or (f-child-of? dir user-home-directory)
                (y-or-n-p (format "Really create tags in \"%s\"? " dir)))
      (error "Aborted"))

    ;; Create tags.
    (async-shell-command (format "%s -e -R --extra=+fq %s -f %s"
                                 ctags-update-command
                                 (cb:format-tags-excludes)
                                 tags)
                         "*Tags*")
    (message "Writing tags file to %s" tags)))
#+end_src
** Define a command for visiting tags files
#+begin_src emacs-lisp
(defun visit-ctags ()
  "Visit the tags file at the root of the current project."
  (interactive)
  (let ((tags-revert-without-query t))
    (visit-tags-table (cbtags:project-root))
    (message "Loaded %s" tags-file-name)))
#+end_src
** Define a command for creating and loading tags
#+begin_src emacs-lisp
(defun load-ctags ()
  "Create a tags file at the root of the current project, then load it."
  (interactive)
  (and (build-ctags) (visit-ctags)))
#+end_src
** Define a command for finding the tag at point
#+begin_src emacs-lisp
(defun find-ctag ()
  "Find the tags at point, creating a tags file if none exists."
  (interactive)
  (let ((tags (f-join (cbtags:project-root) "TAGS")))
    (setq-local tags-file-name tags)
    (if (file-exists-p tags)
        (visit-ctags)
      (build-ctags)))
  (etags-select-find-tag-at-point))
#+end_src
** Set key bindings for the above commands
#+begin_src emacs-lisp
(global-set-key (kbd "M-.") 'find-ctag)
#+end_src
** Evil
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal (kbd "M-.") 'find-ctag)
  (evil-global-set-key 'normal (kbd "C-]") 'find-ctag))
#+end_src
** Auto-update tags
#+begin_src emacs-lisp
(cb:install-package 'ctags-update)
(add-hook 'prog-mode-hook 'turn-on-ctags-auto-update-mode)
#+end_src
*** Use a tmp dir for tags if the current project does not have a tags file
#+begin_src emacs-lisp
(setq tags-file-name (f-join (make-temp-file "tags" t) "TAGS"))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'ctags-auto-update-mode-hook
  (diminish 'ctags-auto-update-mode))
#+end_src
* Smartparens
Provides commands creating balanced parens and editing such expressions in a
structured way.
#+begin_src emacs-lisp
(cb:install-package 'smartparens t)
(smartparens-global-mode)
#+end_src
** Use strict version of smartparens for programming modes
#+begin_src emacs-lisp
(hook-fns '(prog-mode-hook cb:markup-modes-hook)
  (smartparens-strict-mode +1))
#+end_src
** Show matching parens
#+begin_src emacs-lisp
(show-smartparens-global-mode +1)
#+end_src
** Load default config
#+begin_src emacs-lisp
(require 'smartparens-config)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'smartparens-mode)
#+end_src
** Wrapping
*** Make Paredit-style wrapping commands
#+begin_src emacs-lisp
(sp-pair "(" ")" :bind "M-(")
(sp-pair "{" "}" :bind "M-{")
(sp-pair "[" "]" :bind "M-[")
(sp-pair "\"" "\"" :bind "M-\"")
(sp-pair "`" "`" :bind "M-`")
#+end_src
*** Use apostrophe pairs only for certain modes
#+begin_src emacs-lisp
(sp-with-modes (-flatten (list cb:ruby-modes
                               cb:python-modes
                               'shell-script-mode
                               'makefile-mode
                               'conf-mode))
  (sp-local-pair
   "'" "'"
   :bind "M-'"
   :actions '(:add insert)
   :when '(:add sp-in-code-p)
   :unless '(:add sp-in-string-p)))
#+end_src
*** Don't wrap subsequent words when opening a pair
#+begin_src emacs-lisp
(setq sp-autoinsert-if-followed-by-word t)
#+end_src
** Disable apostrophe pair for some modes
#+begin_src emacs-lisp
(sp-with-modes (-flatten
                (list cb:haskell-modes
                      cb:lisp-modes
                      cb:idris-modes
                      cb:prompt-modes
                      'org-mode
                      'tuareg-mode
                      'minibuffer-inactive-mode
                      'text-mode))
  (sp-local-pair "'" "'" :actions '(:rem insert)))
#+end_src
** Keys
#+begin_src emacs-lisp
(define-keys sp-keymap
  "C-<backspace>" 'sp-backward-up-sexp
  "DEL"           'sp-backward-delete-char)

;; Use bind-key for keys that tend to be overridden.
(bind-key "C-M-," 'sp-backward-down-sexp sp-keymap)
(bind-key "C-M-." 'sp-next-sexp sp-keymap)
#+end_src
** Make sexp killing behaviour to be more like paredit's
#+begin_src emacs-lisp
(defun cb-sp:kill-blank-lines ()
  (interactive)
  (cond
   ((s-blank? (s-trim (current-line)))
    (kill-whole-line))
   (t
    (call-interactively 'sp-kill-sexp)
    (when (s-blank? (s-trim (current-line)))
      (let ((pt (point)))
        (join-line)
        (goto-char (1+ pt)))))))

(define-key sp-keymap (kbd "C-k") 'cb-sp:kill-blank-lines)
#+end_src
** Only enable smartparens in the minibuffer for certain commands
#+begin_src emacs-lisp
(defvar sp-minibuffer-enabled-commands
  '(eval-expression calc-algebraic-entry quick-calc)
  "Commands that take input in the minibuffer for which smartparens should be used.")

(hook-fns '(minibuffer-setup-hook minibuffer-inactive-mode-hook)
  :append t
  (smartparens-mode (if (-contains? sp-minibuffer-enabled-commands this-command)
                        +1 -1)))
#+end_src
** Utilities
#+begin_src emacs-lisp
(defun sp-generic-leading-space (&optional id action ctx)
  "Pad ID with a leading space unless point is either:
1. at the start of a braced expression
2. at indentation."
  (when (and (equal 'insert action)
             (sp-in-code-p id action ctx))
    (save-excursion
      (search-backward id)
      (unless (s-matches?
               (rx (or (group bol (* space))
                       (any "(" "[" "{")) eol)
               (buffer-substring (line-beginning-position) (point)))
        (just-one-space)))))
#+end_src
** Always insert or move up delimiters
Mimic the paredit behaviour of never inserting more closing parens than needed,
and reformatting parens as closing parens are added.

*** Close paren keys move up sexp
#+begin_src emacs-lisp
(setq sp-navigate-close-if-unbalanced t)
#+end_src
*** Insert parens or move up when typing a paren key
#+begin_src emacs-lisp
(defun sp-insert-or-up (delim &optional arg)
  "Insert a delimiter DELIM if inside a string, else move up."
  (interactive "sDelimiter:\nP")
  (cond ((or (emr-looking-at-string?) (emr-looking-at-comment?))
         (insert delim))
        (smartparens-mode
         (sp-up-sexp arg 'interactive))
        (t
         (insert delim))))
#+end_src

HACK: There seems to be a race condition that clobbers customisations to the
smartparens maps, so manually set custom bindings in a hook.
#+begin_src emacs-lisp
(defun cbsp:hacky-set-sp-bindings ()
  (cl-loop for key in '(")" "]" "}")
           for map in '(smartparens-mode-map smartparens-strict-mode-map)
           do (eval `(bind-key
                      (kbd key)
                      (command (with-demoted-errors
                                 (sp-insert-or-up ,key _arg)))
                      ,map))))

(hook-fns '(smartparens-mode-hook smartparens-strict-mode-hook)
  :append t
  (cbsp:hacky-set-sp-bindings))
#+end_src
** Evil
*** Bind navigation commands to paren keys
#+begin_src emacs-lisp
(after 'evil
  (evil-global-set-key 'normal "(" 'sp-backward-up-sexp)
  (evil-global-set-key 'normal ")" 'sp-forward-sexp))
#+end_src
*** Define a special paren state for evil-mode
#+begin_src emacs-lisp
(after 'evil
  (evil-define-state paren "Paren editing state."
    :tag " <P> "
    :message "-- PAREN --"
    :suppress-keymap t
    :cursor 'hollow)

  (hook-fn 'evil-paren-state-entry-hook
    (when (equal last-command 'evil-end-of-line)
      (forward-char)))

  ;; Configure entry and exit from paren state.
  (evil-global-set-key 'normal (kbd ",") 'evil-paren-state)
  (define-key evil-paren-state-map (kbd "ESC") 'evil-normal-state)
  (define-key evil-paren-state-map (kbd "C-g") 'evil-normal-state)
  ;; Define paren state keys.
  (evil-global-set-keys 'paren
    "A" 'sp-add-to-previous-sexp
    "a" 'sp-add-to-next-sexp
    "B" 'sp-backward-barf-sexp
    "b" 'sp-forward-barf-sexp
    "M" 'sp-backward-slurp-sexp
    "m" 'sp-forward-slurp-sexp
    "c" 'sp-convolute-sexp
    "D" 'sp-backward-kill-sexp
    "d" 'sp-kill-sexp
    "e" 'sp-emit-sexp
    "G" 'sp-end-of-sexp
    "g" 'sp-beginning-of-sexp
    "j" 'sp-join-sexp
    "K" 'sp-splice-sexp-killing-backward
    "k" 'sp-splice-sexp-killing-forward
    "n" 'sp-next-sexp
    "p" 'sp-previous-sexp
    "r" 'sp-raise-sexp
    "s" 'sp-splice-sexp-killing-around
    "t" 'sp-transpose-sexp
    "U" 'sp-backward-unwrap-sexp
    "u" 'sp-unwrap-sexp
    "w" 'sp-rewrap-sexp
    "x" 'sp-split-sexp
    "Y" 'sp-backward-copy-sexp
    "y" 'sp-copy-sexp
    "," 'sp-previous-sexp
    "." 'sp-next-sexp
    "<" 'sp-backward-down-sexp
    ">" 'sp-down-sexp))
#+end_src
** TeX
#+begin_src emacs-lisp
(after '(smartparens tex)
  (require 'smartparens-latex))
#+end_src
* EMR
Adds refactoring commands for Lisps.
#+begin_src emacs-lisp
(cb:install-package 'emr)
(add-hook 'prog-mode-hook 'emr-initialize)
#+end_src
** Set a key to show EMR menus
#+begin_src emacs-lisp
(bind-key "C-M-<return>" 'emr-show-refactor-menu)
#+end_src
* Whitespace
Visualise whitespace chars.
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'whitespace-mode)
#+end_src
** Highlight trailing whitespace and long lines
#+begin_src emacs-lisp
(setq whitespace-line-column 80
      whitespace-style '(face lines-tail))
#+end_src
** Ignore errors when starting whitespace mode
#+begin_src emacs-lisp
(defadvice whitespace-turn-on (around ignore-errors activate)
  (condition-case _
      ad-do-it
    (void-function)))
#+end_src
** Diminish
#+begin_src emacs-lisp
(hook-fn 'whitespace-mode-hook
  (diminish 'whitespace-mode))
#+end_src
* highlight-symbol
Highlights the symbol at point.
#+begin_src emacs-lisp
(cb:install-package 'highlight-symbol)
(add-hook 'prog-mode-hook 'highlight-symbol-mode)
#+end_src
** Highlight after a delay
#+begin_src emacs-lisp
(setq highlight-symbol-idle-delay 0.5)
#+end_src
** Override default face
#+begin_src emacs-lisp
(defface highlight-symbol-face
  '((((class color) (background dark))
     (:bold t :foreground "wheat3"))
    (((class color) (background light))
     (:bold t :foreground "wheat4")))
  "Face used by `highlight-symbol-mode'."
  :group 'highlight-symbol)
#+end_src
** Diminish
#+begin_src emacs-lisp
(hook-fn 'highlight-symbol-mode-hook
  (diminish 'highlight-symbol-mode))
#+end_src
* Modeline
Use a custom mode line.
** Faces
#+begin_src emacs-lisp
(defface mode-line-tramp-separator
  '((((background dark))
     (:foreground "gray45"))
    (((background light))
     (:foreground "gray80"))
    (t
     (:inherit 'mode-line)))
  "Face for separator characters in modeline."
  :group 'modeline)

(defface mode-line-tramp-method
  '((t (:inherit 'mode-line)))
  "Face for tramp method in modeline."
  :group 'modeline)

(defface mode-line-tramp-user
  '((t (:foreground "VioletRed3" :inherit 'mode-line)))
  "Face for tramp user indicator in modeline."
  :group 'modeline)

(defface modeline-vc-unknown-face
  '((((background dark))
     (:foreground "yellow"))
    (((background light))
     (:foreground "blue"))
    (t
     (:inherit 'mode-line)))
  "Face for unknown vc file status."
  :group 'modeline)

(defface mode-line-read-only
  '((t (:foreground "#4271ae"
                    :box '(:line-width 2 :color "#4271ae")
                    :inherit 'mode-line)))
  "Face for readonly indicator."
  :group 'modeline)

(defface mode-line-modified
  '((t (:foreground "#c82829" :inherit 'mode-line)))
  "Face for modified indicator."
  :group 'modeline)

(defface mode-line-directory
  '((((background dark))
     (:foreground "gray60"))
    (((background light))
     (:foreground "gray70"))
    (t
     (:inherit 'mode-line)))
  "Face for the directory component of the current filename."
  :group 'modeline)

(defface mode-line-filename
  '((((background light))
     (:foreground "darkgoldenrod4" :weight bold))
    (((background dark))
     (:foreground "#eab700" :weight bold))
    (t
     (:inherit 'mode-line)))
  "Face for the name component of the current filename."
  :group 'modeline)

(defface mode-line-position
  `((((background dark))
     (:family ,(monospace-font)
              :height 100
              :foreground "gray60"))
    (((background light))
     (:family ,(monospace-font)
              :height 100
              :foreground "gray50"))
    (t
     (:inherit 'mode-line)))
  "Face for the position indicators."
  :group 'modeline)

(defface mode-line-mode
  '((((background dark))
     (:foreground "gray70"))
    (((background light))
     (:foreground "gray40"))
    (t
     (:inherit 'mode-line)))
  "Face for the current major mode indicator."
  :group 'modeline)

(defface mode-line-minor-mode
  '((((background dark))
     (:foreground "gray40" :height 110))
    (((background light))
     (:foreground "gray70" :height 110))
    (t (:inherit 'mode-line-mode)))
  "Face for the current minor mode indicators."
  :group 'modeline)

(defface mode-line-process
  '((t (:foreground "#718c00" :inherit 'mode-line)))
  "Face for the current process."
  :group 'modeline)

(defface mode-line-80col
  '((((background dark))
     (:foreground "#eab700"))
    (((background light))
     (:foreground "#b58900"))
    (t
     (:inherit 'mode-line-position)))
  "Face for the warning when point is past column 80."
  :group 'modeline)

(defface modeline-org-notes-file-indicator
  `((t (:foreground
        ,solarized-hl-magenta
        :inherit
        'mode-line-position)))
  "Face for the indicator showing the name of the current org notes file."
  :group 'modeline)

#+end_src
** Vars
#+begin_src emacs-lisp
(defvar modeline-mail-indicator nil)

(defvar modeline-custom-description-functions nil
  "A list of functions.
The first function returning non-nil is used for the description
section in the modeline.")
#+end_src
** VC state
#+begin_src emacs-lisp
(cl-defun cb:vc-state->letter (&optional (file (buffer-file-name)))
  "Return a single letter to represent the current version-control status."
  (cl-case (ignore-errors (vc-state file))
    ((up-to-date)           " ")
    ((edited)               (propertize "M" 'face '(:foreground "red")))
    ((needs-merge conflict) (propertize "!" 'face '(:foreground "red")))
    ((added)                (propertize "A" 'face '(:foreground "green")))
    ((removed)              (propertize "D" 'face '(:foreground "red")))
    ((ignored)              (propertize "-" 'face 'modeline-vc-unknown-face))
    (t                      (propertize "?" 'face 'modeline-vc-unknown-face))))

(cl-defun cb:vc-file-uptodate? (&optional (file (buffer-file-name)))
  "Non-nil if FILE is up-to-date."
  (ignore-errors
    (vc-state-refresh file 'git)
    (equal 'up-to-date (vc-state file))))
#+end_src
** Filepath and buffer name
#+begin_src emacs-lisp
(cl-defun cb:shorten-directory (dir &optional (max-length 30))
  "Show up to MAX-LENGTH characters of a directory name DIR."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
        (output ""))
    (when (and path (equal "" (car path)))
      (setq path (cdr path)))
    ;; Ellipsize the path if it is too long.
    ;; `2` is the length of the path separator + ellipsis.
    (while (and path (< (length output) (- max-length 2)))
      (setq output (concat (car path) "/" output))
      (setq path (cdr path)))
    (when path
      (setq output (concat "…/" output)))
    output))

(cl-defun cb:propertize-file-directory
    (&optional (filepath (file-name-directory (buffer-file-name))))
  "Separate tramp info from the given filepath."
  (cl-flet ((face
             (str face)
             (propertize str 'face face)))

    (cl-destructuring-bind (&optional method user host file &rest rs)
        (mapcar 'identity (ignore-errors
                            (tramp-dissect-file-name filepath)))
      (concat
       (when host
         (concat
          (face "/" 'mode-line-tramp-separator)
          (face method 'mode-line-tramp-method)
          (face ":" 'mode-line-tramp-separator)
          (face user 'mode-line-tramp-user)
          (face "@" 'mode-line-tramp-separator)
          host
          (face ":" 'mode-line-tramp-separator)))
       (face (cb:shorten-directory (or file filepath)) 'mode-line-directory)))))

(defun cbmd:description ()
  "Format the mode line description.
This will normally be the path and buffer name, unless there is a suitable
entry in `modeline-custom-description-functions'."
  (or
   (-when-let (s (-first 'funcall modeline-custom-description-functions))
     (propertize (funcall s) 'face 'mode-line-filename))
   (concat
    (if (buffer-file-name) (cb:propertize-file-directory) "")
    (propertize (buffer-name) 'face 'mode-line-filename))))
#+end_src
** Unread mail count
*** Icon for modeline indicator
#+begin_src emacs-lisp
(defvar cbm:mail-icon (create-image (f-join cb:assets-dir "letter.xpm")
                                    'xpm nil :ascent 'center))
#+end_src
*** Define function to get unread count
#+begin_src emacs-lisp
(defun cbm:unread-mail-count ()
  "Return the number of unread messages in all folders in your maildir."
  (->> (f-directories user-mail-directory)
    (-mapcat 'f-directories)
    (-mapcat 'f-directories)
    (-filter (~ s-ends-with? "new"))
    (-remove (~ s-matches? (rx (or "low" "archive" "draft" "org"
                                   "deleted" "trash" "sent"))))
    (-map (C length f-files))
    (-sum)))
#+end_src
*** Define commands to set the modeline indicator
#+begin_src emacs-lisp
(defvar cbm:mode-line-indicator nil
  "The entry to display in the modeline.")

(defun cbm:make-indicator (n)
  (when (cl-plusp n)
    (concat
     (propertize "@" 'display cbm:mail-icon)
     (int-to-string n))))

(defun cbm:update-unread-count ()
  "Find the number of unread messages and update the modeline."
  (when (f-exists? user-mail-directory)
    (setq cbm:mode-line-indicator (cbm:make-indicator (cbm:unread-mail-count)))))
#+end_src
*** Set the indicator in a timer
#+begin_src emacs-lisp
(defvar cbm:unread-count-timer
  (run-with-timer 0 10 'cbm:update-unread-count))
#+end_src
** Mode line format
#+begin_src emacs-lisp
(setq-default
 mode-line-format
 `(
   ;; --------------------------------------------------------------------------
   ;; Line and column number.
   (:propertize " %4l:" face mode-line-position)
   (:eval
    ;; Warn if over 80 columns.
    (propertize "%3c" 'face
                (if (>= (current-column) 80)
                    'mode-line-80col
                  'mode-line-position)))

   " "

   ;; Evil state
   (:eval
    (if (and (featurep 'evil) (true? evil-mode))
        evil-mode-line-tag
      ""))

   ;; --------------------------------------------------------------------------
   ;; Mail status.
   (:eval (or (and (true? cbm:mode-line-indicator)
                   (concat " " cbm:mode-line-indicator " "))
              ""))

   ;; Pomodoro
   (:eval (or (and (true? org-pomodoro-mode-line)
                   (s-join "" org-pomodoro-mode-line))
              ""))

   ;; Current org notes file
   (:eval (or (and (true? org-init-notes-file)
                   (not (equal org-init-notes-file org-default-notes-file))
                   (propertize (concat " ["
                                       (f-filename (f-no-ext org-default-notes-file))
                                       "] ")
                               'face 'modeline-org-notes-file-indicator))
              ""))

   ;; --------------------------------------------------------------------------
   ;; File status.
   (:eval
    (let ((blank "    "))
      (cond
       ;; Do not show status for special buffers.
       ((and (s-starts-with? "*" (buffer-name))
             (not (buffer-file-name)))
        blank)

       ;; Show read-only indicator.
       (buffer-read-only
        (propertize " RO " 'face 'mode-line-read-only))

       ;; Show modified and vc status.
       (t
        (format " %s%s "
                (if (ignore-errors (vc-git-root (buffer-file-name)))
                    (cb:vc-state->letter)
                  " ")
                (if (buffer-modified-p)
                    (propertize "*" 'face 'mode-line-modified)
                  " "))))))
   " "
   ;; --------------------------------------------------------------------------
   ;; Buffer name and path.
   (:eval (cbmd:description))

   ;; --------------------------------------------------------------------------
   ;; Narrowing
   " %n "

   ;; --------------------------------------------------------------------------
   ;; Mode details.

   ;; Major mode.
   " %["
   (:propertize mode-name
                face mode-line-mode)
   "%] "

   ;; Minor modes.
   (:eval (propertize (format-mode-line minor-mode-alist)
                      'face 'mode-line-minor-mode))
   (:propertize mode-line-process
                face mode-line-process)
   " "
   (:eval (or (ignore-errors
                (propertize modeline-mail-indicator 'face 'mode-line-emphasis))
              ""))
   " "
   (global-mode-string global-mode-string)))
#+end_src
* Git
** Magit
Magit provides a convenient interface to git commands.
#+begin_src emacs-lisp
(cb:install-package 'magit)
(unless noninteractive
  (require 'magit))
#+end_src
*** Declare a key binding to show magit fullscreen
#+begin_src emacs-lisp
(declare-modal-executor magit-status
  :command (call-interactively 'magit-status)
  :bind    "M-G")
#+end_src
*** Use ido to read the magit directory
#+begin_src emacs-lisp
(after 'magit
  (declare-ido-wrapper magit-read-top-dir))
#+end_src
*** Customise magit according to global git config
#+begin_src emacs-lisp
(add-hook 'magit-mode-hook 'magit-load-config-extensions)
#+end_src
*** Evil
**** DEFER
#+begin_src emacs-lisp
(after '(magit evil)
#+end_src
**** Bind common magit commands to the /g/ prefix in normal state
#+begin_src emacs-lisp
(evil-global-set-keys 'normal
 "g P" 'magit-key-mode-popup-pushing
 "g c" 'magit-key-mode-popup-committing
 "g l" 'magit-log
 "g r" 'magit-reflog
 "g D" 'magit-diff-working-tree
 "g B" 'magit-blame-mode
 "g b" (command
        (with-window-restore
          (magit-branch-manager)
          (buffer-local-set-key (kbd "q") (command (restore))))))
#+end_src
**** Use evil key bindings in magit diff mode
#+begin_src emacs-lisp
(define-keys magit-diff-mode-map
  "C-f" 'evil-scroll-page-down
  "C-b" 'evil-scroll-page-up
  "j"   'evil-next-line
  "k"   'evil-previous-line
  "/"   'evil-search-forward)
#+end_src
**** Use emacs state in rebase buffers
#+begin_src emacs-lisp
(hook-fn 'git-rebase-mode-hook
  (when (true? evil-mode)
    (evil-emacs-state)))
#+end_src
**** END
#+begin_src emacs-lisp
)
#+end_src
*** Dired
Override dired's default bindings to enable Magit from dired mode.
#+begin_src emacs-lisp
(after 'dired
  (define-key dired-mode-map (kbd "M-G") 'magit-status))
#+end_src
*** Modal views
Declare modal views for magit.
#+begin_src emacs-lisp
(declare-modal-view magit-status)
(declare-modal-view magit-log)
(declare-modal-view magit-reflog)
(declare-modal-view magit-diff-working-tree)
(declare-modal-view magit-diff)
#+end_src
*** Modeline
Update git status in the modeline magit commands.
**** Define a hook for all magit commands
#+begin_src emacs-lisp
(define-combined-hook cb:magit-command-hook
  (--filter-atoms (s-matches? "^magit-.*-command-hook$" (symbol-name it))))
#+end_src
**** Use this hook to force modeline updates
#+begin_src emacs-lisp
(hook-fn 'cb:magit-command-hook
  (force-mode-line-update t))
#+end_src
*** Diminish magit-auto-revert-mode
#+begin_src emacs-lisp
(diminish 'magit-auto-revert-mode)
#+end_src
** git-auto-commit-mode
Minor mode that will automatically commit changes on save.
#+begin_src emacs-lisp
(cb:install-package 'git-auto-commit-mode)
#+end_src
*** Mark variables as safe
#+begin_src emacs-lisp
(add-to-list 'safe-local-variable-values '(gac-automatically-push-p . t))
#+end_src
** git-commit-mode
Provides a major mode for editing commit messages. Used by magit.
#+begin_src emacs-lisp
(add-hook 'git-commit-mode-hook 'turn-on-auto-fill)
(put 'git-commit-mode 'fill-column 72)
#+end_src
*** Evil
Enter insertion state when prompted to enter commit messages.
#+begin_src emacs-lisp
(add-hook 'git-commit-mode-hook 'cb:maybe-evil-insert-state)
#+end_src
** Gist
Provides an Elisp interface to GitHub Gists.
#+begin_src emacs-lisp
(cb:install-package 'gist)
#+end_src
** gitconfig-mode
Provides a major mode for editing git config files.
#+begin_src emacs-lisp
(cb:install-package 'gitconfig-mode)
#+end_src
** git-gutter+
Marks unstaged and deleted hunks in the gutter.
#+begin_src emacs-lisp
(cb:install-package 'git-gutter+)
(unless noninteractive
  (global-git-gutter+-mode +1))
#+end_src
*** Refresh git gutter after saving
#+begin_src emacs-lisp
(hook-fn 'after-save-hook
  (when (true? git-gutter+-mode)
    (ignore-errors
      (git-gutter+-refresh))))
#+end_src
*** Use an idle timer to refresh git gutter status
#+begin_src emacs-lisp
(defvar cb-git:gutter-refresh-idle-timer
  (unless noninteractive
    (run-with-idle-timer 1.5 t (lambda ()
                                 (when (true? git-gutter+-mode)
                                   (ignore-errors (git-gutter+-refresh)))))))
#+end_src
*** Diminish
#+begin_src emacs-lisp
(hook-fn 'git-gutter+-mode-hook
  (diminish 'git-gutter+-mode))
#+end_src
** Hacky fixes
Internal functions attempt to call =magit-read-top-dir= as a variable. Bind a
variable to prevent errors.
#+begin_src emacs-lisp
(defvar magit-read-top-dir 'magit-read-top-dir)
#+end_src

The close buffer function is broken. Redefine it so that it works.
#+begin_src emacs-lisp
(after 'git-gutter+
  (defun git-gutter+-close-commit-edit-buffer ()
    "Abort edits and discard commit message being composed."
    (interactive)
    (remove-hook 'kill-buffer-hook 'server-kill-buffer t)
    (remove-hook 'kill-buffer-query-functions 'git-commit-kill-buffer-noop t)
    (let ((clients (git-commit-buffer-clients)))
      (if clients
          (dolist (client clients)
            (server-send-string client "-error Commit aborted by user")
            (delete-process client))
        (kill-buffer)))

    (set-window-configuration git-gutter+-pre-commit-window-config)))
#+end_src
** Utilities
Define a command to add the current buffer to git, or stage all changes.
#+begin_src emacs-lisp
(defun cb-git:add ()
  "Run 'git add' on the file for the current buffer."
  (interactive)
  (cond
   ((not (buffer-file-name))
    (user-error "Buffer has no corresponding file"))
   ((not (vc-git-root (buffer-file-name)))
    (user-error "Not a git repository"))
   ((yes-or-no-p "Stage all changes to this file?")
    (save-buffer)
    (vc-git-register (list (buffer-file-name)))
    (message "Done.")))
  (git-gutter+-refresh))
#+end_src
** Evil
Define bindings for working with git hunks under the /g/ prefix.
#+begin_src emacs-lisp
(after '(git-gutter+ evil)
  (evil-global-set-keys 'normal
    "g n" (lambda (arg)
            (interactive "p")
            (git-gutter+-refresh)
            (git-gutter+-next-hunk arg))
    "g p" (lambda (arg)
            (interactive "p")
            (git-gutter+-refresh)
            (git-gutter+-previous-hunk arg))
    "g h" 'git-gutter+-popup-hunk
    "g x" 'git-gutter+-revert-hunk
    "g s" 'git-gutter+-stage-hunks
    "g a" 'cb-git:add)

  (add-hook 'magit-commit-mode-hook 'cb:maybe-evil-insert-state))
#+end_src
** git-gutter-fringe+
I'm using a submodule version right now because the MELPA version has
unsatisfiable dependencies.
#+begin_src emacs-lisp
(cb:install-package 'fringe-helper)
(after 'git-gutter+ (require 'git-gutter-fringe+))
#+end_src
* Diffs
** Ediff
Configure ediff variables.
#+begin_src emacs-lisp
(setq diff-switches "-u"
      ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src
** Use /q/ to close diffs
#+begin_src emacs-lisp
(defun cb-diff:close ()
  (interactive)
  (when (> (length (window-list)) 1)
    (kill-buffer-and-window)))

(after 'diff-mode
  (define-key diff-mode-map (kbd "q") 'cb-diff:close))
#+end_src
** Evil
*** Disable evil-mode when running diffs
#+begin_src emacs-lisp
(after 'evil
  (add-hook 'ediff-startup-hook 'turn-off-evil-mode))
#+end_src
*** Use /q/ to close diffs
#+begin_src emacs-lisp
(after 'evil
  (evil-define-key 'normal diff-mode-map (kbd "q") 'cb-diff:close))
#+end_src
* Popwin
Allows you to declare buffers as popups and customise their properties.
#+begin_src emacs-lisp
(cb:install-package 'popwin t)
#+end_src
** Customise buffer handling
#+begin_src emacs-lisp
(setq display-buffer-function 'popwin:display-buffer
      popwin:special-display-config
      '(("*Help*"  :height 30 :stick t)
        ("*Completions*" :noselect t)
        ("*Shell Command Output*")
        ("*compilation*" :noselect t)
        ("*Compile-Log*" :height 7 :noselect t)
        ("*Messages*" :height 30)
        ("* Racket REPL *" :height 7 :stick t)
        ("*Geiser dbg*" :height 7)
        ("*execute scheme*" :height 7 :noselect t)
        ("*haskell*" :height 7 :stick t)
        ("*Directory*")
        ("*Org Note*")
        ("*response*" :height 7 :noselect t)
        ("*jedi:doc*" :height 30)
        ("*robe-doc*" :height 30)
        ("*idris-repl*" :height 30)
        ("*idris-notes*")
        ("*idris-info*")
        ("*utop*" :height 30)
        ("\\*cider-repl " :height 7 :regexp t :stick t)
        ("*cider doc*" :height 30)
        ("*bbdb*")
        ("*BBDB*")
        ("*Occur*" :noselect t)
        ("\\*Slime Description.*" :noselect t :regexp t :height 30)
        ("\\*Slime Inspector.*" :regexp t :height 30)
        ("*sldb.*" :regexp t :height 30)
        ("*Ido Completions*" :noselect t :height 30)
        (".*overtone.log" :regexp t :height 30)
        ("*gists*" :height 30)))
#+end_src
* Dired
#+begin_src emacs-lisp
(setq dired-auto-revert-buffer t)
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'dired
#+end_src
** Show directories before files
#+begin_src emacs-lisp
(setq dired-listing-switches "-al --group-directories-first")
#+end_src
** Define compressed file types
#+begin_src emacs-lisp
(setq dired-compress-file-suffixes
      '(("\\.zip\\'" ".zip" "unzip")
        ("\\.gz\\'" "" "gunzip")
        ("\\.tgz\\'" ".tar" "gunzip")
        ("\\.Z\\'" "" "uncompress")
        ("\\.z\\'" "" "gunzip")
        ("\\.dz\\'" "" "dictunzip")
        ("\\.tbz\\'" ".tar" "bunzip2")
        ("\\.bz2\\'" "" "bunzip2")
        ("\\.xz\\'" "" "unxz")
        ("\\.tar\\'" ".tgz" nil)))
#+end_src
** Don't bind C-x C-j to dired-jump
This interferes with bindings in ansi-term.
#+begin_src emacs-lisp
(setq dired-bind-jump nil)
#+end_src
** dired-details
Toggle file and directory details, such as size and permissions.
#+begin_src emacs-lisp
(cb:install-package 'dired-details t)
(dired-details-install)
#+end_src
*** Use an ellipsis to indicate hidden details
#+begin_src emacs-lisp
(setq-default dired-details-hidden-string "… ")
#+end_src
** Omit certain files
Use =dired-omit-mode= to hide boring files from dired views.
#+begin_src emacs-lisp
(require 'dired-x)
(add-hook 'dired-mode-hook 'dired-omit-mode)
#+end_src
*** Configure files to hide
#+begin_src emacs-lisp
(setq dired-omit-files
      (regexp-opt (list "^\\.?#" "^\\.$" "^\\.\\.$"
                        "\\.DS_Store$" "\\$RECYCLE.BIN")))
#+end_src
** hl-line compatability
Advise hl-line functions not to apply highlight to dired directory headers.
#+begin_src emacs-lisp
(defun cb:line-is-dired-header? ()
  (equal 'dired-header
         (ignore-errors
           (save-excursion
             (move-to-column 3)
             (face-at-point)))))

(defadvice global-hl-line-highlight (around suppress-on-subdir-header activate)
  "Do not highlight the line if looking at a dired header."
  (if (and (derived-mode-p 'dired-mode) (cb:line-is-dired-header?))
      (global-hl-line-unhighlight)
    ad-do-it))

(defadvice hl-line-highlight (around suppress-on-subdir-header activate)
  "Do not highlight the line if looking at a dired header."
  (if (and (derived-mode-p 'dired-mode) (cb:line-is-dired-header?))
      (hl-line-unhighlight)
    ad-do-it))
#+end_src
** OS X
Use GNU version of =ls= where available.
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (-when-let (gls (executable-find "gls"))
    (setq ls-lisp-use-insert-directory-program t
          insert-directory-program gls)))
#+end_src
** Define keys to navigate by subdirs
#+begin_src emacs-lisp
(define-key dired-mode-map (kbd "M-N") 'dired-next-subdir)
(define-key dired-mode-map (kbd "M-P") 'dired-prev-subdir)
#+end_src
** Evil
Load the following after =evil=.
#+begin_src emacs-lisp
(after 'evil
#+end_src
*** Define bindings for working with subdirs
#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map (kbd "SPC") 'dired-hide-subdir)
(evil-define-key 'normal dired-mode-map (kbd "TAB") 'dired-hide-subdir)
(evil-define-key 'normal dired-mode-map [backtab] 'dired-hide-all)
(evil-define-key 'normal dired-mode-map [backspace] 'dired-kill-subdir)
#+end_src
*** Bind commands to show containing folder in dired
#+begin_src emacs-lisp
(bind-key* "M-d" 'dired-jump)
(bind-key* "M-D" 'dired-jump-other-window)
#+end_src
#+begin_src emacs-lisp
)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* Fortune
** Define a command to show the output of the =fortune= command
#+begin_src emacs-lisp
(defun fortune ()
  "Display a quotation from the 'fortune' program."
  (interactive)
  (-when-let (fortune (--first (ignore-errors (file-exists-p it))
                               (list (executable-find "fortune")
                                     "/usr/bin/fortune"
                                     "/usr/local/bin/fortune" )))
    (message (s-trim (shell-command-to-string (concat fortune " -s -n 250"))))))
#+end_src
** Show fortune after init
#+begin_src emacs-lisp
(defun cb:show-fortune ()
  "Show fortune if started without a file to visit."
  (run-with-idle-timer
   0.1 nil
   (lambda ()
     (when (or (-contains? '("*scratch*" "notes.org" "todo.org") (buffer-name))
               (derived-mode-p 'org-agenda-mode))
       (fortune)))))

(hook-fn 'after-make-frame-functions (cb:show-fortune))
(add-hook 'after-init-hook 'cb:show-fortune)
#+end_src

* Info
** Increase line spacing for legibility
#+begin_src emacs-lisp
  (defun cbinfo:set-line-spacing ()
    ;; NB: line spacing is measured in pixels.
    (setq line-spacing 2))

  (add-hook 'Info-mode-hook 'cbinfo:set-line-spacing)
#+end_src
** Set key bindings
#+begin_src emacs-lisp
(after 'info
  (define-key Info-mode-map (kbd "SPC") 'Info-scroll-up)
  (define-key Info-mode-map (kbd "S-SPC") 'Info-scroll-down))
#+end_src
** Keep info history navigation bindings in evil-mode
#+begin_src emacs-lisp
(after '(evil info)
  (evil-define-key 'motion Info-mode-map
    (kbd "l") 'Info-history-back
    (kbd "r") 'Info-history-forward))
#+end_src
* Compilation
** Configure variables
#+begin_src emacs-lisp
(setq compilation-window-height    12
      compilation-scroll-output    'first-error)
#+end_src
** Add global compilation bindings
#+begin_src emacs-lisp
(bind-key "C-c b" 'compile)
(bind-key "C-c C-b" 'recompile)
#+end_src
** Find makefiles in projects
#+begin_src emacs-lisp
(autoload 'projectile-project-root "projectile")
(autoload 'projectile-project-p "projectile")

(hook-fn 'find-file-hook
  (when (projectile-project-p)
    (setq-local compilation-directory (projectile-project-root))))
#+end_src
** Colourise output
Interpret ANSI colour codes in compilation output buffers.
#+begin_src emacs-lisp
(defun cb:ansi-colourise-compilation ()
      (ansi-color-apply-on-region compilation-filter-start (point)))

(add-hook 'compilation-filter-hook 'cb:ansi-colourise-compilation)
#+end_src
** Automatically close compilation buffers on success
#+begin_src emacs-lisp
(defun cb:compile-autoclose (buf string)
  "Automatically close the compile window."
  (cond
   ;; Ignore if this isn't a normal compilation window.
   ((not (equal (buffer-name buf) "*compilation*")))

   ((not (s-contains? "finished" string))
    (message "Compilation exited abnormally: %s" string))

   ((s-contains? "warning" (with-current-buffer buf
                             (buffer-string)) 'ignore-case)
    (message "Compilation succeeded with warnings"))

   (t
    (ignore-errors
      (delete-window (get-buffer-window buf)))
    (message "Compilation succeeded"))))

(add-to-list 'compilation-finish-functions 'cb:compile-autoclose)
#+end_src
* eshell
Provides a shell implemented in emacs-lisp.
** Redirect attempts to edit files to =find-file=
#+begin_src emacs-lisp
(setenv "EDITOR" "emacsclient")
#+end_src
** Declare type as ansi term
#+begin_src emacs-lisp
(setenv "TERM" "ansi")
#+end_src
** Use case-insenitive file completion
#+begin_src emacs-lisp
(setq eshell-cmpl-ignore-case t)
#+end_src
** Cycle command
Create a key-binding for showing and hiding the terminal.
#+begin_src emacs-lisp
(defun cb:term-cycle (&optional arg)
  "Cycle through various terminal window states."
  (interactive "P")
  (cond
   (arg
    (eshell arg))

   ((--none? (with-current-buffer it (derived-mode-p 'eshell-mode))
             (buffer-list))
    (eshell))

   ;; If terminal is maximized, restore previous window config.
   ((and (derived-mode-p 'eshell-mode)
         (equal 1 (length (window-list))))
    (or (ignore-errors (jump-to-register :term-fullscreen) t)
        (bury-buffer)))

   ;; If we're looking at the terminal, maximise it.
   ((derived-mode-p 'eshell-mode)
    (delete-other-windows))

   ;; Otherwise show the terminal.
   (t
    ;; Hide the term window if it's visible.
    (-when-let (win (--first
                     (with-current-buffer (window-buffer it)
                       (derived-mode-p 'eshell-mode))
                     (window-list)))
      (delete-window win))
    ;; Save this configuration to a register so that it can be restored
    ;; for later positions in the cycle.
    (window-configuration-to-register :term-fullscreen)
    ;; Show terminal.
    (switch-to-buffer (--first-buffer (derived-mode-p 'eshell-mode))))))

(bind-key* "<f1>" 'cb:term-cycle)
#+end_src
** Clear command
Define a command to clear the eshell buffer.

#+begin_src emacs-lisp
(defun eshell/clear ()
  "Clear the eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (delete-region (point-min)
                   (save-excursion
                     (goto-char (point-max))
                     (search-backward-regexp eshell-prompt-regexp)
                     (let ((prompt-line (line-beginning-position)))
                       (forward-line -1)
                       (if (s-matches? (rx bol (+ space "[")) (current-line))
                           (line-beginning-position)
                         prompt-line))))))
#+end_src

Bind the above command. It must be set in a hook, because the map isn't created
until =eshell-mode= is called.

#+begin_src emacs-lisp
(hook-fn 'eshell-mode-hook
  (define-key eshell-mode-map (kbd "C-l") 'eshell/clear))
#+end_src

** Custom prompt

Define a custom eshell prompt with the following features:
- Displays the current working directory only when it changes
- Shows git status.

Define a face for prompt separators.

#+begin_src emacs-lisp
(defface eshell-prompt-sep
  '((t :inherit 'font-lock-comment-face))
  "Face for separators in the eshell prompt."
  :group 'cb-eshell)
#+end_src

Do not use the built-in highlight.

#+begin_src emacs-lisp
(setq eshell-highlight-prompt nil)
#+end_src

Tell eshell how to find the prompt.

#+begin_src emacs-lisp
(setq eshell-prompt-regexp (rx bol (* space) (or "#" ":") space))
 #+end_src

Define utilities to format the prompt.

#+begin_src emacs-lisp
(defun cb-eshell:current-dir ()
  (let* ((cwd (f-short (eshell/pwd)))
         (colour (if (s-starts-with? "/" cwd)
                     solarized-hl-orange
                   solarized-hl-cyan))
         (dir (propertize cwd 'face (list :foreground colour))))

    (list
     (cons "cwd" dir))))

(defun cb-eshell:directory-info ()
  (let* ((cwd (if (s-blank? (eshell/pwd)) "." (eshell/pwd)))
         (ls-result (%-string "ls -ld" (%-quote cwd))))
    (unless (s-matches? "No such file or directory" ls-result)
      (cl-destructuring-bind (&optional perms _links owner group &rest _)
          (s-split (rx (+ space)) ls-result)
        (unless (equal owner (%-string "whoami"))
          (list
           (cons "mode"
                 (propertize perms 'face `(:foreground ,solarized-hl-cyan)))
           (cons "owner"
                 (propertize owner 'face `(:foreground ,solarized-hl-cyan)))
           (cons "group"
                 (propertize group 'face `(:foreground ,solarized-hl-cyan)))))))))

(defun cb-eshell:git-anything-untracked? ()
  "Non-nil if there are any untracked files in the current git repo."
  (->> (%-string "git status -u -s --porcelain")
    (s-split "\n")
    (--any? (s-matches? (rx (* space) "??") it))))

(defun cb-eshell:git-status ()
  (require 'magit)
  (when (and (executable-find "git")
             (locate-dominating-file (eshell/pwd) ".git"))
    (let ((branch (%-string "git rev-parse --abbrev-ref HEAD"))
          (sha (substring (%-string "git rev-parse HEAD") 0 7))
          (state (-non-null
                  (list
                   (when (cb-eshell:git-anything-untracked?)
                     (propertize "new" 'face
                                 `(:foreground ,solarized-hl-cyan)))
                   (when (magit-anything-unstaged-p)
                     (propertize "mod" 'face
                                 `(:foreground ,solarized-hl-orange)))
                   (when (magit-anything-staged-p)
                     (propertize "staged" 'face
                                 `(:foreground ,solarized-hl-green)))))))
      (-non-null
       (list

        (cons "branch"
              (propertize branch 'face
                          `(:foreground ,solarized-hl-yellow)))
        (cons "rev" sha)

        (when state
          (cons "state"
                (s-join (propertize "," 'face 'eshell-prompt-sep)
                        state))))))))

(defun cb-eshell:prompt-symbol ()
  (let ((ch (if (= (user-uid) 0) "#" ":"))
        (colour (if (zerop eshell-last-command-status)
                    solarized-hl-cyan
                  solarized-hl-red)))
    (propertize ch 'face (list :foreground colour))))

(defun cb-eshell:make-header-list ()
  "Create a list of alists, representing lines in the header.
Each alist has a string as the key and a "
  (list
   (cb-eshell:current-dir)
   (cb-eshell:directory-info)
   (cb-eshell:git-status)))

(cl-defun cb-eshell:format-cons ((k . v))
  (if (equal k "cwd")
      v
    (concat (propertize (concat k "=") 'face 'eshell-prompt-sep)
            v)))

(defun cb-eshell:header-list->string (header-list)
  (concat
   (propertize " [ " 'face 'eshell-prompt-sep)

   (->> header-list
     (--map (->> it (-map 'cb-eshell:format-cons) (s-join " ")))
     (-remove (C s-blank? s-trim))
     (s-join (propertize " | " 'face 'eshell-prompt-sep)))

   (propertize " ]" 'face 'eshell-prompt-sep)
   "\n"))

(defvar-local cb-eshell:last-header nil)

(defun cb-eshell:format-prompt ()
  "Format the prompt to display in eshell."
  (let* ((hlist (cb-eshell:make-header-list))
         (diff (-difference hlist cb-eshell:last-header)))
    (setq cb-eshell:last-header hlist)
    (concat
     (when cb-eshell:last-header "\n")
     (when diff (cb-eshell:header-list->string diff))
     (propertize (concat " " (cb-eshell:prompt-symbol) " ")
                 'read-only t
                 'front-sticky 'read-only
                 'rear-nonsticky 'read-only))))
#+end_src

Use the above prompt functions.

#+begin_src emacs-lisp
(setq eshell-prompt-function 'cb-eshell:format-prompt)
#+end_src

** Smartparens
#+begin_src emacs-lisp
(after 'smartparens
  (add-hook 'eshell-mode-hook 'smartparens-mode))
#+end_src
** Include current directory in buffer name
#+begin_src emacs-lisp
(defun cb-eshell:format-buffer-name ()
  "Make a buffer name based on the current directory."
  (generate-new-buffer-name
   (concat "eshell: " (f-short (eshell/pwd)))))

(hook-fn 'eshell-directory-change-hook
  (rename-buffer (cb-eshell:format-buffer-name)))
#+end_src
* undo-tree
Provides a graphical view of the undo history.
#+begin_src emacs-lisp
(cb:install-package 'undo-tree t)
(global-undo-tree-mode +1)
#+end_src
** Set global key binding
#+begin_src emacs-lisp
(bind-key "C-x u" 'undo-tree-visualize)
#+end_src
** Diminish
#+begin_src emacs-lisp
(diminish 'undo-tree-mode)
#+end_src
* iedit
Provides commands for transforming and replacing occurrences of a symbol in the
buffer.
#+begin_src emacs-lisp
(cb:install-package 'iedit)
#+end_src
** Define a global key binding
#+begin_src emacs-lisp
(bind-key "M-r" 'iedit-mode)
#+end_src
** Define a command picker for iedit
#+begin_src emacs-lisp
(defun cbiedit:replace-read ()
  (iedit-replace-occurrences (read-string "Replace in buffer: ")))

(defun cbiedit:restrict-to-region ()
  (iedit-restrict-region (region-beginning) (region-end)))

(defun cbiedit:remove-region ()
  (iedit-restrict-region (region-beginning) (region-end) t))

(defun cbiedit:replace-in-region ()
  (cbiedit:restrict-to-region)
  (cbiedit:replace-read))

(define-command-picker iedit-picker
  :title "*iedit*"
  :options
  '(("e" "Expand"
     iedit-expand-by-a-line
     :unless region-active-p)

    ("p" "Expand (up)"
     iedit-expand-up-a-line
     :unless region-active-p)

    ("n" "Expand (down)"
     iedit-expand-down-a-line
     :unless region-active-p)

    ("r" "Replace (in region)"
     cbiedit:replace-in-region
     :when region-active-p)

    ("r" "Replace"
     cbiedit:replace-read
     :unless region-active-p)

    ("k" "Delete Matches"
     iedit-delete-occurrences
     :unless region-active-p)

    ("l" "Restrict (line)"
     iedit-restrict-current-line
     :unless region-active-p)

    ("R" "Restrict (region)"
     cbiedit:restrict-to-region
     :when region-active-p)

    ("x" "Remove (region)"
     cbiedit:remove-region
     :when region-active-p)
    ("f" "Restrict (function)"
     iedit-restrict-function
     :when (lambda () (thing-at-point 'defun)))

    ("c" "Toggle Case-Sensitivity" iedit-toggle-case-sensitive)
    ("t" "Toggle at Point" iedit-toggle-selection)
    ("d" "Done" iedit-done)))

(after 'iedit
  (bind-key "M-r" 'iedit-picker iedit-mode-keymap))
#+end_src
* smooth-scrolling
Changes the default scrolling behaviour to keep point away from the top or
bottom of the window in order to show scrolling context.
#+begin_src emacs-lisp
(cb:install-package 'smooth-scrolling t)
#+end_src
* midnight
Runs a hook at midnight. By default it will clean unused buffers.
#+begin_src emacs-lisp
(cb:install-package 'midnight t)
#+end_src
* hideshow
Provides code folding. Used by evil-mode.
** Diminish hideshow
#+begin_src emacs-lisp
(hook-fn 'hs-minor-mode-hook
  (diminish 'hs-minor-mode))
#+end_src
** Ignore errors when starting
#+begin_src emacs-lisp
(defadvice hs-minor-mode (around no-errs activate)
  (ignore-errors ad-do-it))
#+end_src

* abbrev
Declare abbreviations that will be automatically expanded when typed. I don't
actually use this, but python mode seems to load it.
** Create abbrev file in tmp
#+begin_src emacs-lisp
(setq abbrev-file-name (f-join cb:tmp-dir "abbrev_defs"))
#+end_src
* dictionary
Provides dictionary search functions.
#+begin_src emacs-lisp
(cb:install-package 'dictionary t )
#+end_src
* auto-revert
Minor mode that reverts the buffer if it changes on disk.
** Diminish auto-revert
#+begin_src emacs-lisp
(hook-fn 'auto-revert-mode-hook
  (diminish 'auto-revert-mode))
#+end_src
* file-template
Provides file skeletons.
#+begin_src emacs-lisp
(unless noninteractive (require 'file-template))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'file-template
#+end_src
** Insert file templates automatically when creating new files
#+begin_src emacs-lisp
(add-hook 'find-file-not-found-hooks
          'file-template-find-file-not-found-hook 'append)

(setq file-template-insert-automatically t)
#+end_src
** Add personal file templates directory
#+begin_src emacs-lisp
(defvar cb:file-templates-dir (f-join user-emacs-directory "templates"))
(setq file-template-paths (list cb:file-templates-dir))
#+end_src
** Load file templates programatically from personal templates directory
#+begin_src emacs-lisp
(setq file-template-mapping-alist
      (->> (f-files cb:file-templates-dir)
        (-map 'f-filename)
        (--map (cons (format "\\.%s$" (f-ext it)) it))))
#+end_src
** After inserting file templates, reset the undo history
#+begin_src emacs-lisp
(hook-fn 'file-template-insert-hook
      (setq buffer-undo-list nil
            buffer-undo-tree nil))
#+end_src
** define helper function for org template
#+begin_src emacs-lisp
(defun cbtmpl:org-skeleton-title (filename)
  "Format the title to use for the given FILENAME."
  (->> (f-filename (f-no-ext filename))
    s-split-words
    (-map 's-capitalize)
    (s-join " ")))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* skeletor
Provides project skeletons.
#+begin_src emacs-lisp
(cb:install-package 'skeletor)

(skeletor-define-template "ocaml-project"
  :title "OCaml Project")
#+end_src
* expand-region
Provides commands for expanding and contracting the active region.
#+begin_src emacs-lisp
(cb:install-package 'expand-region)
#+end_src
** Set global bindings for expanding and contracting regions
#+begin_src emacs-lisp
(global-set-key (kbd "M-<up>") 'er/expand-region)
(global-set-key (kbd "M-<down>") 'er/contract-region)
#+end_src
* artist
Provides ascii-art drawing functions.
** If evil-mode is active, use emacs state for artist mode
#+begin_src emacs-lisp
(after 'evil-mode
  (add-hook 'artist-mode-hook 'evil-emacs-state))
#+end_src
* ace-jump-mode
Provides commands for quickly moving around the visible part of the buffer.
#+begin_src emacs-lisp
(cb:install-package 'ace-jump-mode)
#+end_src
** Bind a global hotkey
#+begin_src emacs-lisp
(bind-key "S-<return>" 'ace-jump-word-mode)
#+end_src
** Use ESC to quit ace-jump
#+begin_src emacs-lisp
(hook-fns '(ace-jump-line-mode ace-jump-word-mode ace-jump-char-mode)
  (local-set-key (kbd "ESC") 'keyboard-quit))
#+end_src
** Exit recursive edits when jumping
#+begin_src emacs-lisp
(hook-fn 'ace-jump-mode-end-hook
  (ignore-errors (exit-recursive-edit)))
#+end_src
* BBDB
Provides an address book for emacs and integrates with many modes.
#+begin_src emacs-lisp
(cb:install-package 'bbdb)
#+end_src
** Set the location of the user BBDB file
#+begin_src emacs-lisp
(setq bbdb-file (concat user-dropbox-directory ".bbdb"))
#+end_src
** Customise popup appearance
#+begin_src emacs-lisp
(setq bbdb-use-popup t
      bbdb-pop-up-window-size 0.5
      bbdb-mua-popup-window-size 4
      bddb-popup-target-lines 1)
#+end_src
** Offer to add message senders to BBDB
#+begin_src emacs-lisp
(setq bbdb-offer-save 1
      bbdb-always-add-address t)
#+end_src
** Do not add automated messages to contacts
#+begin_src emacs-lisp
(setq bbdb/mail-auto-create-p 'bbdb-ignore-some-messages-hook)
(setq bbdb-ignore-some-messages-alist
      '(( "From" . "no.?reply\\|DAEMON\\|daemon\\|facebookmail\\|twitter")))
#+end_src
** Configure display style
#+begin_src emacs-lisp
(setq bbdb-complete-name-allow-cycling t
      bbdb-use-alternate-names t
      bbdb-elided-display t)
#+end_src
** Configure completion behaviour
#+begin_src emacs-lisp
(setq bbdb-electric t
      bbdb-completion-type nil)
#+end_src
** Customise Miscellaneous variables
#+begin_src emacs-lisp
(setq bbdb-dwim-net-address-allow-redundancy t
      bbdb-quiet-about-name-mismatches 2
      bbdb-canonicalize-redundant-nets-p t
      bbbd-message-caching-enabled t)
#+end_src
** Configure BBDB support in other modes
#+begin_src emacs-lisp
(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
(add-hook 'message-mode-hook 'bbdb-insinuate-mail)
#+end_src
** Evil
Add evil key bindings to BBDB.
#+begin_src emacs-lisp
(after '(bbdb evil)
  (define-key bbdb-mode-map (kbd "j") 'bbdb-next-record)
  (define-key bbdb-mode-map (kbd "k") 'bbdb-prev-record)
  (define-key bbdb-mode-map (kbd "l") 'bbdb-next-field)
  (define-key bbdb-mode-map (kbd "h") 'bbdb-prev-field))
#+end_src
* w3m
Configure w3m bindings for Emacs. w3m is a command-line web browser.
#+begin_src emacs-lisp
(when (executable-find "w3m")
  (cb:install-package 'w3m))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'w3m
#+end_src
** Increase default line spacing
#+begin_src emacs-lisp
(hook-fn 'w3m-mode-hook (setq line-spacing 5))
#+end_src
** Executor
Declare a modal command to show w3m.
#+begin_src emacs-lisp
(declare-modal-executor w3m
  :command w3m
  :bind "M-W"
  :restore-bindings '("M-W" "M-E"))
#+end_src
** Evil
*** Define evil-style movement keys for w3m
#+begin_src emacs-lisp
(after 'evil
  (bind-keys
    :map w3m-mode-map
    "z t" 'evil-scroll-line-to-top
    "z b" 'evil-scroll-line-to-bottom
    "z z" 'evil-scroll-line-to-center
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up
    "y"   'evil-yank
    "p"   'evil-paste-after
    "/"   'evil-search-forward
    "?"   'evil-search-backward
    "n"   'evil-search-next
    "N"   'evil-search-previous))
#+end_src
*** Define a command to open the URL at point with w3m
#+begin_src emacs-lisp
(autoload 'thing-at-point-url-at-point "thingatpt")

(defun w3m-browse-dwim (url)
  "Browse to URL, ensuring it begins with http:// as required by w3m."
  (interactive
   (list
    (read-string "Go to URL: "
                 (thing-at-point-url-at-point)
                 t)))
  (with-window-restore
    (w3m-browse-url
     (if (s-starts-with? "http://" url)
         url
       (concat "http://" url)))
    (local-set-key (kbd "q") (command (restore)))))
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* message
Provides emailing and messaging functions.
#+begin_src emacs-lisp
(setq message-kill-buffer-on-exit t)
#+end_src
** Background message sending
Send messages in the background instead of blocking Emacs.
*** Define a hook to be run after sending messages in the background
#+begin_src emacs-lisp
(defvar async-smtpmail-sent-hook nil)
#+end_src
*** Use the =async= library to send messages in a background process
#+begin_src emacs-lisp
(defun async-smtpmail-send-it (&rest _)
  "Send mail asynchronously using another Emacs process."
  (let ((to (message-field-value "To")))
    (message "Delivering message to %s..." to)
    (async-start
     `(lambda ()
        (require 'smtpmail)
        (with-temp-buffer
          (insert ,(buffer-string))
          ;; Pass in the variable environment for smtpmail.
          (setq user-mail-address ,user-mail-address
                smtpmail-mail-address ,smtpmail-mail-address
                smtpmail-smtp-server ,smtpmail-smtp-server
                smtpmail-smtp-service ,smtpmail-smtp-service
                message-directory ,message-directory
                message-auto-save-directory ,message-auto-save-directory)

          (smtpmail-send-it)
          nil))
     `(lambda (&rest _)
        (message "Delivering message to %s...done" ,to)
        (run-hooks 'async-smtpmail-sent-hook)))))

(setq message-send-mail-function 'async-smtpmail-send-it
      send-mail-function 'async-smtpmail-send-it)
#+end_src
*** Play the sent mail sound on OS X
#+begin_src emacs-lisp
(when (equal system-type 'darwin)
  (hook-fn 'async-smtpmail-sent-hook
    (let ((snd "/Applications/Mail.app/Contents/Resources/Mail Sent.aiff"))
      (when (file-exists-p snd)
        (start-process "Mail sent" " mail sent" "afplay" snd)))))
#+end_src
** Add attachments with ido
*** Impl
#+begin_src emacs-lisp
(defun mail-add-attachment-ido (file)
  (interactive (list (ido-read-file-name "Attach file: " )))
  (mail-add-attachment file))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(after 'message
  (define-key message-mode-map (kbd "C-c C-a") 'mail-add-attachment-ido))
#+end_src
* notmuch
Provides mail indexing and search.
#+begin_src emacs-lisp
(cb:install-package 'notmuch)
#+end_src
** Use notmuch-maildir-fcc to add sent messages to the maildir Sent Messages dir
#+begin_src emacs-lisp
(require 'notmuch-maildir-fcc)
#+end_src
** Evil
Define evil-style navigation keys for notmuch.
#+begin_src emacs-lisp
(after '(notmuch evil)
  (define-keys notmuch-search-mode-map
    "j" 'next-line
    "k" 'previous-line
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up)

  (define-keys notmuch-show-mode-map
    "C-f" 'evil-scroll-page-down
    "C-b" 'evil-scroll-page-up)
  (evil-add-hjkl-bindings notmuch-show-mode-map))
#+end_src
* Winner-mode
Provides an undo history for window changes.
#+begin_src emacs-lisp
(winner-mode +1)
#+end_src
* transpose-frame
Provides commands to rotate buffers within frames.
** Define autoloads
#+begin_src emacs-lisp
(autoload 'transpose-frame "transpose-frame")
(autoload 'flip-frame "transpose-frame")
(autoload 'flop-frame "transpose-frame")
(autoload 'rotate-frame "transpose-frame")
(autoload 'rotate-frame-clockwise "transpose-frame")
(autoload 'rotate-frame-anticlockwise "transpose-frame")
#+end_src
** Add global key bindings
#+begin_src emacs-lisp
(bind-key "C-x t" 'transpose-frame)
(bind-key "s-t"   'transpose-frame)
(bind-key "C-x f" 'rotate-frame)
(bind-key "s-r"   'rotate-frame)
#+end_src
* Circe
Circe is an Emacs IRC client.
#+begin_src emacs-lisp
(cb:install-package 'circe)
#+end_src
** Enable flyspell for input in circe buffers
#+begin_src emacs-lisp
(setq lui-flyspell-p t)
#+end_src
** Detect long URLs and replace with a link using a paste service
#+begin_src emacs-lisp
(after 'circe (require 'lui-autopaste))
(add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
#+end_src
** Show time stamps in margin
#+begin_src emacs-lisp
(setq lui-time-stamp-position 'right-margin
      lui-time-stamp-format "%H:%M")

(put 'lui-mode 'right-margin-width 5)
#+end_src
** Define a command to show all circe buffers
#+begin_src emacs-lisp
(defun show-irc ()
  "Show all IRC buffers."
  (interactive)
  (with-window-restore
    ;; Start IRC.
    (unless (--first-buffer (derived-mode-p 'circe-server-mode))
      (call-interactively 'circe))
    ;; Select IRC buffers.
    (let ((bufs (->> (--filter-buffers (derived-mode-p 'circe-chat-mode
                                                       'circe-channel-mode))
                  (-sort (-on 'string< 'buffer-name)))))
      ;; Show all IRC buffers.
      (expose-buffers bufs)
      ;; Set up restore bindings.
      (--each bufs (buffer-local-set-key (kbd "C-c C-k") (command (restore)))))))
#+end_src
** Text formatting
*** Disable text filling
#+begin_src emacs-lisp
(setq lui-fill-type nil)
#+end_src
*** Configure text wrapping
#+begin_src emacs-lisp
(defun cbcirce:wrapping-setup ()
  (setq
   fringes-outside-margins t
   right-margin-width 5
   word-wrap t
   wrap-prefix "    "))

(add-hook 'lui-mode-hook 'cbcirce:wrapping-setup)
#+end_src
** Bots and lurkers
*** Define list of bots and lurkers
#+begin_src emacs-lisp
(setq circe-bot-list '("fsbot" "rudybot"))
#+end_src
*** Hide status messages by lurkers
#+begin_src emacs-lisp
(setq circe-reduce-lurker-spam t)
#+end_src
*** Dim messages from bots
#+begin_src emacs-lisp
(defun cbcirce:message-option-bot (nick &rest ignored)
  (when (member nick circe-bot-list)
    '((text-properties . (face circe-fool-face lui-do-not-track t)))))

(add-hook 'circe-message-option-functions 'cbcirce:message-option-bot)
#+end_src
** Customise circe faces
#+begin_src emacs-lisp
(after 'circe
  (set-face-foreground 'circe-server-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'circe-fool-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'lui-time-stamp-face
                       (face-foreground 'font-lock-comment-face))

  (set-face-foreground 'circe-my-message-face solarized-hl-orange)
  (set-face-foreground 'lui-button-face solarized-hl-yellow)
  (set-face-foreground 'circe-originator-face solarized-hl-violet)
  (set-face-foreground 'circe-highlight-nick-face solarized-hl-cyan))
#+end_src
** Customise prompt
*** Apply in hooks
#+begin_src emacs-lisp
(defun cbcirce:set-prompt ()
  (let ((prompt (propertize (format "%s: " (circe-server-nick))
                            'face circe-prompt-face)))
    (lui-set-prompt prompt)))

(add-hook 'circe-nickserv-authenticated-hook 'cbcirce:set-prompt)
(add-hook 'circe-server-connected-hook 'cbcirce:set-prompt)
(add-hook 'circe-channel-mode-hook 'cbcirce:set-prompt)
#+end_src
*** Customise prompt face
#+begin_src emacs-lisp
(after 'circe
  (set-face-foreground 'circe-prompt-face solarized-hl-orange)
  (set-face-background 'circe-prompt-face nil))
#+end_src
** Evil
Use evil insert state in Circe.
#+begin_src emacs-lisp
(after '(evil circe)
  (add-hook 'circe-server-mode-hook 'evil-insert-state)
  (add-hook 'circe-channel-mode-hook 'evil-insert-state)
  (add-hook 'circe-chat-mode-hook 'evil-insert-state))
#+end_src
** Smartparens
Fix delete key behaviour in circe message mode.
#+begin_src emacs-lisp
(defun cbcirce:del ()
  "Delete command for Circe buffers that works with smartparens."
  (interactive)
  (call-interactively
   (if (sp-get-sexp t) 'sp-backward-delete-char 'delete-backward-char)))

(after '(circe smartparens)
  (define-key circe-channel-mode-map (kbd "<backspace>") 'cbcirce:del))
#+end_src
* ledger
** ledger-mode
Provides support for ledger files.
#+begin_src emacs-lisp
(cb:install-package 'ledger-mode)
(add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
#+end_src

Use 2 spaces for indentation.
#+begin_src emacs-lisp
(setq ledger-post-account-alignment-column 2)
#+end_src

Use ido for completion.
#+begin_src emacs-lisp
(setq ledger-post-use-completion-engine :ido)
#+end_src
** Org
*** Add a command to the org picker to go to the ledger file
#+begin_src emacs-lisp
  (after 'config-orgmode
    (add-to-list 'org-action-picker-options
                 '("$" "Go to ledger" (lambda () (find-file ledger-file)))))
#+end_src
*** Define capture template for expenses
#+begin_src emacs-lisp
(after 'org-capture

  (defmacro cbledger:with-ledger-buffer (&rest body)
    "Execute BODY forms in a ledger buffer.
Use `ledger-buffer' if the current buffer is not in ledger-mode."
    (declare (indent 0))
    `(with-current-buffer ,(if (derived-mode-p 'ledger-mode)
                               (current-buffer)
                             (find-file-noselect ledger-file))
       ,@body))

  (defun cbledger:read-date ()
    (s-replace "-" "/" (car (s-split " " (org-read-date)))))

  (defun cbledger:read-payee ()
    (cbledger:with-ledger-buffer
      (ido-completing-read "Payee: " (ledger-payees-in-buffer))))

  (defun cbledger:read-clear-state ()
    (if (y-or-n-p "Transaction cleared? ") " * " " "))

  (defun cbledger:read-amount ()
    (format "$ %.2f" (read-number "Amount $: ")))

  (defun cbledger:accounts ()
    "Find all accounts in the current ledger buffer, or in the `ledger-file'."
    (cbledger:with-ledger-buffer
      (->> (s-match-strings-all
            (rx bol (+ space) (group (+ (not space)) ":" (+? nonl))
                (or eol "  "))
            (buffer-string))
        (-map 'cadr)
        (-concat '("Income" "Assets" "Liabilities" "Expenses"))
        (-uniq)
        (-sort 'string<))))

  (cl-defun cbledger:read-account (&optional (prompt "Account: ") initial-input)
    (ido-completing-read prompt (cbledger:accounts) nil nil initial-input))

  (defun cbledger:read-expense ()
    (let ((date (cbledger:read-date))
          (payee (cbledger:read-payee))
          (to-account (cbledger:read-account "To: " "Expenses:"))
          (amount (cbledger:read-amount))
          (from-account (cbledger:read-account "From: " "Assets:Checking"))
          (cleared? (cbledger:read-clear-state)))
      (concat date cleared? payee "\n"
              "  " to-account "  " amount "\n"
              "  " from-account)))

  (add-to-list 'org-capture-templates
               `("$" "Expense" plain (file ,ledger-file)
                 (function cbledger:read-expense)
                 :empty-lines 1
                 :clock-keep t
                 :jump-to-captured t
                 :immediate-finish t)))
#+end_src
** DEFER
#+begin_src emacs-lisp
(after 'ledger-mode
#+end_src
** Utilities for finding the bounds of transactions
#+begin_src emacs-lisp
(defvar cbledger:transaction-start (rx bol (any digit "~" "="))
  "Regex matching the start of a transaction line.")

(cl-defun ledger-transaction-at-pt (&optional (pt (point)))
  "Return the transaction at PT."
  (goto-char pt)
  (-when-let* ((beg (ledger-transaction-start-pos))
               (end (ledger-transaction-end-pos)))
    (buffer-substring-no-properties beg end)))

(cl-defun ledger-cur-transaction-date ()
  "Return the date for the transaction at point"
  (-when-let (trans (ledger-transaction-at-pt))
    (car (s-match ledger-full-date-regexp trans))))

(defun ledger-transaction-start-pos ()
  "Return the buffer position where the transaction at point begins."
  (save-excursion
    (if (s-matches? cbledger:transaction-start (current-line))
        (goto-char (line-beginning-position))
      (ignore-errors
        (ledger-prev-transaction)))))

(defun ledger-transaction-end-pos ()
  "Return the buffer position where the transaction at point ends."
  (save-excursion
    (or (ignore-errors (ledger-next-transaction))
        (goto-char (point-max)))

    (let (pos)
      (forward-line -1)
      (goto-char (line-end-position))
      (setq pos (point))
      (while (s-matches? (rx bol (* space) eol) (current-line))
        (forward-line -1)
        (goto-char (line-end-position))
        (setq pos (point)))
      pos)))
#+end_src
** Move by date
Define a command to move to transactions of a certain date.
*** Impl
#+begin_src emacs-lisp
(defun ledger-move-to-date (date)
  "Move to DATE in the ledger file."
  ;; Use slashes for consistency with ledger's date format.
  (interactive (list (s-replace "-" "/" (org-read-date))))
  (cl-destructuring-bind (y m d) (-map 'string-to-number (s-split "/" date))
    (ledger-xact-find-slot (encode-time 0 0 0 d m y))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-d") 'ledger-move-to-date)
#+end_src
** Buffer formatting
*** Define format buffer command
#+begin_src emacs-lisp
(defun ledger-format-buffer ()
  "Reformat the buffer."
  (interactive "*")
  (let ((pt (point)))
    (save-excursion
      (ledger-post-align-postings (point-min) (point-max))
      (ledger-sort-buffer)
      (message "Formatted buffer"))
    (goto-char pt)))
#+end_src
*** Automatically reformat the buffer on save
#+begin_src emacs-lisp
(hook-fn 'ledger-mode-hook
  (add-hook 'before-save-hook 'ledger-format-buffer nil t))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-q") 'ledger-format-buffer)
#+end_src
** Custom newline command
Define a custom newline command.
*** Impl
#+begin_src emacs-lisp
(defun ledger-ret ()
  "Newline and format."
  (interactive "*")
  (cond
   ((s-matches? (rx bol (* space) eol) (current-line))
    (delete-horizontal-space)
    (newline))
   (t
    (ledger-post-align-postings)
    (newline)
    (indent-to ledger-post-account-alignment-column))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "RET") 'ledger-ret)
#+end_src
** Movement by transactions
Define commands for moving by transactions.
*** Impl
#+begin_src emacs-lisp
(defun ledger-prev-transaction (&optional count)
  "Move backward to the start of the last transaction."
  (interactive)
  (goto-char (line-beginning-position))
  (cond
   ((bobp)
    (user-error "Beginning of buffer"))
   ((search-backward-regexp cbledger:transaction-start nil t count)
    (goto-char (line-beginning-position)))
   (t
    (goto-char (point-min)))))

(defun ledger-next-transaction (&optional count)
  "Move forward to the start of the next transaction."
  (interactive)
  (let ((start (point)))
    (goto-char (line-end-position))
    (if (search-forward-regexp cbledger:transaction-start nil t count)
        (goto-char (line-beginning-position))
      (goto-char start)
      (user-error "End of buffer"))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-P") 'ledger-prev-transaction)
(define-key ledger-mode-map (kbd "M-N") 'ledger-next-transaction)
#+end_src
** Deleting transactions
Define a command to kill the transaction at point.
*** Impl
#+begin_src emacs-lisp
(defun cbledger:delete-transaction-at-pt ()
  "Kill the current transaction.
Behaves correctly for transactions that are not separated by blank lines."
  (when (s-blank? (ledger-transaction-at-pt))
    (error "Not at a transaction"))
  (delete-region (ledger-transaction-start-pos)
                 (ledger-transaction-end-pos))
  (collapse-vertical-whitespace)
  (forward-line))

    (defun ledger-kill-transaction-at-pt ()
      "Kill the transaction at point and add it to the kill ring."
      (interactive "*")
      (-if-let (trans (ledger-transaction-at-pt))
          (progn
            (kill-new trans)
            (cbledger:delete-transaction-at-pt)
            (when (called-interactively-p nil)
              (message "Transaction copied to kill-ring"))
            trans)
        (user-error "Point is not at a transaction")))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-k") 'ledger-kill-transaction-at-pt)
#+end_src
** Transposing transactions
Define a command to transpose transactions around point.
#+begin_src emacs-lisp
(defun ledger-periodic-transaction? (str)
  "Non-nil if STR is a periodic transaction."
  (when str (s-starts-with? "~" str)))

(defun ledger-transpose-transactions ()
  "Swap the current transaction with the preceding one.
The transactions must have matching dates."
  (interactive "*")
  (let ((start (point)))
    (goto-char (ledger-transaction-start-pos))
    (let* ((trans (ledger-transaction-at-pt))
           (date (ledger-cur-transaction-date))
           (periodic? (ledger-periodic-transaction? trans)))
      (cond
       ((null trans)
        (goto-char start)
        (user-error "Point is not at a valid transaction"))

       ((and (null date) (not periodic?))
        (goto-char start)
        (error "Invalid date for current transaction"))

       ((save-excursion
          (ledger-prev-transaction)
          (equal periodic? (not (ledger-periodic-transaction?
                                 (ledger-transaction-at-pt)))))
        (goto-char start)
        (user-error "Incompatable transaction types"))

       ;; Inspect the preceding transaction to see whether we can transpose.
       ((save-excursion
          (ledger-prev-transaction)
          (equal date (ledger-cur-transaction-date)))

        (unwind-protect
            (atomic-change-group
              (ledger-kill-transaction-at-pt)
              (ledger-prev-transaction)
              (forward-line -1)
              (unless (bobp) (newline))
              (save-excursion
                (insert trans)
                (newline)
                (collapse-vertical-whitespace)))

          (pop kill-ring)))

       (t
        (goto-char start)
        (user-error "Transaction dates do not match"))))))
#+end_src
** Re-ordering transactions
Define commands to move transactions up or down.
*** Impl
#+begin_src emacs-lisp
(defun ledger-move-transaction-up ()
  "Move the current transaction up.
Signal an error of doing so would break date ordering."
  (interactive "*")
  (ledger-transpose-transactions))

(defun ledger-move-transaction-down ()
  "Move the current transaction down.
Signal an error of doing so would break date ordering."
  (interactive "*")
  (let ((pt (point)))
    (unwind-protect
        (progn
          (ledger-next-transaction)
          (ledger-transpose-transactions))
      (goto-char pt))
    (ledger-next-transaction)))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "M-<up>") 'ledger-move-transaction-up)
(define-key ledger-mode-map (kbd "M-<down>") 'ledger-move-transaction-down)
#+end_src
** Inserting timestamps
#+begin_src emacs-lisp
(defun cbledger:insert-timestamp (date)
  "Insert a timestamp at point."
  (interactive (list (org-read-date)))
  (insert (s-replace "-" "/" date))
  (just-one-space)
  (when (true? evil-mode)
    (evil-insert-state)))

(define-key ledger-mode-map (kbd "C-c C-.") 'cbledger:insert-timestamp)
#+end_src
** Key bindings
Define key bindings for stock ledger commands.
#+begin_src emacs-lisp
(define-key ledger-mode-map (kbd "C-c C-c") 'ledger-report)
(define-key ledger-mode-map (kbd "M-RET") 'ledger-toggle-current-transaction)
#+end_src
** Do not use flyspell in reports
#+begin_src emacs-lisp
(add-hook 'ledger-report-mode-hook 'flyspell-mode-off)
#+end_src
** Define custom reports
#+begin_src emacs-lisp
(--each
    '(("net worth" "ledger -f %(ledger-file) bal ^assets ^liabilities")
      ("cash flow" "ledger -f %(ledger-file) bal ^income ^expenses")
      ("checking" "ledger -f accounts.ledger --start-of-week friday -p 'this week' -r reg 'checking' --invert")
      )
  (add-to-list 'ledger-reports it t))
#+end_src
** Use ido for built-in reports
#+begin_src emacs-lisp
(cl-delete-if (C (~ equal "payee") car) ledger-report-format-specifiers)
(add-to-list 'ledger-report-format-specifiers '("payee" . cbledger:read-payee))

(cl-delete-if (C (~ equal "account") car) ledger-report-format-specifiers)
(add-to-list 'ledger-report-format-specifiers '("account" . cbledger:read-account))
#+end_src
** Fixes
Modify =ledger-report-payee-format-specifier= to prevent errors passing nil
string to regexp-quote.
#+begin_src emacs-lisp
(defun ledger-report-payee-format-specifier ()
  (let ((payee (ledger-xact-payee)))
    (ledger-read-string-with-default
     "Payee" (when payee (regexp-quote payee)))))
#+end_src
** Font lock
*** Customise existing ledegr faces
#+begin_src emacs-lisp
(set-face-background 'ledger-font-xact-highlight-face nil)
(set-face-foreground 'ledger-font-comment-face
                     (face-foreground 'font-lock-comment-face))
(set-face-foreground 'ledger-font-posting-account-face
                     (face-foreground 'default))

(set-face-foreground 'ledger-font-pending-face solarized-hl-orange)
(set-face-foreground 'ledger-font-payee-cleared-face solarized-hl-green)
(set-face-foreground 'ledger-font-payee-uncleared-face solarized-hl-orange)
#+end_src
*** Define faces for dates
#+begin_src emacs-lisp
(defface ledger-date
  `((t :inherit org-date :underline nil :foreground ,solarized-hl-cyan))
  "Face for dates at start of transactions."
  :group 'ledger-faces)

(defface ledger-periodic-header
  `((t :foreground ,solarized-hl-violet :bold t))
  "Face for the header for periodic transactions."
  :group 'ledger-faces)

(defface ledger-year-line
  `((t :foreground ,solarized-hl-violet))
  "Face for year declarations."
  :group 'ledger-faces)
#+end_src
*** Add font-locking for dates
#+begin_src emacs-lisp
(font-lock-add-keywords
 'ledger-mode
 `((,(rx bol (+ (any digit "=" "/"))) . 'ledger-date)
   (,(rx bol "~" (* nonl)) . 'ledger-periodic-header)
   (,(rx bol "year" (+ space) (+ digit) (* space) eol) . 'ledger-year-line)))
#+end_src
** Flycheck
Use flycheck-ledger.
#+begin_src emacs-lisp
(after 'flycheck
  (cb:install-package 'flycheck-ledger t))
#+end_src
** Hideshow
Add support for hideshow to ledger.
#+begin_src emacs-lisp
(defvar ledger--transaction-start-re (rx bol (any digit "~" "="))
  "Regex matching the start of a transaction line.")

(defun ledger--hs-forward (&optional n)
  "Forward motion command for ledger-mode's hideshow support.
Argument N is provided for compatibility and is not used."
  (forward-line 1)
  (or (when (search-forward-regexp ledger--transaction-start-re nil t)
        (forward-line -1)
        (goto-char (line-end-position))
        t)
      (goto-char (point-max))))

(eval-after-load 'hideshow
  '(add-to-list 'hs-special-modes-alist
                `(ledger-mode
                  ,ledger--transaction-start-re
                  nil
                  nil
                  ledger--hs-forward
                  nil)))

(add-hook 'ledger-mode-hook 'hs-minor-mode)
#+end_src
** Evil
*** Evil motions in ledger reports
#+begin_src emacs-lisp
(evil-define-key 'normal ledger-report-mode-map
  "e" 'ledger-report-edit
  "q" 'ledger-report-kill
  "r" 'ledger-report-redo
  "R" 'ledger-report-reverse-lines
  "s" 'ledger-report-save)
#+end_src
*** Enter insert state after inserting a new transaction
#+begin_src emacs-lisp
(add-hook 'ledger-transaction-inserted-hook 'evil-insert-state)
#+end_src
** END
#+begin_src emacs-lisp
)
#+end_src
* PDF utilities
Define commands to work with PDF files.
#+begin_src emacs-lisp
(require 'cb-file-picker-widget)

(defun pdf-combine ()
  "Concatenate the given PDF files."
  (interactive)
  (file-picker
   "*Select PDFs*"
   :on-accept
   (lambda (pdfs)
     (let ((dest (read-file-name "Destination: " "~/" nil nil ".pdf")))
       (when (zerop (pdf-combine-command dest pdfs))
         (kill-new dest)
         (message "PDF path copied to kill-ring."))))))

(defun pdf-combine-command (destination pdfs)
  "Concatenate the given PDF files and output to DESTINATION."
  (%-sh (format "pdftk %s cat output %s"
                (s-join " " (-map (C %-quote f-expand) pdfs))
                (%-quote (f-expand destination)))))

(cl-defun tiff->pdf (file)
  "Convert the tiff at FILE to PDF. "
  (let* ((dest (concat (f-no-ext file) ".pdf"))
         (cmd (concat "cupsfilter -i image/tiff " (%-quote file) " > " (%-quote dest))))
    (when (zerop (%-sh cmd))
      dest)))
#+end_src
* Scanning
** Single scans
Define a command to scan a single file to disk.
*** utilities
#+begin_src emacs-lisp
(defun cbscan:scan-to-file (colour-mode path)
  "Scan to PATH. Return nil if scanning failed, or PATH if succeeded."
  (when (zerop (%-sh (concat "scanimage"
                             " --mode=" colour-mode
                             " --format=tiff"
                             " > " path)))
    path))

(defun scan-file (colour-mode destination &optional async?)
  "Scan as a TIFF to a temp file, then export to PDF with CUPS.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION.

If ASYNC? is non-nil, the scan will be performed in the background."
  (save-window-excursion
    (let* ((tmpfile (make-temp-file "scan--" nil ".tiff"))
           (command (concat "scanimage"
                            " --mode=" colour-mode
                            " --format=tiff"
                            " > " tmpfile
                            " && cupsfilter -D -i image/tiff " tmpfile
                            " > " (%-quote (f-expand destination)))))
      (cond (async? (%-async command))
            ((zerop (%-sh command))
             destination)))))
#+end_src
*** impl
#+begin_src emacs-lisp
(defun scan (colour-mode destination)
  "Scan using the default scanner to a PDF file.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (scan-file colour-mode destination 'async)
  (kill-new destination)
  (message "Scan started. Destination path copied to kill-ring."))
#+end_src
** Batch scanning
#+begin_src emacs-lisp
(defun scan-batch-to-file (colour-mode destination)
  "Scan several files from the document feeder then export to a single PDF.
The args COLOUR-MODE and DESTINATION are the same as for `scan-file'."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (read-char-choice "Press <return> to start." (list ?\^M))
  (let (pdfs)
    ;; Scan PDFs in flatbed.
    (save-window-excursion
      (let ((tmpdir (make-temp-file "scan-" t)))

        ;; Scan with document feeder.
        (unless (zerop (%-sh (concat "scanimage"
                                     " --mode=" colour-mode
                                     " --format=tiff"
                                     " --batch=" (f-join tmpdir "scan--%d.tiff"))))
          (error "Scanning failed"))
        (let ((pdfs)))
        ;; Export files to PDFs.
        (unless (->> (f-files tmpdir)

                  (--map (%-sh "cupsfilter -D -i image/tiff" (%-quote it)
                               ">" (%-quote (concat it ".pdf"))))
                  (-all? 'zerop))
          (error "PDF export failed"))
        ;; Combine PDFs.
        (unless (zerop (pdf-combine-command destination (f-files tmpdir)))
          (error "PDF combination failed"))))

    (kill-new destination)
    (message "PDF path copied to kill-ring.")))
#+end_src
** Combined scanning
Define a function for scanning multiple docmunts and combining them to a single
PDF.
*** Utils
#+begin_src emacs-lisp
(defun cbscan:read-continue? ()
  "Prompt the user whether to continue scanning."
  (equal ?\^M (read-char-choice "Press <return> to scan or C-d to finish."
                                (list ?\^M ?\^D))))
#+end_src
*** Impl
#+begin_src emacs-lisp
(defun scan-then-combine (colour-mode destination)
  "Scan several documents on the flatbed, then combine to a single PDF.

COLOUR-MODE should be either \"colour\" or \"grayscale\".

The document will be created at DESTINATION."
  (interactive
   (list
    (ido-completing-read "Mode: " '("Colour" "Grayscale"))
    (read-file-name "Destination: " "~/" nil nil ".pdf")))

  (save-window-excursion
    (let ((tmpdir (make-temp-file "scan-" t))
          (n 1))
      ;; Scan PDFs in flatbed.
      (while (cbscan:read-continue?)
        (message "Scanning...")
        (if (cbscan:scan-to-file colour-mode (f-join tmpdir (format "%03i.tiff" n)))
            (cl-incf n)
          (or (y-or-n-p "Scan failed.  Try again? ")
              (error "Scanning failed"))))

      ;; Export files to PDFs.
      (let ((pdfs (-map 'tiff->pdf (f-files tmpdir))))
        (when (-any? 'null pdfs)
          (error "PDF export failed"))

        ;; Combine PDFs.
        (unless (zerop (pdf-combine-command destination pdfs))
          (error "PDF combination failed"))

        (f-delete tmpdir 'force)

        (when (called-interactively-p nil)
          (kill-new destination)
          (message "%s page(s) scanned. PDF path copied to kill-ring." (length pdfs)))

        destination))))
#+end_src
** Org
Define a command to scan and attach documents to the subtree at point.
#+begin_src emacs-lisp
(defun org-attach-from-scanner (colour-mode)
  "Scan a document and attach it to the current org heading.

- COLOUR-MODE is either \"colour\" or \"grayscale\"."
  (interactive (list (ido-completing-read "Mode: " '("Colour" "Grayscale"))))
  (let ((file (scan-then-combine colour-mode (make-temp-file "scan--" nil ".pdf"))))
    (org-attach-attach file nil 'mv))

  (message "Scanning...Done"))
#+end_src

** Command picker
Define a command picker for printer and scanner functions.
*** Impl
#+begin_src emacs-lisp
(define-command-picker printer-scanner-picker
  :title
  "*Print/Scan*"
  :options
  '(("p" "Print Buffer" print-buffer)
    ("r" "Print Region" print-region)
    ("s" "Scan (flatbed)" scan)
    ("m" "Scan Multiple & Combine (flatbed)" scan-then-combine)
    ("u" "Scan (document feeder)" scan-batch-to-file)
    ("a" "Scan and Attach (org)" org-attach-from-scanner
     :when (lambda () (derived-mode-p 'org-mode)))))
#+end_src
*** Key binding
#+begin_src emacs-lisp
(bind-key* "<f10>" 'printer-scanner-picker)
#+end_src

* Mutt
#+begin_src emacs-lisp
(cb:declare-package-installer muttrc
  :match "muttrc"
  :packages (muttrc-mode))
#+end_src
* Define functions for [[file:Makefile][Makefile]]
#+begin_src emacs-lisp
(defun byte-compile-conf ()
  "Recompile all configuration files."
  (interactive)
  (dolist (file (file-expand-wildcards (concat user-emacs-directory "*.el")))
    (byte-recompile-file file t))
  (when (boundp 'cb:lisp-dir)
    (byte-recompile-directory cb:lisp-dir 0 t)))
#+end_src
* Provide this file
#+begin_src emacs-lisp
(provide 'config-base)
#+end_src
