This is bison.info, produced by makeinfo version 4.8 from
/Users/chris/Downloads/bison.texi.

   This manual (23 October 2013) is for GNU Bison (version 3.0.2),
the GNU parser generator.

   Copyright (C) 1988-1993, 1995, 1998-2013 Free Software Foundation,
Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual," and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have the freedom to copy
     and modify this GNU manual.  Buying copies from the FSF supports
     it in developing GNU and promoting software freedom."

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* bison: (bison).       GNU parser generator (Yacc replacement).
END-INFO-DIR-ENTRY


File: bison.info,  Node: Reduce/Reduce,  Next: Mysterious Conflicts,  Prev: Parser States,  Up: Algorithm

5.6 Reduce/Reduce Conflicts
===========================

A reduce/reduce conflict occurs if there are two or more rules that
apply to the same sequence of input.  This usually indicates a
serious error in the grammar.

   For example, here is an erroneous attempt to define a sequence of
zero or more `word' groupings.

     sequence:
       %empty         { printf ("empty sequence\n"); }
     | maybeword
     | sequence word  { printf ("added word %s\n", $2); }
     ;

     maybeword:
       %empty    { printf ("empty maybeword\n"); }
     | word      { printf ("single word %s\n", $1); }
     ;

The error is an ambiguity: there is more than one way to parse a
single `word' into a `sequence'.  It could be reduced to a
`maybeword' and then into a `sequence' via the second rule.
Alternatively, nothing-at-all could be reduced into a `sequence' via
the first rule, and this could be combined with the `word' using the
third rule for `sequence'.

   There is also more than one way to reduce nothing-at-all into a
`sequence'.  This can be done directly via the first rule, or
indirectly via `maybeword' and then the second rule.

   You might think that this is a distinction without a difference,
because it does not change whether any particular input is valid or
not.  But it does affect which actions are run.  One parsing order
runs the second rule's action; the other runs the first rule's action
and the third rule's action.  In this example, the output of the
program changes.

   Bison resolves a reduce/reduce conflict by choosing to use the
rule that appears first in the grammar, but it is very risky to rely
on this.  Every reduce/reduce conflict must be studied and usually
eliminated.  Here is the proper way to define `sequence':

     sequence:
       %empty         { printf ("empty sequence\n"); }
     | sequence word  { printf ("added word %s\n", $2); }
     ;

   Here is another common error that yields a reduce/reduce conflict:

     sequence:
       %empty
     | sequence words
     | sequence redirects
     ;

     words:
       %empty
     | words word
     ;

     redirects:
       %empty
     | redirects redirect
     ;

The intention here is to define a sequence which can contain either
`word' or `redirect' groupings.  The individual definitions of
`sequence', `words' and `redirects' are error-free, but the three
together make a subtle ambiguity: even an empty input can be parsed
in infinitely many ways!

   Consider: nothing-at-all could be a `words'.  Or it could be two
`words' in a row, or three, or any number.  It could equally well be a
`redirects', or two, or any number.  Or it could be a `words'
followed by three `redirects' and another `words'.  And so on.

   Here are two ways to correct these rules.  First, to make it a
single level of sequence:

     sequence:
       %empty
     | sequence word
     | sequence redirect
     ;

   Second, to prevent either a `words' or a `redirects' from being
empty:

     sequence:
       %empty
     | sequence words
     | sequence redirects
     ;

     words:
       word
     | words word
     ;

     redirects:
       redirect
     | redirects redirect
     ;

   Yet this proposal introduces another kind of ambiguity!  The input
`word word' can be parsed as a single `words' composed of two
`word's, or as two one-`word' `words' (and likewise for
`redirect'/`redirects').  However this ambiguity is now a
shift/reduce conflict, and therefore it can now be addressed with
precedence directives.

   To simplify the matter, we will proceed with `word' and `redirect'
being tokens: `"word"' and `"redirect"'.

   To prefer the longest `words', the conflict between the token
`"word"' and the rule `sequence: sequence words' must be resolved as
a shift.  To this end, we use the same techniques as exposed above,
see *Note Using Precedence For Non Operators: Non Operators.  One
solution relies on precedences: use `%prec' to give a lower
precedence to the rule:

     %precedence "word"
     %precedence "sequence"
     %%
     sequence:
       %empty
     | sequence word      %prec "sequence"
     | sequence redirect  %prec "sequence"
     ;

     words:
       word
     | words "word"
     ;

   Another solution relies on associativity: provide both the token
and the rule with the same precedence, but make them
right-associative:

     %right "word" "redirect"
     %%
     sequence:
       %empty
     | sequence word      %prec "word"
     | sequence redirect  %prec "redirect"
     ;


File: bison.info,  Node: Mysterious Conflicts,  Next: Tuning LR,  Prev: Reduce/Reduce,  Up: Algorithm

5.7 Mysterious Conflicts
========================

Sometimes reduce/reduce conflicts can occur that don't look warranted.
Here is an example:

     %%
     def: param_spec return_spec ',';
     param_spec:
       type
     | name_list ':' type
     ;

     return_spec:
       type
     | name ':' type
     ;

     type: "id";

     name: "id";
     name_list:
       name
     | name ',' name_list
     ;

   It would seem that this grammar can be parsed with only a single
token of lookahead: when a `param_spec' is being read, an `"id"' is a
`name' if a comma or colon follows, or a `type' if another `"id"'
follows.  In other words, this grammar is LR(1).

   However, for historical reasons, Bison cannot by default handle all
LR(1) grammars.  In this grammar, two contexts, that after an `"id"'
at the beginning of a `param_spec' and likewise at the beginning of a
`return_spec', are similar enough that Bison assumes they are the
same.  They appear similar because the same set of rules would be
active--the rule for reducing to a `name' and that for reducing to a
`type'.  Bison is unable to determine at that stage of processing
that the rules would require different lookahead tokens in the two
contexts, so it makes a single parser state for them both.  Combining
the two contexts causes a conflict later.  In parser terminology, this
occurrence means that the grammar is not LALR(1).

   For many practical grammars (specifically those that fall into the
non-LR(1) class), the limitations of LALR(1) result in difficulties
beyond just mysterious reduce/reduce conflicts.  The best way to fix
all these problems is to select a different parser table construction
algorithm.  Either IELR(1) or canonical LR(1) would suffice, but the
former is more efficient and easier to debug during development.
*Note LR Table Construction::, for details.  (Bison's IELR(1) and
canonical LR(1) implementations are experimental.  More user feedback
will help to stabilize them.)

   If you instead wish to work around LALR(1)'s limitations, you can
often fix a mysterious conflict by identifying the two parser states
that are being confused, and adding something to make them look
distinct.  In the above example, adding one rule to `return_spec' as
follows makes the problem go away:

     ...
     return_spec:
       type
     | name ':' type
     | "id" "bogus"       /* This rule is never used.  */
     ;

   This corrects the problem because it introduces the possibility of
an additional active rule in the context after the `"id"' at the
beginning of `return_spec'.  This rule is not active in the
corresponding context in a `param_spec', so the two contexts receive
distinct parser states.  As long as the token `"bogus"' is never
generated by `yylex', the added rule cannot alter the way actual
input is parsed.

   In this particular example, there is another way to solve the
problem: rewrite the rule for `return_spec' to use `"id"' directly
instead of via `name'.  This also causes the two confusing contexts
to have different sets of active rules, because the one for
`return_spec' activates the altered rule for `return_spec' rather
than the one for `name'.

     param_spec:
       type
     | name_list ':' type
     ;

     return_spec:
       type
     | "id" ':' type
     ;

   For a more detailed exposition of LALR(1) parsers and parser
generators, *note DeRemer 1982: Bibliography.


File: bison.info,  Node: Tuning LR,  Next: Generalized LR Parsing,  Prev: Mysterious Conflicts,  Up: Algorithm

5.8 Tuning LR
=============

The default behavior of Bison's LR-based parsers is chosen mostly for
historical reasons, but that behavior is often not robust.  For
example, in the previous section, we discussed the mysterious
conflicts that can be produced by LALR(1), Bison's default parser
table construction algorithm.  Another example is Bison's `%define
parse.error verbose' directive, which instructs the generated parser
to produce verbose syntax error messages, which can sometimes contain
incorrect information.

   In this section, we explore several modern features of Bison that
allow you to tune fundamental aspects of the generated LR-based
parsers.  Some of these features easily eliminate shortcomings like
those mentioned above.  Others can be helpful purely for
understanding your parser.

   Most of the features discussed in this section are still
experimental.  More user feedback will help to stabilize them.

* Menu:

* LR Table Construction:: Choose a different construction algorithm.
* Default Reductions::    Disable default reductions.
* LAC::                   Correct lookahead sets in the parser states.
* Unreachable States::    Keep unreachable parser states for debugging.


File: bison.info,  Node: LR Table Construction,  Next: Default Reductions,  Up: Tuning LR

5.8.1 LR Table Construction
---------------------------

For historical reasons, Bison constructs LALR(1) parser tables by
default.  However, LALR does not possess the full
language-recognition power of LR.  As a result, the behavior of
parsers employing LALR parser tables is often mysterious.  We
presented a simple example of this effect in *Note Mysterious
Conflicts::.

   As we also demonstrated in that example, the traditional approach
to eliminating such mysterious behavior is to restructure the grammar.
Unfortunately, doing so correctly is often difficult.  Moreover,
merely discovering that LALR causes mysterious behavior in your
parser can be difficult as well.

   Fortunately, Bison provides an easy way to eliminate the
possibility of such mysterious behavior altogether.  You simply need
to activate a more powerful parser table construction algorithm by
using the `%define lr.type' directive.

 -- Directive: %define lr.type TYPE
     Specify the type of parser tables within the LR(1) family.  The
     accepted values for TYPE are:

        * `lalr' (default)

        * `ielr'

        * `canonical-lr'

     (This feature is experimental. More user feedback will help to
     stabilize it.)

   For example, to activate IELR, you might add the following
directive to you grammar file:

     %define lr.type ielr

For the example in *Note Mysterious Conflicts::, the mysterious
conflict is then eliminated, so there is no need to invest time in
comprehending the conflict or restructuring the grammar to fix it.
If, during future development, the grammar evolves such that all
mysterious behavior would have disappeared using just LALR, you need
not fear that continuing to use IELR will result in unnecessarily
large parser tables.  That is, IELR generates LALR tables when LALR
(using a deterministic parsing algorithm) is sufficient to support
the full language-recognition power of LR.  Thus, by enabling IELR at
the start of grammar development, you can safely and completely
eliminate the need to consider LALR's shortcomings.

   While IELR is almost always preferable, there are circumstances
where LALR or the canonical LR parser tables described by Knuth
(*note Knuth 1965: Bibliography.) can be useful.  Here we summarize
the relative advantages of each parser table construction algorithm
within Bison:

   * LALR

     There are at least two scenarios where LALR can be worthwhile:

        * GLR without static conflict resolution.

          When employing GLR parsers (*note GLR Parsers::), if you do
          not resolve any conflicts statically (for example, with
          `%left' or `%precedence'), then the parser explores all
          potential parses of any given input.  In this case, the
          choice of parser table construction algorithm is guaranteed
          not to alter the language accepted by the parser.  LALR
          parser tables are the smallest parser tables Bison can
          currently construct, so they may then be preferable.
          Nevertheless, once you begin to resolve conflicts
          statically, GLR behaves more like a deterministic parser in
          the syntactic contexts where those conflicts appear, and so
          either IELR or canonical LR can then be helpful to avoid
          LALR's mysterious behavior.

        * Malformed grammars.

          Occasionally during development, an especially malformed
          grammar with a major recurring flaw may severely impede the
          IELR or canonical LR parser table construction algorithm.
          LALR can be a quick way to construct parser tables in order
          to investigate such problems while ignoring the more subtle
          differences from IELR and canonical LR.

   * IELR

     IELR (Inadequacy Elimination LR) is a minimal LR algorithm.
     That is, given any grammar (LR or non-LR), parsers using IELR or
     canonical LR parser tables always accept exactly the same set of
     sentences.  However, like LALR, IELR merges parser states during
     parser table construction so that the number of parser states is
     often an order of magnitude less than for canonical LR.  More
     importantly, because canonical LR's extra parser states may
     contain duplicate conflicts in the case of non-LR grammars, the
     number of conflicts for IELR is often an order of magnitude less
     as well.  This effect can significantly reduce the complexity of
     developing a grammar.

   * Canonical LR

     While inefficient, canonical LR parser tables can be an
     interesting means to explore a grammar because they possess a
     property that IELR and LALR tables do not.  That is, if
     `%nonassoc' is not used and default reductions are left disabled
     (*note Default Reductions::), then, for every left context of
     every canonical LR state, the set of tokens accepted by that
     state is guaranteed to be the exact set of tokens that is
     syntactically acceptable in that left context.  It might then
     seem that an advantage of canonical LR parsers in production is
     that, under the above constraints, they are guaranteed to detect
     a syntax error as soon as possible without performing any
     unnecessary reductions.  However, IELR parsers that use LAC are
     also able to achieve this behavior without sacrificing
     `%nonassoc' or default reductions.  For details and a few
     caveats of LAC, *note LAC::.

   For a more detailed exposition of the mysterious behavior in LALR
parsers and the benefits of IELR, *note Denny 2008 March:
Bibliography, and *Note Denny 2010 November: Bibliography.


File: bison.info,  Node: Default Reductions,  Next: LAC,  Prev: LR Table Construction,  Up: Tuning LR

5.8.2 Default Reductions
------------------------

After parser table construction, Bison identifies the reduction with
the largest lookahead set in each parser state.  To reduce the size
of the parser state, traditional Bison behavior is to remove that
lookahead set and to assign that reduction to be the default parser
action.  Such a reduction is known as a "default reduction".

   Default reductions affect more than the size of the parser tables.
They also affect the behavior of the parser:

   * Delayed `yylex' invocations.

     A "consistent state" is a state that has only one possible parser
     action.  If that action is a reduction and is encoded as a
     default reduction, then that consistent state is called a
     "defaulted state".  Upon reaching a defaulted state, a
     Bison-generated parser does not bother to invoke `yylex' to
     fetch the next token before performing the reduction.  In other
     words, whether default reductions are enabled in consistent
     states determines how soon a Bison-generated parser invokes
     `yylex' for a token: immediately when it _reaches_ that token in
     the input or when it eventually _needs_ that token as a
     lookahead to determine the next parser action.  Traditionally,
     default reductions are enabled, and so the parser exhibits the
     latter behavior.

     The presence of defaulted states is an important consideration
     when designing `yylex' and the grammar file.  That is, if the
     behavior of `yylex' can influence or be influenced by the
     semantic actions associated with the reductions in defaulted
     states, then the delay of the next `yylex' invocation until
     after those reductions is significant.  For example, the
     semantic actions might pop a scope stack that `yylex' uses to
     determine what token to return.  Thus, the delay might be
     necessary to ensure that `yylex' does not look up the next token
     in a scope that should already be considered closed.

   * Delayed syntax error detection.

     When the parser fetches a new token by invoking `yylex', it
     checks whether there is an action for that token in the current
     parser state.  The parser detects a syntax error if and only if
     either (1) there is no action for that token or (2) the action
     for that token is the error action (due to the use of
     `%nonassoc').  However, if there is a default reduction in that
     state (which might or might not be a defaulted state), then it is
     impossible for condition 1 to exist.  That is, all tokens have
     an action.  Thus, the parser sometimes fails to detect the
     syntax error until it reaches a later state.

     While default reductions never cause the parser to accept
     syntactically incorrect sentences, the delay of syntax error
     detection can have unexpected effects on the behavior of the
     parser.  However, the delay can be caused anyway by parser state
     merging and the use of `%nonassoc', and it can be fixed by
     another Bison feature, LAC.  We discuss the effects of delayed
     syntax error detection and LAC more in the next section (*note
     LAC::).

   For canonical LR, the only default reduction that Bison enables by
default is the accept action, which appears only in the accepting
state, which has no other action and is thus a defaulted state.
However, the default accept action does not delay any `yylex'
invocation or syntax error detection because the accept action ends
the parse.

   For LALR and IELR, Bison enables default reductions in nearly all
states by default.  There are only two exceptions.  First, states
that have a shift action on the `error' token do not have default
reductions because delayed syntax error detection could then prevent
the `error' token from ever being shifted in that state.  However,
parser state merging can cause the same effect anyway, and LAC fixes
it in both cases, so future versions of Bison might drop this
exception when LAC is activated.  Second, GLR parsers do not record
the default reduction as the action on a lookahead token for which
there is a conflict.  The correct action in this case is to split the
parse instead.

   To adjust which states have default reductions enabled, use the
`%define lr.default-reduction' directive.

 -- Directive: %define lr.default-reduction WHERE
     Specify the kind of states that are permitted to contain default
     reductions.  The accepted values of WHERE are:
        * `most' (default for LALR and IELR)

        * `consistent'

        * `accepting' (default for canonical LR)

     (The ability to specify where default reductions are permitted is
     experimental.  More user feedback will help to stabilize it.)


File: bison.info,  Node: LAC,  Next: Unreachable States,  Prev: Default Reductions,  Up: Tuning LR

5.8.3 LAC
---------

Canonical LR, IELR, and LALR can suffer from a couple of problems upon
encountering a syntax error.  First, the parser might perform
additional parser stack reductions before discovering the syntax
error.  Such reductions can perform user semantic actions that are
unexpected because they are based on an invalid token, and they cause
error recovery to begin in a different syntactic context than the one
in which the invalid token was encountered.  Second, when verbose
error messages are enabled (*note Error Reporting::), the expected
token list in the syntax error message can both contain invalid
tokens and omit valid tokens.

   The culprits for the above problems are `%nonassoc', default
reductions in inconsistent states (*note Default Reductions::), and
parser state merging.  Because IELR and LALR merge parser states,
they suffer the most.  Canonical LR can suffer only if `%nonassoc' is
used or if default reductions are enabled for inconsistent states.

   LAC (Lookahead Correction) is a new mechanism within the parsing
algorithm that solves these problems for canonical LR, IELR, and LALR
without sacrificing `%nonassoc', default reductions, or state
merging.  You can enable LAC with the `%define parse.lac' directive.

 -- Directive: %define parse.lac VALUE
     Enable LAC to improve syntax error handling.
        * `none' (default)

        * `full'
     (This feature is experimental.  More user feedback will help to
     stabilize it.  Moreover, it is currently only available for
     deterministic parsers in C.)

   Conceptually, the LAC mechanism is straight-forward.  Whenever the
parser fetches a new token from the scanner so that it can determine
the next parser action, it immediately suspends normal parsing and
performs an exploratory parse using a temporary copy of the normal
parser state stack.  During this exploratory parse, the parser does
not perform user semantic actions.  If the exploratory parse reaches
a shift action, normal parsing then resumes on the normal parser
stacks.  If the exploratory parse reaches an error instead, the
parser reports a syntax error.  If verbose syntax error messages are
enabled, the parser must then discover the list of expected tokens,
so it performs a separate exploratory parse for each token in the
grammar.

   There is one subtlety about the use of LAC.  That is, when in a
consistent parser state with a default reduction, the parser will not
attempt to fetch a token from the scanner because no lookahead is
needed to determine the next parser action.  Thus, whether default
reductions are enabled in consistent states (*note Default
Reductions::) affects how soon the parser detects a syntax error:
immediately when it _reaches_ an erroneous token or when it
eventually _needs_ that token as a lookahead to determine the next
parser action.  The latter behavior is probably more intuitive, so
Bison currently provides no way to achieve the former behavior while
default reductions are enabled in consistent states.

   Thus, when LAC is in use, for some fixed decision of whether to
enable default reductions in consistent states, canonical LR and IELR
behave almost exactly the same for both syntactically acceptable and
syntactically unacceptable input.  While LALR still does not support
the full language-recognition power of canonical LR and IELR, LAC at
least enables LALR's syntax error handling to correctly reflect LALR's
language-recognition power.

   There are a few caveats to consider when using LAC:

   * Infinite parsing loops.

     IELR plus LAC does have one shortcoming relative to canonical
     LR.  Some parsers generated by Bison can loop infinitely.  LAC
     does not fix infinite parsing loops that occur between
     encountering a syntax error and detecting it, but enabling
     canonical LR or disabling default reductions sometimes does.

   * Verbose error message limitations.

     Because of internationalization considerations, Bison-generated
     parsers limit the size of the expected token list they are
     willing to report in a verbose syntax error message.  If the
     number of expected tokens exceeds that limit, the list is simply
     dropped from the message.  Enabling LAC can increase the size of
     the list and thus cause the parser to drop it.  Of course,
     dropping the list is better than reporting an incorrect list.

   * Performance.

     Because LAC requires many parse actions to be performed twice,
     it can have a performance penalty.  However, not all parse
     actions must be performed twice.  Specifically, during a series
     of default reductions in consistent states and shift actions,
     the parser never has to initiate an exploratory parse.
     Moreover, the most time-consuming tasks in a parse are often the
     file I/O, the lexical analysis performed by the scanner, and the
     user's semantic actions, but none of these are performed during
     the exploratory parse.  Finally, the base of the temporary stack
     used during an exploratory parse is a pointer into the normal
     parser state stack so that the stack is never physically copied.
     In our experience, the performance penalty of LAC has proved
     insignificant for practical grammars.

   While the LAC algorithm shares techniques that have been
recognized in the parser community for years, for the publication
that introduces LAC, *note Denny 2010 May: Bibliography.


File: bison.info,  Node: Unreachable States,  Prev: LAC,  Up: Tuning LR

5.8.4 Unreachable States
------------------------

If there exists no sequence of transitions from the parser's start
state to some state S, then Bison considers S to be an "unreachable
state".  A state can become unreachable during conflict resolution if
Bison disables a shift action leading to it from a predecessor state.

   By default, Bison removes unreachable states from the parser after
conflict resolution because they are useless in the generated parser.
However, keeping unreachable states is sometimes useful when trying
to understand the relationship between the parser and the grammar.

 -- Directive: %define lr.keep-unreachable-state VALUE
     Request that Bison allow unreachable states to remain in the
     parser tables.  VALUE must be a Boolean.  The default is `false'.

   There are a few caveats to consider:

   * Missing or extraneous warnings.

     Unreachable states may contain conflicts and may use rules not
     used in any other state.  Thus, keeping unreachable states may
     induce warnings that are irrelevant to your parser's behavior,
     and it may eliminate warnings that are relevant.  Of course, the
     change in warnings may actually be relevant to a parser table
     analysis that wants to keep unreachable states, so this behavior
     will likely remain in future Bison releases.

   * Other useless states.

     While Bison is able to remove unreachable states, it is not
     guaranteed to remove other kinds of useless states.
     Specifically, when Bison disables reduce actions during conflict
     resolution, some goto actions may become useless, and thus some
     additional states may become useless.  If Bison were to compute
     which goto actions were useless and then disable those actions,
     it could identify such states as unreachable and then remove
     those states.  However, Bison does not compute which goto
     actions are useless.


File: bison.info,  Node: Generalized LR Parsing,  Next: Memory Management,  Prev: Tuning LR,  Up: Algorithm

5.9 Generalized LR (GLR) Parsing
================================

Bison produces _deterministic_ parsers that choose uniquely when to
reduce and which reduction to apply based on a summary of the
preceding input and on one extra token of lookahead.  As a result,
normal Bison handles a proper subset of the family of context-free
languages.  Ambiguous grammars, since they have strings with more
than one possible sequence of reductions cannot have deterministic
parsers in this sense.  The same is true of languages that require
more than one symbol of lookahead, since the parser lacks the
information necessary to make a decision at the point it must be made
in a shift-reduce parser.  Finally, as previously mentioned (*note
Mysterious Conflicts::), there are languages where Bison's default
choice of how to summarize the input seen so far loses necessary
information.

   When you use the `%glr-parser' declaration in your grammar file,
Bison generates a parser that uses a different algorithm, called
Generalized LR (or GLR).  A Bison GLR parser uses the same basic
algorithm for parsing as an ordinary Bison parser, but behaves
differently in cases where there is a shift-reduce conflict that has
not been resolved by precedence rules (*note Precedence::) or a
reduce-reduce conflict.  When a GLR parser encounters such a
situation, it effectively _splits_ into a several parsers, one for
each possible shift or reduction.  These parsers then proceed as
usual, consuming tokens in lock-step.  Some of the stacks may
encounter other conflicts and split further, with the result that
instead of a sequence of states, a Bison GLR parsing stack is what is
in effect a tree of states.

   In effect, each stack represents a guess as to what the proper
parse is.  Additional input may indicate that a guess was wrong, in
which case the appropriate stack silently disappears.  Otherwise, the
semantics actions generated in each stack are saved, rather than
being executed immediately.  When a stack disappears, its saved
semantic actions never get executed.  When a reduction causes two
stacks to become equivalent, their sets of semantic actions are both
saved with the state that results from the reduction.  We say that
two stacks are equivalent when they both represent the same sequence
of states, and each pair of corresponding states represents a grammar
symbol that produces the same segment of the input token stream.

   Whenever the parser makes a transition from having multiple states
to having one, it reverts to the normal deterministic parsing
algorithm, after resolving and executing the saved-up actions.  At
this transition, some of the states on the stack will have semantic
values that are sets (actually multisets) of possible actions.  The
parser tries to pick one of the actions by first finding one whose
rule has the highest dynamic precedence, as set by the `%dprec'
declaration.  Otherwise, if the alternative actions are not ordered by
precedence, but there the same merging function is declared for both
rules by the `%merge' declaration, Bison resolves and evaluates both
and then calls the merge function on the result.  Otherwise, it
reports an ambiguity.

   It is possible to use a data structure for the GLR parsing tree
that permits the processing of any LR(1) grammar in linear time (in
the size of the input), any unambiguous (not necessarily LR(1))
grammar in quadratic worst-case time, and any general (possibly
ambiguous) context-free grammar in cubic worst-case time.  However,
Bison currently uses a simpler data structure that requires time
proportional to the length of the input times the maximum number of
stacks required for any prefix of the input.  Thus, really ambiguous
or nondeterministic grammars can require exponential time and space
to process.  Such badly behaving examples, however, are not generally
of practical interest.  Usually, nondeterminism in a grammar is
local--the parser is "in doubt" only for a few tokens at a time.
Therefore, the current data structure should generally be adequate.
On LR(1) portions of a grammar, in particular, it is only slightly
slower than with the deterministic LR(1) Bison parser.

   For a more detailed exposition of GLR parsers, *note Scott 2000:
Bibliography.


File: bison.info,  Node: Memory Management,  Prev: Generalized LR Parsing,  Up: Algorithm

5.10 Memory Management, and How to Avoid Memory Exhaustion
==========================================================

The Bison parser stack can run out of memory if too many tokens are
shifted and not reduced.  When this happens, the parser function
`yyparse' calls `yyerror' and then returns 2.

   Because Bison parsers have growing stacks, hitting the upper limit
usually results from using a right recursion instead of a left
recursion, see *Note Recursive Rules: Recursion.

   By defining the macro `YYMAXDEPTH', you can control how deep the
parser stack can become before memory is exhausted.  Define the macro
with a value that is an integer.  This value is the maximum number of
tokens that can be shifted (and not reduced) before overflow.

   The stack space allowed is not necessarily allocated.  If you
specify a large value for `YYMAXDEPTH', the parser normally allocates
a small stack at first, and then makes it bigger by stages as needed.
This increasing allocation happens automatically and silently.
Therefore, you do not need to make `YYMAXDEPTH' painfully small
merely to save space for ordinary inputs that do not need much stack.

   However, do not allow `YYMAXDEPTH' to be a value so large that
arithmetic overflow could occur when calculating the size of the stack
space.  Also, do not allow `YYMAXDEPTH' to be less than `YYINITDEPTH'.

   The default value of `YYMAXDEPTH', if you do not define it, is
10000.

   You can control how much stack is allocated initially by defining
the macro `YYINITDEPTH' to a positive integer.  For the deterministic
parser in C, this value must be a compile-time constant unless you
are assuming C99 or some other target language or compiler that
allows variable-length arrays.  The default is 200.

   Do not allow `YYINITDEPTH' to be greater than `YYMAXDEPTH'.

   You can generate a deterministic parser containing C++ user code
from the default (C) skeleton, as well as from the C++ skeleton
(*note C++ Parsers::).  However, if you do use the default skeleton
and want to allow the parsing stack to grow, be careful not to use
semantic types or location types that require non-trivial copy
constructors.  The C skeleton bypasses these constructors when
copying data to new, larger stacks.


File: bison.info,  Node: Error Recovery,  Next: Context Dependency,  Prev: Algorithm,  Up: Top

6 Error Recovery
****************

It is not usually acceptable to have a program terminate on a syntax
error.  For example, a compiler should recover sufficiently to parse
the rest of the input file and check it for errors; a calculator
should accept another expression.

   In a simple interactive command parser where each input is one
line, it may be sufficient to allow `yyparse' to return 1 on error
and have the caller ignore the rest of the input line when that
happens (and then call `yyparse' again).  But this is inadequate for
a compiler, because it forgets all the syntactic context leading up
to the error.  A syntax error deep within a function in the compiler
input should not cause the compiler to treat the following line like
the beginning of a source file.

   You can define how to recover from a syntax error by writing rules
to recognize the special token `error'.  This is a terminal symbol
that is always defined (you need not declare it) and reserved for
error handling.  The Bison parser generates an `error' token whenever
a syntax error happens; if you have provided a rule to recognize this
token in the current context, the parse can continue.

   For example:

     stmts:
       %empty
     | stmts '\n'
     | stmts exp '\n'
     | stmts error '\n'

   The fourth rule in this example says that an error followed by a
newline makes a valid addition to any `stmts'.

   What happens if a syntax error occurs in the middle of an `exp'?
The error recovery rule, interpreted strictly, applies to the precise
sequence of a `stmts', an `error' and a newline.  If an error occurs
in the middle of an `exp', there will probably be some additional
tokens and subexpressions on the stack after the last `stmts', and
there will be tokens to read before the next newline.  So the rule is
not applicable in the ordinary way.

   But Bison can force the situation to fit the rule, by discarding
part of the semantic context and part of the input.  First it
discards states and objects from the stack until it gets back to a
state in which the `error' token is acceptable.  (This means that the
subexpressions already parsed are discarded, back to the last
complete `stmts'.)  At this point the `error' token can be shifted.
Then, if the old lookahead token is not acceptable to be shifted
next, the parser reads tokens and discards them until it finds a
token which is acceptable.  In this example, Bison reads and discards
input until the next newline so that the fourth rule can apply.  Note
that discarded symbols are possible sources of memory leaks, see
*Note Freeing Discarded Symbols: Destructor Decl, for a means to
reclaim this memory.

   The choice of error rules in the grammar is a choice of strategies
for error recovery.  A simple and useful strategy is simply to skip
the rest of the current input line or current statement if an error
is detected:

     stmt: error ';'  /* On error, skip until ';' is read.  */

   It is also useful to recover to the matching close-delimiter of an
opening-delimiter that has already been parsed.  Otherwise the
close-delimiter will probably appear to be unmatched, and generate
another, spurious error message:

     primary:
       '(' expr ')'
     | '(' error ')'
     ...
     ;

   Error recovery strategies are necessarily guesses.  When they
guess wrong, one syntax error often leads to another.  In the above
example, the error recovery rule guesses that an error is due to bad
input within one `stmt'.  Suppose that instead a spurious semicolon
is inserted in the middle of a valid `stmt'.  After the error
recovery rule recovers from the first error, another syntax error
will be found straightaway, since the text following the spurious
semicolon is also an invalid `stmt'.

   To prevent an outpouring of error messages, the parser will output
no error message for another syntax error that happens shortly after
the first; only after three consecutive input tokens have been
successfully shifted will error messages resume.

   Note that rules which accept the `error' token may have actions,
just as any other rules can.

   You can make error messages resume immediately by using the macro
`yyerrok' in an action.  If you do this in the error rule's action, no
error messages will be suppressed.  This macro requires no arguments;
`yyerrok;' is a valid C statement.

   The previous lookahead token is reanalyzed immediately after an
error.  If this is unacceptable, then the macro `yyclearin' may be
used to clear this token.  Write the statement `yyclearin;' in the
error rule's action.  *Note Special Features for Use in Actions:
Action Features.

   For example, suppose that on a syntax error, an error handling
routine is called that advances the input stream to some point where
parsing should once again commence.  The next symbol returned by the
lexical scanner is probably correct.  The previous lookahead token
ought to be discarded with `yyclearin;'.

   The expression `YYRECOVERING ()' yields 1 when the parser is
recovering from a syntax error, and 0 otherwise.  Syntax error
diagnostics are suppressed while recovering from a syntax error.


File: bison.info,  Node: Context Dependency,  Next: Debugging,  Prev: Error Recovery,  Up: Top

7 Handling Context Dependencies
*******************************

The Bison paradigm is to parse tokens first, then group them into
larger syntactic units.  In many languages, the meaning of a token is
affected by its context.  Although this violates the Bison paradigm,
certain techniques (known as "kludges") may enable you to write Bison
parsers for such languages.

* Menu:

* Semantic Tokens::   Token parsing can depend on the semantic context.
* Lexical Tie-ins::   Token parsing can depend on the syntactic context.
* Tie-in Recovery::   Lexical tie-ins have implications for how
                        error recovery rules must be written.

   (Actually, "kludge" means any technique that gets its job done but
is neither clean nor robust.)


File: bison.info,  Node: Semantic Tokens,  Next: Lexical Tie-ins,  Up: Context Dependency

7.1 Semantic Info in Token Types
================================

The C language has a context dependency: the way an identifier is used
depends on what its current meaning is.  For example, consider this:

     foo (x);

   This looks like a function call statement, but if `foo' is a
typedef name, then this is actually a declaration of `x'.  How can a
Bison parser for C decide how to parse this input?

   The method used in GNU C is to have two different token types,
`IDENTIFIER' and `TYPENAME'.  When `yylex' finds an identifier, it
looks up the current declaration of the identifier in order to decide
which token type to return: `TYPENAME' if the identifier is declared
as a typedef, `IDENTIFIER' otherwise.

   The grammar rules can then express the context dependency by the
choice of token type to recognize.  `IDENTIFIER' is accepted as an
expression, but `TYPENAME' is not.  `TYPENAME' can start a
declaration, but `IDENTIFIER' cannot.  In contexts where the meaning
of the identifier is _not_ significant, such as in declarations that
can shadow a typedef name, either `TYPENAME' or `IDENTIFIER' is
accepted--there is one rule for each of the two token types.

   This technique is simple to use if the decision of which kinds of
identifiers to allow is made at a place close to where the identifier
is parsed.  But in C this is not always so: C allows a declaration to
redeclare a typedef name provided an explicit type has been specified
earlier:

     typedef int foo, bar;
     int baz (void)
     {
       static bar (bar);      /* redeclare `bar' as static variable */
       extern foo foo (foo);  /* redeclare `foo' as function */
       return foo (bar);
     }

   Unfortunately, the name being declared is separated from the
declaration construct itself by a complicated syntactic
structure--the "declarator".

   As a result, part of the Bison parser for C needs to be
duplicated, with all the nonterminal names changed: once for parsing
a declaration in which a typedef name can be redefined, and once for
parsing a declaration in which that can't be done.  Here is a part of
the duplication, with actions omitted for brevity:

     initdcl:
       declarator maybeasm '=' init
     | declarator maybeasm
     ;

     notype_initdcl:
       notype_declarator maybeasm '=' init
     | notype_declarator maybeasm
     ;

Here `initdcl' can redeclare a typedef name, but `notype_initdcl'
cannot.  The distinction between `declarator' and `notype_declarator'
is the same sort of thing.

   There is some similarity between this technique and a lexical
tie-in (described next), in that information which alters the lexical
analysis is changed during parsing by other parts of the program.
The difference is here the information is global, and is used for
other purposes in the program.  A true lexical tie-in has a
special-purpose flag controlled by the syntactic context.


File: bison.info,  Node: Lexical Tie-ins,  Next: Tie-in Recovery,  Prev: Semantic Tokens,  Up: Context Dependency

7.2 Lexical Tie-ins
===================

One way to handle context-dependency is the "lexical tie-in": a flag
which is set by Bison actions, whose purpose is to alter the way
tokens are parsed.

   For example, suppose we have a language vaguely like C, but with a
special construct `hex (HEX-EXPR)'.  After the keyword `hex' comes an
expression in parentheses in which all integers are hexadecimal.  In
particular, the token `a1b' must be treated as an integer rather than
as an identifier if it appears in that context.  Here is how you can
do it:

     %{
       int hexflag;
       int yylex (void);
       void yyerror (char const *);
     %}
     %%
     ...
     expr:
       IDENTIFIER
     | constant
     | HEX '('        { hexflag = 1; }
         expr ')'     { hexflag = 0; $$ = $4; }
     | expr '+' expr  { $$ = make_sum ($1, $3); }
     ...
     ;

     constant:
       INTEGER
     | STRING
     ;

Here we assume that `yylex' looks at the value of `hexflag'; when it
is nonzero, all integers are parsed in hexadecimal, and tokens
starting with letters are parsed as integers if possible.

   The declaration of `hexflag' shown in the prologue of the grammar
file is needed to make it accessible to the actions (*note The
Prologue: Prologue.).  You must also write the code in `yylex' to obey
the flag.


File: bison.info,  Node: Tie-in Recovery,  Prev: Lexical Tie-ins,  Up: Context Dependency

7.3 Lexical Tie-ins and Error Recovery
======================================

Lexical tie-ins make strict demands on any error recovery rules you
have.  *Note Error Recovery::.

   The reason for this is that the purpose of an error recovery rule
is to abort the parsing of one construct and resume in some larger
construct.  For example, in C-like languages, a typical error
recovery rule is to skip tokens until the next semicolon, and then
start a new statement, like this:

     stmt:
       expr ';'
     | IF '(' expr ')' stmt { ... }
     ...
     | error ';'  { hexflag = 0; }
     ;

   If there is a syntax error in the middle of a `hex (EXPR)'
construct, this error rule will apply, and then the action for the
completed `hex (EXPR)' will never run.  So `hexflag' would remain set
for the entire rest of the input, or until the next `hex' keyword,
causing identifiers to be misinterpreted as integers.

   To avoid this problem the error recovery rule itself clears
`hexflag'.

   There may also be an error recovery rule that works within
expressions.  For example, there could be a rule which applies within
parentheses and skips to the close-parenthesis:

     expr:
       ...
     | '(' expr ')'   { $$ = $2; }
     | '(' error ')'
     ...

   If this rule acts within the `hex' construct, it is not going to
abort that construct (since it applies to an inner level of
parentheses within the construct).  Therefore, it should not clear
the flag: the rest of the `hex' construct should be parsed with the
flag still in effect.

   What if there is an error recovery rule which might abort out of
the `hex' construct or might not, depending on circumstances?  There
is no way you can write the action to determine whether a `hex'
construct is being aborted or not.  So if you are using a lexical
tie-in, you had better make sure your error recovery rules are not of
this kind.  Each rule must be such that you can be sure that it
always will, or always won't, have to clear the flag.


File: bison.info,  Node: Debugging,  Next: Invocation,  Prev: Context Dependency,  Up: Top

8 Debugging Your Parser
***********************

Developing a parser can be a challenge, especially if you don't
understand the algorithm (*note The Bison Parser Algorithm:
Algorithm.).  This chapter explains how understand and debug a parser.

   The first sections focus on the static part of the parser: its
structure.  They explain how to generate and read the detailed
description of the automaton.  There are several formats available:
   - as text, see *Note Understanding Your Parser: Understanding.;

   - as a graph, see *Note Visualizing Your Parser: Graphviz.;

   - or as a markup report that can be turned, for instance, into
     HTML, see *Note Visualizing your parser in multiple formats: Xml.

   The last section focuses on the dynamic part of the parser: how to
enable and understand the parser run-time traces (*note Tracing Your
Parser: Tracing.).

* Menu:

* Understanding::     Understanding the structure of your parser.
* Graphviz::          Getting a visual representation of the parser.
* Xml::               Getting a markup representation of the parser.
* Tracing::           Tracing the execution of your parser.


File: bison.info,  Node: Understanding,  Next: Graphviz,  Up: Debugging

8.1 Understanding Your Parser
=============================

As documented elsewhere (*note The Bison Parser Algorithm: Algorithm.)
Bison parsers are "shift/reduce automata".  In some cases (much more
frequent than one would hope), looking at this automaton is required
to tune or simply fix a parser.

   The textual file is generated when the options `--report' or
`--verbose' are specified, see *Note Invoking Bison: Invocation.  Its
name is made by removing `.tab.c' or `.c' from the parser
implementation file name, and adding `.output' instead.  Therefore,
if the grammar file is `foo.y', then the parser implementation file
is called `foo.tab.c' by default.  As a consequence, the verbose
output file is called `foo.output'.

   The following grammar file, `calc.y', will be used in the sequel:

     %token NUM STR
     %left '+' '-'
     %left '*'
     %%
     exp:
       exp '+' exp
     | exp '-' exp
     | exp '*' exp
     | exp '/' exp
     | NUM
     ;
     useless: STR;
     %%

   `bison' reports:

     calc.y: warning: 1 nonterminal useless in grammar
     calc.y: warning: 1 rule useless in grammar
     calc.y:12.1-7: warning: nonterminal useless in grammar: useless
     calc.y:12.10-12: warning: rule useless in grammar: useless: STR
     calc.y: conflicts: 7 shift/reduce

   When given `--report=state', in addition to `calc.tab.c', it
creates a file `calc.output' with contents detailed below.  The order
of the output and the exact presentation might vary, but the
interpretation is the same.

The first section reports useless tokens, nonterminals and rules.
Useless nonterminals and rules are removed in order to produce a
smaller parser, but useless tokens are preserved, since they might be
used by the scanner (note the difference between "useless" and
"unused" below):

     Nonterminals useless in grammar
        useless

     Terminals unused in grammar
        STR

     Rules useless in grammar
         6 useless: STR

The next section lists states that still have conflicts.

     State 8 conflicts: 1 shift/reduce
     State 9 conflicts: 1 shift/reduce
     State 10 conflicts: 1 shift/reduce
     State 11 conflicts: 4 shift/reduce

Then Bison reproduces the exact grammar it used:

     Grammar

         0 $accept: exp $end

         1 exp: exp '+' exp
         2    | exp '-' exp
         3    | exp '*' exp
         4    | exp '/' exp
         5    | NUM

and reports the uses of the symbols:

     Terminals, with rules where they appear

     $end (0) 0
     '*' (42) 3
     '+' (43) 1
     '-' (45) 2
     '/' (47) 4
     error (256)
     NUM (258) 5
     STR (259)

     Nonterminals, with rules where they appear

     $accept (9)
         on left: 0
     exp (10)
         on left: 1 2 3 4 5, on right: 0 1 2 3 4

Bison then proceeds onto the automaton itself, describing each state
with its set of "items", also known as "pointed rules".  Each item is
a production rule together with a point (`.') marking the location of
the input cursor.

     State 0

         0 $accept: . exp $end

         NUM  shift, and go to state 1

         exp  go to state 2

   This reads as follows: "state 0 corresponds to being at the very
beginning of the parsing, in the initial rule, right before the start
symbol (here, `exp').  When the parser returns to this state right
after having reduced a rule that produced an `exp', the control flow
jumps to state 2.  If there is no such transition on a nonterminal
symbol, and the lookahead is a `NUM', then this token is shifted onto
the parse stack, and the control flow jumps to state 1.  Any other
lookahead triggers a syntax error."

   Even though the only active rule in state 0 seems to be rule 0, the
report lists `NUM' as a lookahead token because `NUM' can be at the
beginning of any rule deriving an `exp'.  By default Bison reports
the so-called "core" or "kernel" of the item set, but if you want to
see more detail you can invoke `bison' with `--report=itemset' to
list the derived items as well:

     State 0

         0 $accept: . exp $end
         1 exp: . exp '+' exp
         2    | . exp '-' exp
         3    | . exp '*' exp
         4    | . exp '/' exp
         5    | . NUM

         NUM  shift, and go to state 1

         exp  go to state 2

In the state 1...

     State 1

         5 exp: NUM .

         $default  reduce using rule 5 (exp)

the rule 5, `exp: NUM;', is completed.  Whatever the lookahead token
(`$default'), the parser will reduce it.  If it was coming from State
0, then, after this reduction it will return to state 0, and will
jump to state 2 (`exp: go to state 2').

     State 2

         0 $accept: exp . $end
         1 exp: exp . '+' exp
         2    | exp . '-' exp
         3    | exp . '*' exp
         4    | exp . '/' exp

         $end  shift, and go to state 3
         '+'   shift, and go to state 4
         '-'   shift, and go to state 5
         '*'   shift, and go to state 6
         '/'   shift, and go to state 7

In state 2, the automaton can only shift a symbol.  For instance,
because of the item `exp: exp . '+' exp', if the lookahead is `+' it
is shifted onto the parse stack, and the automaton jumps to state 4,
corresponding to the item `exp: exp '+' . exp'.  Since there is no
default action, any lookahead not listed triggers a syntax error.

   The state 3 is named the "final state", or the "accepting state":

     State 3

         0 $accept: exp $end .

         $default  accept

the initial rule is completed (the start symbol and the end-of-input
were read), the parsing exits successfully.

   The interpretation of states 4 to 7 is straightforward, and is
left to the reader.

     State 4

         1 exp: exp '+' . exp

         NUM  shift, and go to state 1

         exp  go to state 8


     State 5

         2 exp: exp '-' . exp

         NUM  shift, and go to state 1

         exp  go to state 9


     State 6

         3 exp: exp '*' . exp

         NUM  shift, and go to state 1

         exp  go to state 10


     State 7

         4 exp: exp '/' . exp

         NUM  shift, and go to state 1

         exp  go to state 11

   As was announced in beginning of the report, `State 8 conflicts: 1
shift/reduce':

     State 8

         1 exp: exp . '+' exp
         1    | exp '+' exp .
         2    | exp . '-' exp
         3    | exp . '*' exp
         4    | exp . '/' exp

         '*'  shift, and go to state 6
         '/'  shift, and go to state 7

         '/'       [reduce using rule 1 (exp)]
         $default  reduce using rule 1 (exp)

   Indeed, there are two actions associated to the lookahead `/':
either shifting (and going to state 7), or reducing rule 1.  The
conflict means that either the grammar is ambiguous, or the parser
lacks information to make the right decision.  Indeed the grammar is
ambiguous, as, since we did not specify the precedence of `/', the
sentence `NUM + NUM / NUM' can be parsed as `NUM + (NUM / NUM)',
which corresponds to shifting `/', or as `(NUM + NUM) / NUM', which
corresponds to reducing rule 1.

   Because in deterministic parsing a single decision can be made,
Bison arbitrarily chose to disable the reduction, see *Note
Shift/Reduce Conflicts: Shift/Reduce.  Discarded actions are reported
between square brackets.

   Note that all the previous states had a single possible action:
either shifting the next token and going to the corresponding state,
or reducing a single rule.  In the other cases, i.e., when shifting
_and_ reducing is possible or when _several_ reductions are possible,
the lookahead is required to select the action.  State 8 is one such
state: if the lookahead is `*' or `/' then the action is shifting,
otherwise the action is reducing rule 1.  In other words, the first
two items, corresponding to rule 1, are not eligible when the
lookahead token is `*', since we specified that `*' has higher
precedence than `+'.  More generally, some items are eligible only
with some set of possible lookahead tokens.  When run with
`--report=lookahead', Bison specifies these lookahead tokens:

     State 8

         1 exp: exp . '+' exp
         1    | exp '+' exp .  [$end, '+', '-', '/']
         2    | exp . '-' exp
         3    | exp . '*' exp
         4    | exp . '/' exp

         '*'  shift, and go to state 6
         '/'  shift, and go to state 7

         '/'       [reduce using rule 1 (exp)]
         $default  reduce using rule 1 (exp)

   Note however that while `NUM + NUM / NUM' is ambiguous (which
results in the conflicts on `/'), `NUM + NUM * NUM' is not: the
conflict was solved thanks to associativity and precedence
directives.  If invoked with `--report=solved', Bison includes
information about the solved conflicts in the report:

     Conflict between rule 1 and token '+' resolved as reduce (%left '+').
     Conflict between rule 1 and token '-' resolved as reduce (%left '-').
     Conflict between rule 1 and token '*' resolved as shift ('+' < '*').

   The remaining states are similar:

     State 9

         1 exp: exp . '+' exp
         2    | exp . '-' exp
         2    | exp '-' exp .
         3    | exp . '*' exp
         4    | exp . '/' exp

         '*'  shift, and go to state 6
         '/'  shift, and go to state 7

         '/'       [reduce using rule 2 (exp)]
         $default  reduce using rule 2 (exp)

     State 10

         1 exp: exp . '+' exp
         2    | exp . '-' exp
         3    | exp . '*' exp
         3    | exp '*' exp .
         4    | exp . '/' exp

         '/'  shift, and go to state 7

         '/'       [reduce using rule 3 (exp)]
         $default  reduce using rule 3 (exp)

     State 11

         1 exp: exp . '+' exp
         2    | exp . '-' exp
         3    | exp . '*' exp
         4    | exp . '/' exp
         4    | exp '/' exp .

         '+'  shift, and go to state 4
         '-'  shift, and go to state 5
         '*'  shift, and go to state 6
         '/'  shift, and go to state 7

         '+'       [reduce using rule 4 (exp)]
         '-'       [reduce using rule 4 (exp)]
         '*'       [reduce using rule 4 (exp)]
         '/'       [reduce using rule 4 (exp)]
         $default  reduce using rule 4 (exp)

Observe that state 11 contains conflicts not only due to the lack of
precedence of `/' with respect to `+', `-', and `*', but also because
the associativity of `/' is not specified.

   Bison may also produce an HTML version of this output, via an XML
file and XSLT processing (*note Visualizing your parser in multiple
formats: Xml.).


File: bison.info,  Node: Graphviz,  Next: Xml,  Prev: Understanding,  Up: Debugging

8.2 Visualizing Your Parser
===========================

As another means to gain better understanding of the shift/reduce
automaton corresponding to the Bison parser, a DOT file can be
generated. Note that debugging a real grammar with this is tedious at
best, and impractical most of the times, because the generated files
are huge (the generation of a PDF or PNG file from it will take very
long, and more often than not it will fail due to memory exhaustion).
This option was rather designed for beginners, to help them
understand LR parsers.

   This file is generated when the `--graph' option is specified
(*note Invoking Bison: Invocation.).  Its name is made by removing
`.tab.c' or `.c' from the parser implementation file name, and adding
`.dot' instead.  If the grammar file is `foo.y', the Graphviz output
file is called `foo.dot'.  A DOT file may also be produced via an XML
file and XSLT processing (*note Visualizing your parser in multiple
formats: Xml.).

   The following grammar file, `rr.y', will be used in the sequel:

     %%
     exp: a ";" | b ".";
     a: "0";
     b: "0";

   The graphical output is very similar to the textual one, and as
such it is easier understood by making direct comparisons between
them.  *Note Debugging Your Parser: Debugging, for a detailled
analysis of the textual report.

Graphical Representation of States
----------------------------------

The items (pointed rules) for each state are grouped together in
graph nodes.  Their numbering is the same as in the verbose file. See
the following points, about transitions, for examples

   When invoked with `--report=lookaheads', the lookahead tokens, when
needed, are shown next to the relevant rule between square brackets
as a comma separated list. This is the case in the figure for the
representation of reductions, below.


   The transitions are represented as directed edges between the
current and the target states.

Graphical Representation of Shifts
----------------------------------

Shifts are shown as solid arrows, labelled with the lookahead token
for that shift. The following describes a reduction in the
`rr.output' file:

     State 3

         1 exp: a . ";"

         ";"  shift, and go to state 6

   A Graphviz rendering of this portion of the graph could be:



Graphical Representation of Reductions
--------------------------------------

Reductions are shown as solid arrows, leading to a diamond-shaped node
bearing the number of the reduction rule. The arrow is labelled with
the appropriate comma separated lookahead tokens. If the reduction is
the default action for the given state, there is no such label.

   This is how reductions are represented in the verbose file
`rr.output':
     State 1

         3 a: "0" .  [";"]
         4 b: "0" .  ["."]

         "."       reduce using rule 4 (b)
         $default  reduce using rule 3 (a)

   A Graphviz rendering of this portion of the graph could be:



When unresolved conflicts are present, because in deterministic
parsing a single decision can be made, Bison can arbitrarily choose
to disable a reduction, see *Note Shift/Reduce Conflicts:
Shift/Reduce.  Discarded actions are distinguished by a red filling
color on these nodes, just like how they are reported between square
brackets in the verbose file.

   The reduction corresponding to the rule number 0 is the acceptation
state. It is shown as a blue diamond, labelled "Acc".

Graphical representation of go tos
----------------------------------

The `go to' jump transitions are represented as dotted lines bearing
the name of the rule being jumped to.


File: bison.info,  Node: Xml,  Next: Tracing,  Prev: Graphviz,  Up: Debugging

8.3 Visualizing your parser in multiple formats
===============================================

Bison supports two major report formats: textual output (*note
Understanding Your Parser: Understanding.) when invoked with option
`--verbose', and DOT (*note Visualizing Your Parser: Graphviz.) when
invoked with option `--graph'. However, another alternative is to
output an XML file that may then be, with `xsltproc', rendered as
either a raw text format equivalent to the verbose file, or as an
HTML version of the same file, with clickable transitions, or even as
a DOT. The `.output' and DOT files obtained via XSLT have no
difference whatsoever with those obtained by invoking `bison' with
options `--verbose' or `--graph'.

   The XML file is generated when the options `-x' or `--xml[=FILE]'
are specified, see *Note Invoking Bison: Invocation.  If not
specified, its name is made by removing `.tab.c' or `.c' from the
parser implementation file name, and adding `.xml' instead.  For
instance, if the grammar file is `foo.y', the default XML output file
is `foo.xml'.

   Bison ships with a `data/xslt' directory, containing XSL
Transformation files to apply to the XML file. Their names are
non-ambiguous:

`xml2dot.xsl'
     Used to output a copy of the DOT visualization of the automaton.

`xml2text.xsl'
     Used to output a copy of the `.output' file.

`xml2xhtml.xsl'
     Used to output an xhtml enhancement of the `.output' file.

   Sample usage (requires `xsltproc'):
     $ bison -x gr.y
     $ bison --print-datadir
     /usr/local/share/bison
     $ xsltproc /usr/local/share/bison/xslt/xml2xhtml.xsl gr.xml >gr.html


File: bison.info,  Node: Tracing,  Prev: Xml,  Up: Debugging

8.4 Tracing Your Parser
=======================

When a Bison grammar compiles properly but parses "incorrectly", the
`yydebug' parser-trace feature helps figuring out why.

* Menu:

* Enabling Traces::    Activating run-time trace support
* Mfcalc Traces::      Extending `mfcalc' to support traces
* The YYPRINT Macro::  Obsolete interface for semantic value reports


File: bison.info,  Node: Enabling Traces,  Next: Mfcalc Traces,  Up: Tracing

8.4.1 Enabling Traces
---------------------

There are several means to enable compilation of trace facilities:

the macro `YYDEBUG'
     Define the macro `YYDEBUG' to a nonzero value when you compile
     the parser.  This is compliant with POSIX Yacc.  You could use
     `-DYYDEBUG=1' as a compiler option or you could put `#define
     YYDEBUG 1' in the prologue of the grammar file (*note The
     Prologue: Prologue.).

     If the `%define' variable `api.prefix' is used (*note Multiple
     Parsers in the Same Program: Multiple Parsers.), for instance
     `%define api.prefix x', then if `CDEBUG' is defined, its value
     controls the tracing feature (enabled if and only if nonzero);
     otherwise tracing is enabled if and only if `YYDEBUG' is nonzero.

the option `-t' (POSIX Yacc compliant)
the option `--debug' (Bison extension)
     Use the `-t' option when you run Bison (*note Invoking Bison:
     Invocation.).  With `%define api.prefix {c}', it defines
     `CDEBUG' to 1, otherwise it defines `YYDEBUG' to 1.

the directive `%debug'
     Add the `%debug' directive (*note Bison Declaration Summary:
     Decl Summary.).  This Bison extension is maintained for backward
     compatibility with previous versions of Bison.

the variable `parse.trace'
     Add the `%define parse.trace' directive (*note parse.trace:
     %define Summary.), or pass the `-Dparse.trace' option (*note
     Bison Options::).  This is a Bison extension, which is especially
     useful for languages that don't use a preprocessor.  Unless
     POSIX and Yacc portability matter to you, this is the preferred
     solution.

   We suggest that you always enable the trace option so that
debugging is always possible.

   The trace facility outputs messages with macro calls of the form
`YYFPRINTF (stderr, FORMAT, ARGS)' where FORMAT and ARGS are the
usual `printf' format and variadic arguments.  If you define
`YYDEBUG' to a nonzero value but do not define `YYFPRINTF',
`<stdio.h>' is automatically included and `YYFPRINTF' is defined to
`fprintf'.

   Once you have compiled the program with trace facilities, the way
to request a trace is to store a nonzero value in the variable
`yydebug'.  You can do this by making the C code do it (in `main',
perhaps), or you can alter the value with a C debugger.

   Each step taken by the parser when `yydebug' is nonzero produces a
line or two of trace information, written on `stderr'.  The trace
messages tell you these things:

   * Each time the parser calls `yylex', what kind of token was read.

   * Each time a token is shifted, the depth and complete contents of
     the state stack (*note Parser States::).

   * Each time a rule is reduced, which rule it is, and the complete
     contents of the state stack afterward.

   To make sense of this information, it helps to refer to the
automaton description file (*note Understanding Your Parser:
Understanding.).  This file shows the meaning of each state in terms
of positions in various rules, and also what each state will do with
each possible input token.  As you read the successive trace
messages, you can see that the parser is functioning according to its
specification in the listing file.  Eventually you will arrive at the
place where something undesirable happens, and you will see which
parts of the grammar are to blame.

   The parser implementation file is a C/C++/Java program and you can
use debuggers on it, but it's not easy to interpret what it is doing.
The parser function is a finite-state machine interpreter, and aside
from the actions it executes the same code over and over.  Only the
values of variables show where in the grammar it is working.


File: bison.info,  Node: Mfcalc Traces,  Next: The YYPRINT Macro,  Prev: Enabling Traces,  Up: Tracing

8.4.2 Enabling Debug Traces for `mfcalc'
----------------------------------------

The debugging information normally gives the token type of each token
read, but not its semantic value.  The `%printer' directive allows
specify how semantic values are reported, see *Note Printing Semantic
Values: Printer Decl.  For backward compatibility, Yacc like C
parsers may also use the `YYPRINT' (*note The `YYPRINT' Macro: The
YYPRINT Macro.), but its use is discouraged.

   As a demonstration of `%printer', consider the multi-function
calculator, `mfcalc' (*note Multi-function Calc::).  To enable
run-time traces, and semantic value reports, insert the following
directives in its prologue:

     /* Generate the parser description file.  */
     %verbose
     /* Enable run-time traces (yydebug).  */
     %define parse.trace

     /* Formatting semantic values.  */
     %printer { fprintf (yyoutput, "%s", $$->name); } VAR;
     %printer { fprintf (yyoutput, "%s()", $$->name); } FNCT;
     %printer { fprintf (yyoutput, "%g", $$); } <double>;

   The `%define' directive instructs Bison to generate run-time trace
support.  Then, activation of these traces is controlled at run-time
by the `yydebug' variable, which is disabled by default.  Because
these traces will refer to the "states" of the parser, it is helpful
to ask for the creation of a description of that parser; this is the
purpose of (admittedly ill-named) `%verbose' directive.

   The set of `%printer' directives demonstrates how to format the
semantic value in the traces.  Note that the specification can be done
either on the symbol type (e.g., `VAR' or `FNCT'), or on the type
tag: since `<double>' is the type for both `NUM' and `exp', this
printer will be used for them.

   Here is a sample of the information provided by run-time traces.
The traces are sent onto standard error.

     $ echo 'sin(1-1)' | ./mfcalc -p
     Starting parse
     Entering state 0
     Reducing stack by rule 1 (line 34):
     -> $$ = nterm input ()
     Stack now 0
     Entering state 1

This first batch shows a specific feature of this grammar: the first
rule (which is in line 34 of `mfcalc.y' can be reduced without even
having to look for the first token.  The resulting left-hand symbol
(`$$') is a valueless (`()') `input' non terminal (`nterm').

   Then the parser calls the scanner.
     Reading a token: Next token is token FNCT (sin())
     Shifting token FNCT (sin())
     Entering state 6

That token (`token') is a function (`FNCT') whose value is `sin' as
formatted per our `%printer' specification: `sin()'.  The parser
stores (`Shifting') that token, and others, until it can do something
about it.

     Reading a token: Next token is token '(' ()
     Shifting token '(' ()
     Entering state 14
     Reading a token: Next token is token NUM (1.000000)
     Shifting token NUM (1.000000)
     Entering state 4
     Reducing stack by rule 6 (line 44):
        $1 = token NUM (1.000000)
     -> $$ = nterm exp (1.000000)
     Stack now 0 1 6 14
     Entering state 24

The previous reduction demonstrates the `%printer' directive for
`<double>': both the token `NUM' and the resulting nonterminal `exp'
have `1' as value.

     Reading a token: Next token is token '-' ()
     Shifting token '-' ()
     Entering state 17
     Reading a token: Next token is token NUM (1.000000)
     Shifting token NUM (1.000000)
     Entering state 4
     Reducing stack by rule 6 (line 44):
        $1 = token NUM (1.000000)
     -> $$ = nterm exp (1.000000)
     Stack now 0 1 6 14 24 17
     Entering state 26
     Reading a token: Next token is token ')' ()
     Reducing stack by rule 11 (line 49):
        $1 = nterm exp (1.000000)
        $2 = token '-' ()
        $3 = nterm exp (1.000000)
     -> $$ = nterm exp (0.000000)
     Stack now 0 1 6 14
     Entering state 24

The rule for the subtraction was just reduced.  The parser is about to
discover the end of the call to `sin'.

     Next token is token ')' ()
     Shifting token ')' ()
     Entering state 31
     Reducing stack by rule 9 (line 47):
        $1 = token FNCT (sin())
        $2 = token '(' ()
        $3 = nterm exp (0.000000)
        $4 = token ')' ()
     -> $$ = nterm exp (0.000000)
     Stack now 0 1
     Entering state 11

Finally, the end-of-line allow the parser to complete the
computation, and display its result.

     Reading a token: Next token is token '\n' ()
     Shifting token '\n' ()
     Entering state 22
     Reducing stack by rule 4 (line 40):
        $1 = nterm exp (0.000000)
        $2 = token '\n' ()
     => 0
     -> $$ = nterm line ()
     Stack now 0 1
     Entering state 10
     Reducing stack by rule 2 (line 35):
        $1 = nterm input ()
        $2 = nterm line ()
     -> $$ = nterm input ()
     Stack now 0
     Entering state 1

   The parser has returned into state 1, in which it is waiting for
the next expression to evaluate, or for the end-of-file token, which
causes the completion of the parsing.

     Reading a token: Now at end of input.
     Shifting token $end ()
     Entering state 2
     Stack now 0 1 2
     Cleanup: popping token $end ()
     Cleanup: popping nterm input ()


File: bison.info,  Node: The YYPRINT Macro,  Prev: Mfcalc Traces,  Up: Tracing

8.4.3 The `YYPRINT' Macro
-------------------------

Before `%printer' support, semantic values could be displayed using
the `YYPRINT' macro, which works only for terminal symbols and only
with the `yacc.c' skeleton.

 -- Macro: YYPRINT (STREAM, TOKEN, VALUE);
     If you define `YYPRINT', it should take three arguments.  The
     parser will pass a standard I/O stream, the numeric code for the
     token type, and the token value (from `yylval').

     For `yacc.c' only.  Obsoleted by `%printer'.

   Here is an example of `YYPRINT' suitable for the multi-function
calculator (*note Declarations for `mfcalc': Mfcalc Declarations.):

     %{
       static void print_token_value (FILE *, int, YYSTYPE);
       #define YYPRINT(File, Type, Value)            \
         print_token_value (File, Type, Value)
     %}

     ... %% ... %% ...

     static void
     print_token_value (FILE *file, int type, YYSTYPE value)
     {
       if (type == VAR)
         fprintf (file, "%s", value.tptr->name);
       else if (type == NUM)
         fprintf (file, "%d", value.val);
     }


File: bison.info,  Node: Invocation,  Next: Other Languages,  Prev: Debugging,  Up: Top

9 Invoking Bison
****************

The usual way to invoke Bison is as follows:

     bison INFILE

   Here INFILE is the grammar file name, which usually ends in `.y'.
The parser implementation file's name is made by replacing the `.y'
with `.tab.c' and removing any leading directory.  Thus, the `bison
foo.y' file name yields `foo.tab.c', and the `bison hack/foo.y' file
name yields `foo.tab.c'.  It's also possible, in case you are writing
C++ code instead of C in your grammar file, to name it `foo.ypp' or
`foo.y++'.  Then, the output files will take an extension like the
given one as input (respectively `foo.tab.cpp' and `foo.tab.c++').
This feature takes effect with all options that manipulate file names
like `-o' or `-d'.

   For example :

     bison -d INFILE.YXX
   will produce `infile.tab.cxx' and `infile.tab.hxx', and

     bison -d -o OUTPUT.C++ INFILE.Y
   will produce `output.c++' and `outfile.h++'.

   For compatibility with POSIX, the standard Bison distribution also
contains a shell script called `yacc' that invokes Bison with the
`-y' option.

* Menu:

* Bison Options::     All the options described in detail,
                        in alphabetical order by short options.
* Option Cross Key::  Alphabetical list of long options.
* Yacc Library::      Yacc-compatible `yylex' and `main'.


File: bison.info,  Node: Bison Options,  Next: Option Cross Key,  Up: Invocation

9.1 Bison Options
=================

Bison supports both traditional single-letter options and mnemonic
long option names.  Long option names are indicated with `--' instead
of `-'.  Abbreviations for option names are allowed as long as they
are unique.  When a long option takes an argument, like
`--file-prefix', connect the option name and the argument with `='.

   Here is a list of options that can be used with Bison,
alphabetized by short option.  It is followed by a cross key
alphabetized by long option.

Operations modes:
`-h'
`--help'
     Print a summary of the command-line options to Bison and exit.

`-V'
`--version'
     Print the version number of Bison and exit.

`--print-localedir'
     Print the name of the directory containing locale-dependent data.

`--print-datadir'
     Print the name of the directory containing skeletons and XSLT.

`-y'
`--yacc'
     Act more like the traditional Yacc command.  This can cause
     different diagnostics to be generated, and may change behavior
     in other minor ways.  Most importantly, imitate Yacc's output
     file name conventions, so that the parser implementation file is
     called `y.tab.c', and the other outputs are called `y.output'
     and `y.tab.h'.  Also, if generating a deterministic parser in C,
     generate `#define' statements in addition to an `enum' to
     associate token numbers with token names.  Thus, the following
     shell script can substitute for Yacc, and the Bison distribution
     contains such a script for compatibility with POSIX:

          #! /bin/sh
          bison -y "$@"

     The `-y'/`--yacc' option is intended for use with traditional
     Yacc grammars.  If your grammar uses a Bison extension like
     `%glr-parser', Bison might not be Yacc-compatible even if this
     option is specified.

`-W [CATEGORY]'
`--warnings[=CATEGORY]'
     Output warnings falling in CATEGORY.  CATEGORY can be one of:
    `midrule-values'
          Warn about mid-rule values that are set but not used within
          any of the actions of the parent rule.  For example, warn
          about unused `$2' in:

               exp: '1' { $$ = 1; } '+' exp { $$ = $1 + $4; };

          Also warn about mid-rule values that are used but not set.
          For example, warn about unset `$$' in the mid-rule action
          in:

               exp: '1' { $1 = 1; } '+' exp { $$ = $2 + $4; };

          These warnings are not enabled by default since they
          sometimes prove to be false alarms in existing grammars
          employing the Yacc constructs `$0' or `$-N' (where N is
          some positive integer).

    `yacc'
          Incompatibilities with POSIX Yacc.

    `conflicts-sr'
    `conflicts-rr'
          S/R and R/R conflicts.  These warnings are enabled by
          default.  However, if the `%expect' or `%expect-rr'
          directive is specified, an unexpected number of conflicts
          is an error, and an expected number of conflicts is not
          reported, so `-W' and `--warning' then have no effect on
          the conflict report.

    `deprecated'
          Deprecated constructs whose support will be removed in
          future versions of Bison.

    `empty-rule'
          Empty rules without `%empty'.  *Note Empty Rules::.
          Disabled by default, but enabled by uses of `%empty', unless
          `-Wno-empty-rule' was specified.

    `precedence'
          Useless precedence and associativity directives.  Disabled
          by default.

          Consider for instance the following grammar:

               %nonassoc "="
               %left "+"
               %left "*"
               %precedence "("
               %%
               stmt:
                 exp
               | "var" "=" exp
               ;

               exp:
                 exp "+" exp
               | exp "*" "num"
               | "(" exp ")"
               | "num"
               ;

          Bison reports:

               warning: useless precedence and associativity for "="
                %nonassoc "="
                          ^^^
               warning: useless associativity for "*", use %precedence
                %left "*"
                      ^^^
               warning: useless precedence for "("
                %precedence "("
                            ^^^

          One would get the exact same parser with the following
          directives instead:

               %left "+"
               %precedence "*"

    `other'
          All warnings not categorized above.  These warnings are
          enabled by default.

          This category is provided merely for the sake of
          completeness.  Future releases of Bison may move warnings
          from this category to new, more specific categories.

    `all'
          All the warnings except `yacc'.

    `none'
          Turn off all the warnings.

    `error'
          See `-Werror', below.

     A category can be turned off by prefixing its name with `no-'.
     For instance, `-Wno-yacc' will hide the warnings about POSIX
     Yacc incompatibilities.

`-Werror'
     Turn enabled warnings for every CATEGORY into errors, unless
     they are explicitly disabled by `-Wno-error=CATEGORY'.

`-Werror=CATEGORY'
     Enable warnings falling in CATEGORY, and treat them as errors.

     CATEGORY is the same as for `--warnings', with the exception that
     it may not be prefixed with `no-' (see above).

     Note that the precedence of the `=' and `,' operators is such
     that the following commands are _not_ equivalent, as the first
     will not treat S/R conflicts as errors.

          $ bison -Werror=yacc,conflicts-sr input.y
          $ bison -Werror=yacc,error=conflicts-sr input.y

`-Wno-error'
     Do not turn enabled warnings for every CATEGORY into errors,
     unless they are explicitly enabled by `-Werror=CATEGORY'.

`-Wno-error=CATEGORY'
     Deactivate the error treatment for this CATEGORY. However, the
     warning itself won't be disabled, or enabled, by this option.

`-f [FEATURE]'
`--feature[=FEATURE]'
     Activate miscellaneous FEATURE. FEATURE can be one of:
    `caret'
    `diagnostics-show-caret'
          Show caret errors, in a manner similar to GCC's
          `-fdiagnostics-show-caret', or Clang's
          `-fcaret-diagnotics'. The location provided with the
          message is used to quote the corresponding line of the
          source file, underlining the important part of it with
          carets (^). Here is an example, using the following file
          `in.y':

               %type <ival> exp
               %%
               exp: exp '+' exp { $exp = $1 + $2; };

          When invoked with `-fcaret' (or nothing), Bison will report:

               in.y:3.20-23: error: ambiguous reference: '$exp'
                exp: exp '+' exp { $exp = $1 + $2; };
                                   ^^^^
               in.y:3.1-3:       refers to: $exp at $$
                exp: exp '+' exp { $exp = $1 + $2; };
                ^^^
               in.y:3.6-8:       refers to: $exp at $1
                exp: exp '+' exp { $exp = $1 + $2; };
                     ^^^
               in.y:3.14-16:     refers to: $exp at $3
                exp: exp '+' exp { $exp = $1 + $2; };
                             ^^^
               in.y:3.32-33: error: $2 of 'exp' has no declared type
                exp: exp '+' exp { $exp = $1 + $2; };
                                               ^^

          Whereas, when invoked with `-fno-caret', Bison will only
          report:

               in.y:3.20-23: error: ambiguous reference: $exp
               in.y:3.1-3:       refers to: $exp at $$
               in.y:3.6-8:       refers to: $exp at $1
               in.y:3.14-16:     refers to: $exp at $3
               in.y:3.32-33: error: $2 of exp has no declared type

          This option is activated by default.


Tuning the parser:

`-t'
`--debug'
     In the parser implementation file, define the macro `YYDEBUG' to
     1 if it is not already defined, so that the debugging facilities
     are compiled.  *Note Tracing Your Parser: Tracing.

`-D NAME[=VALUE]'
`--define=NAME[=VALUE]'
`-F NAME[=VALUE]'
`--force-define=NAME[=VALUE]'
     Each of these is equivalent to `%define NAME "VALUE"' (*note
     %define Summary::) except that Bison processes multiple
     definitions for the same NAME as follows:

        * Bison quietly ignores all command-line definitions for NAME
          except the last.

        * If that command-line definition is specified by a `-D' or
          `--define', Bison reports an error for any `%define'
          definition for NAME.

        * If that command-line definition is specified by a `-F' or
          `--force-define' instead, Bison quietly ignores all
          `%define' definitions for NAME.

        * Otherwise, Bison reports an error if there are multiple
          `%define' definitions for NAME.

     You should avoid using `-F' and `--force-define' in your make
     files unless you are confident that it is safe to quietly ignore
     any conflicting `%define' that may be added to the grammar file.

`-L LANGUAGE'
`--language=LANGUAGE'
     Specify the programming language for the generated parser, as if
     `%language' was specified (*note Bison Declaration Summary: Decl
     Summary.).  Currently supported languages include C, C++, and
     Java.  LANGUAGE is case-insensitive.

`--locations'
     Pretend that `%locations' was specified.  *Note Decl Summary::.

`-p PREFIX'
`--name-prefix=PREFIX'
     Pretend that `%name-prefix "PREFIX"' was specified (*note Decl
     Summary::).  Obsoleted by `-Dapi.prefix=PREFIX'.  *Note Multiple
     Parsers in the Same Program: Multiple Parsers.

`-l'
`--no-lines'
     Don't put any `#line' preprocessor commands in the parser
     implementation file.  Ordinarily Bison puts them in the parser
     implementation file so that the C compiler and debuggers will
     associate errors with your source file, the grammar file.  This
     option causes them to associate errors with the parser
     implementation file, treating it as an independent source file
     in its own right.

`-S FILE'
`--skeleton=FILE'
     Specify the skeleton to use, similar to `%skeleton' (*note Bison
     Declaration Summary: Decl Summary.).

     If FILE does not contain a `/', FILE is the name of a skeleton
     file in the Bison installation directory.  If it does, FILE is
     an absolute file name or a file name relative to the current
     working directory.  This is similar to how most shells resolve
     commands.

`-k'
`--token-table'
     Pretend that `%token-table' was specified.  *Note Decl Summary::.

Adjust the output:

`--defines[=FILE]'
     Pretend that `%defines' was specified, i.e., write an extra
     output file containing macro definitions for the token type
     names defined in the grammar, as well as a few other
     declarations.  *Note Decl Summary::.

`-d'
     This is the same as `--defines' except `-d' does not accept a
     FILE argument since POSIX Yacc requires that `-d' can be bundled
     with other short options.

`-b FILE-PREFIX'
`--file-prefix=PREFIX'
     Pretend that `%file-prefix' was specified, i.e., specify prefix
     to use for all Bison output file names.  *Note Decl Summary::.

`-r THINGS'
`--report=THINGS'
     Write an extra output file containing verbose description of the
     comma separated list of THINGS among:

    `state'
          Description of the grammar, conflicts (resolved and
          unresolved), and parser's automaton.

    `itemset'
          Implies `state' and augments the description of the
          automaton with the full set of items for each state,
          instead of its core only.

    `lookahead'
          Implies `state' and augments the description of the
          automaton with each rule's lookahead set.

    `solved'
          Implies `state'.  Explain how conflicts were solved thanks
          to precedence and associativity directives.

    `all'
          Enable all the items.

    `none'
          Do not generate the report.

`--report-file=FILE'
     Specify the FILE for the verbose description.

`-v'
`--verbose'
     Pretend that `%verbose' was specified, i.e., write an extra
     output file containing verbose descriptions of the grammar and
     parser.  *Note Decl Summary::.

`-o FILE'
`--output=FILE'
     Specify the FILE for the parser implementation file.

     The other output files' names are constructed from FILE as
     described under the `-v' and `-d' options.

`-g [FILE]'
`--graph[=FILE]'
     Output a graphical representation of the parser's automaton
     computed by Bison, in Graphviz (http://www.graphviz.org/) DOT
     (http://www.graphviz.org/doc/info/lang.html) format.  `FILE' is
     optional.  If omitted and the grammar file is `foo.y', the
     output file will be `foo.dot'.

`-x [FILE]'
`--xml[=FILE]'
     Output an XML report of the parser's automaton computed by Bison.
     `FILE' is optional.  If omitted and the grammar file is `foo.y',
     the output file will be `foo.xml'.  (The current XML schema is
     experimental and may evolve.  More user feedback will help to
     stabilize it.)


File: bison.info,  Node: Option Cross Key,  Next: Yacc Library,  Prev: Bison Options,  Up: Invocation

9.2 Option Cross Key
====================

Here is a list of options, alphabetized by long option, to help you
find the corresponding short option and directive.

Long Option                     Short Option        Bison Directive
--------------------------------------------------------------------------------- 
`--debug'                       `-t'                `%debug'
`--define=NAME[=VALUE]'         `-D NAME[=VALUE]'   `%define NAME ["VALUE"]'
`--defines[=FILE]'              `-d'                `%defines ["FILE"]'
`--feature[=FEATURE]'           `-f [FEATURE]'      
`--file-prefix=PREFIX'          `-b PREFIX'         `%file-prefix "PREFIX"'
`--force-define=NAME[=VALUE]'   `-F NAME[=VALUE]'   `%define NAME ["VALUE"]'
`--graph[=FILE]'                `-g [FILE]'         
`--help'                        `-h'                
`--language=LANGUAGE'           `-L LANGUAGE'       `%language "LANGUAGE"'
`--locations'                                       `%locations'
`--name-prefix=PREFIX'          `-p PREFIX'         `%name-prefix "PREFIX"'
`--no-lines'                    `-l'                `%no-lines'
`--output=FILE'                 `-o FILE'           `%output "FILE"'
`--print-datadir'                                   
`--print-localedir'                                 
`--report-file=FILE'                                
`--report=THINGS'               `-r THINGS'         
`--skeleton=FILE'               `-S FILE'           `%skeleton "FILE"'
`--token-table'                 `-k'                `%token-table'
`--verbose'                     `-v'                `%verbose'
`--version'                     `-V'                
`--warnings[=CATEGORY]'         `-W [CATEGORY]'     
`--xml[=FILE]'                  `-x [FILE]'         
`--yacc'                        `-y'                `%yacc'


File: bison.info,  Node: Yacc Library,  Prev: Option Cross Key,  Up: Invocation

9.3 Yacc Library
================

The Yacc library contains default implementations of the `yyerror'
and `main' functions.  These default implementations are normally not
useful, but POSIX requires them.  To use the Yacc library, link your
program with the `-ly' option.  Note that Bison's implementation of
the Yacc library is distributed under the terms of the GNU General
Public License (*note Copying::).

   If you use the Yacc library's `yyerror' function, you should
declare `yyerror' as follows:

     int yyerror (char const *);

   Bison ignores the `int' value returned by this `yyerror'.  If you
use the Yacc library's `main' function, your `yyparse' function
should have the following type signature:

     int yyparse (void);


File: bison.info,  Node: Other Languages,  Next: FAQ,  Prev: Invocation,  Up: Top

10 Parsers Written In Other Languages
*************************************

* Menu:

* C++ Parsers::                 The interface to generate C++ parser classes
* Java Parsers::                The interface to generate Java parser classes


File: bison.info,  Node: C++ Parsers,  Next: Java Parsers,  Up: Other Languages

10.1 C++ Parsers
================

* Menu:

* C++ Bison Interface::         Asking for C++ parser generation
* C++ Semantic Values::         %union vs. C++
* C++ Location Values::         The position and location classes
* C++ Parser Interface::        Instantiating and running the parser
* C++ Scanner Interface::       Exchanges between yylex and parse
* A Complete C++ Example::      Demonstrating their use


File: bison.info,  Node: C++ Bison Interface,  Next: C++ Semantic Values,  Up: C++ Parsers

10.1.1 C++ Bison Interface
--------------------------

The C++ deterministic parser is selected using the skeleton directive,
`%skeleton "lalr1.cc"', or the synonymous command-line option
`--skeleton=lalr1.cc'.  *Note Decl Summary::.

   When run, `bison' will create several entities in the `yy'
namespace.  Use the `%define api.namespace' directive to change the
namespace name, see *Note api.namespace: %define Summary.  The
various classes are generated in the following files:

`position.hh'
`location.hh'
     The definition of the classes `position' and `location', used for
     location tracking when enabled.  These files are not generated
     if the `%define' variable `api.location.type' is defined.  *Note
     C++ Location Values::.

`stack.hh'
     An auxiliary class `stack' used by the parser.

`FILE.hh'
`FILE.cc'
     (Assuming the extension of the grammar file was `.yy'.)  The
     declaration and implementation of the C++ parser class.  The
     basename and extension of these two files follow the same rules
     as with regular C parsers (*note Invocation::).

     The header is _mandatory_; you must either pass `-d'/`--defines'
     to `bison', or use the `%defines' directive.

   All these files are documented using Doxygen; run `doxygen' for a
complete and accurate documentation.


File: bison.info,  Node: C++ Semantic Values,  Next: C++ Location Values,  Prev: C++ Bison Interface,  Up: C++ Parsers

10.1.2 C++ Semantic Values
--------------------------

Bison supports two different means to handle semantic values in C++.
One is alike the C interface, and relies on unions (*note C++
Unions::).  As C++ practitioners know, unions are inconvenient in
C++, therefore another approach is provided, based on variants (*note
C++ Variants::).

* Menu:

* C++ Unions::             Semantic values cannot be objects
* C++ Variants::           Using objects as semantic values


File: bison.info,  Node: C++ Unions,  Next: C++ Variants,  Up: C++ Semantic Values

10.1.2.1 C++ Unions
...................

The `%union' directive works as for C, see *Note The Union
Declaration: Union Decl.  In particular it produces a genuine
`union', which have a few specific features in C++.
   - The type `YYSTYPE' is defined but its use is discouraged: rather
     you should refer to the parser's encapsulated type
     `yy::parser::semantic_type'.

   - Non POD (Plain Old Data) types cannot be used.  C++ forbids any
     instance of classes with constructors in unions: only _pointers_
     to such objects are allowed.

   Because objects have to be stored via pointers, memory is not
reclaimed automatically: using the `%destructor' directive is the
only means to avoid leaks.  *Note Freeing Discarded Symbols:
Destructor Decl.


File: bison.info,  Node: C++ Variants,  Prev: C++ Unions,  Up: C++ Semantic Values

10.1.2.2 C++ Variants
.....................

Bison provides a _variant_ based implementation of semantic values for
C++.  This alleviates all the limitations reported in the previous
section, and in particular, object types can be used without pointers.

   To enable variant-based semantic values, set `%define' variable
`variant' (*note variant: %define Summary.).  Once this defined,
`%union' is ignored, and instead of using the name of the fields of
the `%union' to "type" the symbols, use genuine types.

   For instance, instead of

     %union
     {
       int ival;
       std::string* sval;
     }
     %token <ival> NUMBER;
     %token <sval> STRING;

write

     %token <int> NUMBER;
     %token <std::string> STRING;

   `STRING' is no longer a pointer, which should fairly simplify the
user actions in the grammar and in the scanner (in particular the
memory management).

   Since C++ features destructors, and since it is customary to
specialize `operator<<' to support uniform printing of values,
variants also typically simplify Bison printers and destructors.

   Variants are stricter than unions.  When based on unions, you may
play any dirty game with `yylval', say storing an `int', reading a
`char*', and then storing a `double' in it.  This is no longer
possible with variants: they must be initialized, then assigned to,
and eventually, destroyed.

 -- Method on semantic_type: T& build<T> ()
     Initialize, but leave empty.  Returns the address where the
     actual value may be stored.  Requires that the variant was not
     initialized yet.

 -- Method on semantic_type: T& build<T> (const T& T)
     Initialize, and copy-construct from T.

   *Warning*: We do not use Boost.Variant, for two reasons.  First, it
appeared unacceptable to require Boost on the user's machine (i.e.,
the machine on which the generated parser will be compiled, not the
machine on which `bison' was run).  Second, for each possible
semantic value, Boost.Variant not only stores the value, but also a
tag specifying its type.  But the parser already "knows" the type of
the semantic value, so that would be duplicating the information.

   Therefore we developed light-weight variants whose type tag is
external (so they are really like `unions' for C++ actually).  But
our code is much less mature that Boost.Variant.  So there is a
number of limitations in (the current implementation of) variants:
   * Alignment must be enforced: values should be aligned in memory
     according to the most demanding type.  Computing the smallest
     alignment possible requires meta-programming techniques that are
     not currently implemented in Bison, and therefore, since, as far
     as we know, `double' is the most demanding type on all
     platforms, alignments are enforced for `double' whatever types
     are actually used.  This may waste space in some cases.

   * There might be portability issues we are not aware of.

   As far as we know, these limitations _can_ be alleviated.  All it
takes is some time and/or some talented C++ hacker willing to
contribute to Bison.


File: bison.info,  Node: C++ Location Values,  Next: C++ Parser Interface,  Prev: C++ Semantic Values,  Up: C++ Parsers

10.1.3 C++ Location Values
--------------------------

When the directive `%locations' is used, the C++ parser supports
location tracking, see *Note Tracking Locations::.

   By default, two auxiliary classes define a `position', a single
point in a file, and a `location', a range composed of a pair of
`position's (possibly spanning several files).  But if the `%define'
variable `api.location.type' is defined, then these classes will not
be generated, and the user defined type will be used.

   In this section `uint' is an abbreviation for `unsigned int': in
genuine code only the latter is used.

* Menu:

* C++ position::         One point in the source file
* C++ location::         Two points in the source file
* User Defined Location Type::  Required interface for locations


File: bison.info,  Node: C++ position,  Next: C++ location,  Up: C++ Location Values

10.1.3.1 C++ `position'
.......................

 -- Constructor on position:  position (std::string* FILE = 0, uint
          LINE = 1, uint COL = 1)
     Create a `position' denoting a given point.  Note that `file' is
     not reclaimed when the `position' is destroyed: memory managed
     must be handled elsewhere.

 -- Method on position: void initialize (std::string* FILE = 0, uint
          LINE = 1, uint COL = 1)
     Reset the position to the given values.

 -- Instance Variable of position: std::string* file
     The name of the file.  It will always be handled as a pointer,
     the parser will never duplicate nor deallocate it.  As an
     experimental feature you may change it to `TYPE*' using `%define
     filename_type "TYPE"'.

 -- Instance Variable of position: uint line
     The line, starting at 1.

 -- Method on position: void lines (int HEIGHT = 1)
     If HEIGHT is not null, advance by HEIGHT lines, resetting the
     column number.  The resulting line number cannot be less than 1.

 -- Instance Variable of position: uint column
     The column, starting at 1.

 -- Method on position: void columns (int WIDTH = 1)
     Advance by WIDTH columns, without changing the line number. The
     resulting column number cannot be less than 1.

 -- Method on position: position& operator+= (int WIDTH)
 -- Method on position: position operator+ (int WIDTH)
 -- Method on position: position& operator-= (int WIDTH)
 -- Method on position: position operator- (int WIDTH)
     Various forms of syntactic sugar for `columns'.

 -- Method on position: bool operator== (const position& THAT)
 -- Method on position: bool operator!= (const position& THAT)
     Whether `*this' and `that' denote equal/different positions.

 -- Function: std::ostream& operator<< (std::ostream& O, const
          position& P)
     Report P on O like this: `FILE:LINE.COLUMN', or `LINE.COLUMN' if
     FILE is null.


File: bison.info,  Node: C++ location,  Next: User Defined Location Type,  Prev: C++ position,  Up: C++ Location Values

10.1.3.2 C++ `location'
.......................

 -- Constructor on location:  location (const position& BEGIN, const
          position& END)
     Create a `Location' from the endpoints of the range.

 -- Constructor on location:  location (const position& POS =
          position())
 -- Constructor on location:  location (std::string* FILE, uint LINE,
          uint COL)
     Create a `Location' denoting an empty range located at a given
     point.

 -- Method on location: void initialize (std::string* FILE = 0, uint
          LINE = 1, uint COL = 1)
     Reset the location to an empty range at the given values.

 -- Instance Variable of location: position begin
 -- Instance Variable of location: position end
     The first, inclusive, position of the range, and the first
     beyond.

 -- Method on location: void columns (int WIDTH = 1)
 -- Method on location: void lines (int HEIGHT = 1)
     Forwarded to the `end' position.

 -- Method on location: location operator+ (const location& END)
 -- Method on location: location operator+ (int WIDTH)
 -- Method on location: location operator+= (int WIDTH)
 -- Method on location: location operator- (int WIDTH)
 -- Method on location: location operator-= (int WIDTH)
     Various forms of syntactic sugar.

 -- Method on location: void step ()
     Move `begin' onto `end'.

 -- Method on location: bool operator== (const location& THAT)
 -- Method on location: bool operator!= (const location& THAT)
     Whether `*this' and `that' denote equal/different ranges of
     positions.

 -- Function: std::ostream& operator<< (std::ostream& O, const
          location& P)
     Report P on O, taking care of special cases such as: no
     `filename' defined, or equal filename/line or column.


File: bison.info,  Node: User Defined Location Type,  Prev: C++ location,  Up: C++ Location Values

10.1.3.3 User Defined Location Type
...................................

Instead of using the built-in types you may use the `%define' variable
`api.location.type' to specify your own type:

     %define api.location.type {LOCATIONTYPE}

   The requirements over your LOCATIONTYPE are:
   * it must be copyable;

   * in order to compute the (default) value of `@$' in a reduction,
     the parser basically runs
          @$.begin = @$1.begin;
          @$.end   = @$N.end; // The location of last right-hand side symbol.
     so there must be copyable `begin' and `end' members;

   * alternatively you may redefine the computation of the default
     location, in which case these members are not required (*note
     Location Default Action::);

   * if traces are enabled, then there must exist an `std::ostream&
     operator<< (std::ostream& o, const LOCATIONTYPE& s)' function.


   In programs with several C++ parsers, you may also use the
`%define' variable `api.location.type' to share a common set of
built-in definitions for `position' and `location'.  For instance, one
parser `master/parser.yy' might use:

     %defines
     %locations
     %define api.namespace {master::}

to generate the `master/position.hh' and `master/location.hh' files,
reused by other parsers as follows:

     %define api.location.type {master::location}
     %code requires { #include <master/location.hh> }


File: bison.info,  Node: C++ Parser Interface,  Next: C++ Scanner Interface,  Prev: C++ Location Values,  Up: C++ Parsers

10.1.4 C++ Parser Interface
---------------------------

The output files `OUTPUT.hh' and `OUTPUT.cc' declare and define the
parser class in the namespace `yy'.  The class name defaults to
`parser', but may be changed using `%define parser_class_name
{NAME}'.  The interface of this class is detailed below.  It can be
extended using the `%parse-param' feature: its semantics is slightly
changed since it describes an additional member of the parser class,
and an additional argument for its constructor.

 -- Type of parser: semantic_type
 -- Type of parser: location_type
     The types for semantic values and locations (if enabled).

 -- Type of parser: token
     A structure that contains (only) the `yytokentype' enumeration,
     which defines the tokens.  To refer to the token `FOO', use
     `yy::parser::token::FOO'.  The scanner can use `typedef
     yy::parser::token token;' to "import" the token enumeration
     (*note Calc++ Scanner::).

 -- Type of parser: syntax_error
     This class derives from `std::runtime_error'.  Throw instances
     of it from the scanner or from the user actions to raise parse
     errors.  This is equivalent with first invoking `error' to
     report the location and message of the syntax error, and then to
     invoke `YYERROR' to enter the error-recovery mode.  But contrary
     to `YYERROR' which can only be invoked from user actions (i.e.,
     written in the action itself), the exception can be thrown from
     function invoked from the user action.

 -- Method on parser:  parser (TYPE1 ARG1, ...)
     Build a new parser object.  There are no arguments by default,
     unless `%parse-param {TYPE1 ARG1}' was used.

 -- Method on syntax_error:  syntax_error (const location_type& L,
          const std::string& M)
 -- Method on syntax_error:  syntax_error (const std::string& M)
     Instantiate a syntax-error exception.

 -- Method on parser: int parse ()
     Run the syntactic analysis, and return 0 on success, 1 otherwise.

     The whole function is wrapped in a `try'/`catch' block, so that
     when an exception is thrown, the `%destructor's are called to
     release the lookahead symbol, and the symbols pushed on the
     stack.

 -- Method on parser: std::ostream& debug_stream ()
 -- Method on parser: void set_debug_stream (std::ostream& O)
     Get or set the stream used for tracing the parsing.  It defaults
     to `std::cerr'.

 -- Method on parser: debug_level_type debug_level ()
 -- Method on parser: void set_debug_level (debug_level L)
     Get or set the tracing level.  Currently its value is either 0,
     no trace, or nonzero, full tracing.

 -- Method on parser: void error (const location_type& L, const
          std::string& M)
 -- Method on parser: void error (const std::string& M)
     The definition for this member function must be supplied by the
     user: the parser uses it to report a parser error occurring at L,
     described by M.  If location tracking is not enabled, the second
     signature is used.


File: bison.info,  Node: C++ Scanner Interface,  Next: A Complete C++ Example,  Prev: C++ Parser Interface,  Up: C++ Parsers

10.1.5 C++ Scanner Interface
----------------------------

The parser invokes the scanner by calling `yylex'.  Contrary to C
parsers, C++ parsers are always pure: there is no point in using the
`%define api.pure' directive.  The actual interface with `yylex'
depends whether you use unions, or variants.

* Menu:

* Split Symbols::         Passing symbols as two/three components
* Complete Symbols::      Making symbols a whole


File: bison.info,  Node: Split Symbols,  Next: Complete Symbols,  Up: C++ Scanner Interface

10.1.5.1 Split Symbols
......................

The interface is as follows.

 -- Method on parser: int yylex (semantic_type* YYLVAL,
          location_type* YYLLOC, TYPE1 ARG1, ...)
 -- Method on parser: int yylex (semantic_type* YYLVAL, TYPE1 ARG1,
          ...)
     Return the next token.  Its type is the return value, its
     semantic value and location (if enabled) being YYLVAL and
     YYLLOC.  Invocations of `%lex-param {TYPE1 ARG1}' yield
     additional arguments.

   Note that when using variants, the interface for `yylex' is the
same, but `yylval' is handled differently.

   Regular union-based code in Lex scanner typically look like:

     [0-9]+   {
                yylval.ival = text_to_int (yytext);
                return yy::parser::INTEGER;
              }
     [a-z]+   {
                yylval.sval = new std::string (yytext);
                return yy::parser::IDENTIFIER;
              }

   Using variants, `yylval' is already constructed, but it is not
initialized.  So the code would look like:

     [0-9]+   {
                yylval.build<int>() = text_to_int (yytext);
                return yy::parser::INTEGER;
              }
     [a-z]+   {
                yylval.build<std::string> = yytext;
                return yy::parser::IDENTIFIER;
              }

or

     [0-9]+   {
                yylval.build(text_to_int (yytext));
                return yy::parser::INTEGER;
              }
     [a-z]+   {
                yylval.build(yytext);
                return yy::parser::IDENTIFIER;
              }


File: bison.info,  Node: Complete Symbols,  Prev: Split Symbols,  Up: C++ Scanner Interface

10.1.5.2 Complete Symbols
.........................

If you specified both `%define api.value.type variant' and `%define
api.token.constructor', the `parser' class also defines the class
`parser::symbol_type' which defines a _complete_ symbol, aggregating
its type (i.e., the traditional value returned by `yylex'), its
semantic value (i.e., the value passed in `yylval', and possibly its
location (`yylloc').

 -- Method on symbol_type:  symbol_type (token_type TYPE, const
          semantic_type& VALUE, const location_type& LOCATION)
     Build a complete terminal symbol which token type is TYPE, and
     which semantic value is VALUE.  If location tracking is enabled,
     also pass the LOCATION.

   This interface is low-level and should not be used for two
reasons.  First, it is inconvenient, as you still have to build the
semantic value, which is a variant, and second, because consistency
is not enforced: as with unions, it is still possible to give an
integer as semantic value for a string.

   So for each token type, Bison generates named constructors as
follows.

 -- Method on symbol_type:  make_TOKEN (const VALUE_TYPE& VALUE,
          const location_type& LOCATION)
 -- Method on symbol_type:  make_TOKEN (const location_type& LOCATION)
     Build a complete terminal symbol for the token type TOKEN (not
     including the `api.token.prefix') whose possible semantic value
     is VALUE of adequate VALUE_TYPE.  If location tracking is
     enabled, also pass the LOCATION.

   For instance, given the following declarations:

     %define api.token.prefix {TOK_}
     %token <std::string> IDENTIFIER;
     %token <int> INTEGER;
     %token COLON;

Bison generates the following functions:

     symbol_type make_IDENTIFIER(const std::string& v,
                                 const location_type& l);
     symbol_type make_INTEGER(const int& v,
                              const location_type& loc);
     symbol_type make_COLON(const location_type& loc);

which should be used in a Lex-scanner as follows.

     [0-9]+   return yy::parser::make_INTEGER(text_to_int (yytext), loc);
     [a-z]+   return yy::parser::make_IDENTIFIER(yytext, loc);
     ":"      return yy::parser::make_COLON(loc);

   Tokens that do not have an identifier are not accessible: you
cannot simply use characters such as `':'', they must be declared
with `%token'.


File: bison.info,  Node: A Complete C++ Example,  Prev: C++ Scanner Interface,  Up: C++ Parsers

10.1.6 A Complete C++ Example
-----------------------------

This section demonstrates the use of a C++ parser with a simple but
complete example.  This example should be available on your system,
ready to compile, in the directory ".../bison/examples/calc++".  It
focuses on the use of Bison, therefore the design of the various C++
classes is very naive: no accessors, no encapsulation of members etc.
We will use a Lex scanner, and more precisely, a Flex scanner, to
demonstrate the various interactions.  A hand-written scanner is
actually easier to interface with.

* Menu:

* Calc++ --- C++ Calculator::   The specifications
* Calc++ Parsing Driver::       An active parsing context
* Calc++ Parser::               A parser class
* Calc++ Scanner::              A pure C++ Flex scanner
* Calc++ Top Level::            Conducting the band


File: bison.info,  Node: Calc++ --- C++ Calculator,  Next: Calc++ Parsing Driver,  Up: A Complete C++ Example

10.1.6.1 Calc++ -- C++ Calculator
.................................

Of course the grammar is dedicated to arithmetics, a single
expression, possibly preceded by variable assignments.  An
environment containing possibly predefined variables such as `one'
and `two', is exchanged with the parser.  An example of valid input
follows.

     three := 3
     seven := one + two * three
     seven * seven


File: bison.info,  Node: Calc++ Parsing Driver,  Next: Calc++ Parser,  Prev: Calc++ --- C++ Calculator,  Up: A Complete C++ Example

10.1.6.2 Calc++ Parsing Driver
..............................

To support a pure interface with the parser (and the scanner) the
technique of the "parsing context" is convenient: a structure
containing all the data to exchange.  Since, in addition to simply
launch the parsing, there are several auxiliary tasks to execute (open
the file for parsing, instantiate the parser etc.), we recommend
transforming the simple parsing context structure into a fully blown
"parsing driver" class.

   The declaration of this driver class, `calc++-driver.hh', is as
follows.  The first part includes the CPP guard and imports the
required standard library components, and the declaration of the
parser class.

     #ifndef CALCXX_DRIVER_HH
     # define CALCXX_DRIVER_HH
     # include <string>
     # include <map>
     # include "calc++-parser.hh"

Then comes the declaration of the scanning function.  Flex expects
the signature of `yylex' to be defined in the macro `YY_DECL', and
the C++ parser expects it to be declared.  We can factor both as
follows.

     // Tell Flex the lexer's prototype ...
     # define YY_DECL \
       yy::calcxx_parser::symbol_type yylex (calcxx_driver& driver)
     // ... and declare it for the parser's sake.
     YY_DECL;

The `calcxx_driver' class is then declared with its most obvious
members.

     // Conducting the whole scanning and parsing of Calc++.
     class calcxx_driver
     {
     public:
       calcxx_driver ();
       virtual ~calcxx_driver ();

       std::map<std::string, int> variables;

       int result;

To encapsulate the coordination with the Flex scanner, it is useful
to have member functions to open and close the scanning phase.

       // Handling the scanner.
       void scan_begin ();
       void scan_end ();
       bool trace_scanning;

Similarly for the parser itself.

       // Run the parser on file F.
       // Return 0 on success.
       int parse (const std::string& f);
       // The name of the file being parsed.
       // Used later to pass the file name to the location tracker.
       std::string file;
       // Whether parser traces should be generated.
       bool trace_parsing;

To demonstrate pure handling of parse errors, instead of simply
dumping them on the standard error output, we will pass them to the
compiler driver using the following two member functions.  Finally, we
close the class declaration and CPP guard.

       // Error handling.
       void error (const yy::location& l, const std::string& m);
       void error (const std::string& m);
     };
     #endif // ! CALCXX_DRIVER_HH

   The implementation of the driver is straightforward.  The `parse'
member function deserves some attention.  The `error' functions are
simple stubs, they should actually register the located error
messages and set error state.

     #include "calc++-driver.hh"
     #include "calc++-parser.hh"

     calcxx_driver::calcxx_driver ()
       : trace_scanning (false), trace_parsing (false)
     {
       variables["one"] = 1;
       variables["two"] = 2;
     }

     calcxx_driver::~calcxx_driver ()
     {
     }

     int
     calcxx_driver::parse (const std::string &f)
     {
       file = f;
       scan_begin ();
       yy::calcxx_parser parser (*this);
       parser.set_debug_level (trace_parsing);
       int res = parser.parse ();
       scan_end ();
       return res;
     }

     void
     calcxx_driver::error (const yy::location& l, const std::string& m)
     {
       std::cerr << l << ": " << m << std::endl;
     }

     void
     calcxx_driver::error (const std::string& m)
     {
       std::cerr << m << std::endl;
     }


File: bison.info,  Node: Calc++ Parser,  Next: Calc++ Scanner,  Prev: Calc++ Parsing Driver,  Up: A Complete C++ Example

10.1.6.3 Calc++ Parser
......................

The grammar file `calc++-parser.yy' starts by asking for the C++
deterministic parser skeleton, the creation of the parser header file,
and specifies the name of the parser class.  Because the C++ skeleton
changed several times, it is safer to require the version you designed
the grammar for.

     %skeleton "lalr1.cc" /* -*- C++ -*- */
     %require "3.0.2"
     %defines
     %define parser_class_name {calcxx_parser}

This example will use genuine C++ objects as semantic values,
therefore, we require the variant-based interface.  To make sure we
properly use it, we enable assertions.  To fully benefit from
type-safety and more natural definition of "symbol", we enable
`api.token.constructor'.

     %define api.token.constructor
     %define api.value.type variant
     %define parse.assert

Then come the declarations/inclusions needed by the semantic values.
Because the parser uses the parsing driver and reciprocally, both
would like to include the header of the other, which is, of course,
insane.  This mutual dependency will be broken using forward
declarations.  Because the driver's header needs detailed knowledge
about the parser class (in particular its inner types), it is the
parser's header which will use a forward declaration of the driver.
*Note %code Summary::.

     %code requires
     {
     # include <string>
     class calcxx_driver;
     }

The driver is passed by reference to the parser and to the scanner.
This provides a simple but effective pure interface, not relying on
global variables.

     // The parsing context.
     %param { calcxx_driver& driver }

Then we request location tracking, and initialize the first
location's file name.  Afterward new locations are computed
relatively to the previous locations: the file name will be
propagated.

     %locations
     %initial-action
     {
       // Initialize the initial location.
       @$.begin.filename = @$.end.filename = &driver.file;
     };

Use the following two directives to enable parser tracing and verbose
error messages.  However, verbose error messages can contain
incorrect information (*note LAC::).

     %define parse.trace
     %define parse.error verbose

The code between `%code {' and `}' is output in the `*.cc' file; it
needs detailed knowledge about the driver.

     %code
     {
     # include "calc++-driver.hh"
     }

The token numbered as 0 corresponds to end of file; the following line
allows for nicer error messages referring to "end of file" instead of
"$end".  Similarly user friendly names are provided for each symbol.
To avoid name clashes in the generated files (*note Calc++
Scanner::), prefix tokens with `TOK_' (*note api.token.prefix:
%define Summary.).

     %define api.token.prefix {TOK_}
     %token
       END  0  "end of file"
       ASSIGN  ":="
       MINUS   "-"
       PLUS    "+"
       STAR    "*"
       SLASH   "/"
       LPAREN  "("
       RPAREN  ")"
     ;

Since we use variant-based semantic values, `%union' is not used, and
both `%type' and `%token' expect genuine types, as opposed to type
tags.

     %token <std::string> IDENTIFIER "identifier"
     %token <int> NUMBER "number"
     %type  <int> exp

No `%destructor' is needed to enable memory deallocation during error
recovery; the memory, for strings for instance, will be reclaimed by
the regular destructors.  All the values are printed using their
`operator<<' (*note Printing Semantic Values: Printer Decl.).

     %printer { yyoutput << $$; } <*>;

The grammar itself is straightforward (*note Location Tracking
Calculator: `ltcalc': Location Tracking Calc.).

     %%
     %start unit;
     unit: assignments exp  { driver.result = $2; };

     assignments:
       %empty                 {}
     | assignments assignment {};

     assignment:
       "identifier" ":=" exp { driver.variables[$1] = $3; };

     %left "+" "-";
     %left "*" "/";
     exp:
       exp "+" exp   { $$ = $1 + $3; }
     | exp "-" exp   { $$ = $1 - $3; }
     | exp "*" exp   { $$ = $1 * $3; }
     | exp "/" exp   { $$ = $1 / $3; }
     | "(" exp ")"   { std::swap ($$, $2); }
     | "identifier"  { $$ = driver.variables[$1]; }
     | "number"      { std::swap ($$, $1); };
     %%

Finally the `error' member function registers the errors to the
driver.

     void
     yy::calcxx_parser::error (const location_type& l,
                               const std::string& m)
     {
       driver.error (l, m);
     }


File: bison.info,  Node: Calc++ Scanner,  Next: Calc++ Top Level,  Prev: Calc++ Parser,  Up: A Complete C++ Example

10.1.6.4 Calc++ Scanner
.......................

The Flex scanner first includes the driver declaration, then the
parser's to get the set of defined tokens.

     %{ /* -*- C++ -*- */
     # include <cerrno>
     # include <climits>
     # include <cstdlib>
     # include <string>
     # include "calc++-driver.hh"
     # include "calc++-parser.hh"

     // Work around an incompatibility in flex (at least versions
     // 2.5.31 through 2.5.33): it generates code that does
     // not conform to C89.  See Debian bug 333231
     // <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.
     # undef yywrap
     # define yywrap() 1

     // The location of the current token.
     static yy::location loc;
     %}

Because there is no `#include'-like feature we don't need `yywrap',
we don't need `unput' either, and we parse an actual file, this is
not an interactive session with the user.  Finally, we enable scanner
tracing.

     %option noyywrap nounput batch debug noinput

Abbreviations allow for more readable rules.

     id    [a-zA-Z][a-zA-Z_0-9]*
     int   [0-9]+
     blank [ \t]

The following paragraph suffices to track locations accurately.  Each
time `yylex' is invoked, the begin position is moved onto the end
position.  Then when a pattern is matched, its width is added to the
end column.  When matching ends of lines, the end cursor is adjusted,
and each time blanks are matched, the begin cursor is moved onto the
end cursor to effectively ignore the blanks preceding tokens.
Comments would be treated equally.

     %{
       // Code run each time a pattern is matched.
       # define YY_USER_ACTION  loc.columns (yyleng);
     %}
     %%
     %{
       // Code run each time yylex is called.
       loc.step ();
     %}
     {blank}+   loc.step ();
     [\n]+      loc.lines (yyleng); loc.step ();

The rules are simple.  The driver is used to report errors.

     "-"      return yy::calcxx_parser::make_MINUS(loc);
     "+"      return yy::calcxx_parser::make_PLUS(loc);
     "*"      return yy::calcxx_parser::make_STAR(loc);
     "/"      return yy::calcxx_parser::make_SLASH(loc);
     "("      return yy::calcxx_parser::make_LPAREN(loc);
     ")"      return yy::calcxx_parser::make_RPAREN(loc);
     ":="     return yy::calcxx_parser::make_ASSIGN(loc);

     {int}      {
       errno = 0;
       long n = strtol (yytext, NULL, 10);
       if (! (INT_MIN <= n && n <= INT_MAX && errno != ERANGE))
         driver.error (loc, "integer is out of range");
       return yy::calcxx_parser::make_NUMBER(n, loc);
     }
     {id}       return yy::calcxx_parser::make_IDENTIFIER(yytext, loc);
     .          driver.error (loc, "invalid character");
     <<EOF>>    return yy::calcxx_parser::make_END(loc);
     %%

Finally, because the scanner-related driver's member-functions depend
on the scanner's data, it is simpler to implement them in this file.

     void
     calcxx_driver::scan_begin ()
     {
       yy_flex_debug = trace_scanning;
       if (file.empty () || file == "-")
         yyin = stdin;
       else if (!(yyin = fopen (file.c_str (), "r")))
         {
           error ("cannot open " + file + ": " + strerror(errno));
           exit (EXIT_FAILURE);
         }
     }

     void
     calcxx_driver::scan_end ()
     {
       fclose (yyin);
     }


File: bison.info,  Node: Calc++ Top Level,  Prev: Calc++ Scanner,  Up: A Complete C++ Example

10.1.6.5 Calc++ Top Level
.........................

The top level file, `calc++.cc', poses no problem.

     #include <iostream>
     #include "calc++-driver.hh"

     int
     main (int argc, char *argv[])
     {
       int res = 0;
       calcxx_driver driver;
       for (int i = 1; i < argc; ++i)
         if (argv[i] == std::string ("-p"))
           driver.trace_parsing = true;
         else if (argv[i] == std::string ("-s"))
           driver.trace_scanning = true;
         else if (!driver.parse (argv[i]))
           std::cout << driver.result << std::endl;
         else
           res = 1;
       return res;
     }


File: bison.info,  Node: Java Parsers,  Prev: C++ Parsers,  Up: Other Languages

10.2 Java Parsers
=================

* Menu:

* Java Bison Interface::        Asking for Java parser generation
* Java Semantic Values::        %type and %token vs. Java
* Java Location Values::        The position and location classes
* Java Parser Interface::       Instantiating and running the parser
* Java Scanner Interface::      Specifying the scanner for the parser
* Java Action Features::        Special features for use in actions
* Java Push Parser Interface::  Instantiating and running the a push parser
* Java Differences::            Differences between C/C++ and Java Grammars
* Java Declarations Summary::   List of Bison declarations used with Java


File: bison.info,  Node: Java Bison Interface,  Next: Java Semantic Values,  Up: Java Parsers

10.2.1 Java Bison Interface
---------------------------

(The current Java interface is experimental and may evolve.  More
user feedback will help to stabilize it.)

   The Java parser skeletons are selected using the `%language "Java"'
directive or the `-L java'/`--language=java' option.

   When generating a Java parser, `bison BASENAME.y' will create a
single Java source file named `BASENAME.java' containing the parser
implementation.  Using a grammar file without a `.y' suffix is
currently broken.  The basename of the parser implementation file can
be changed by the `%file-prefix' directive or the
`-p'/`--name-prefix' option.  The entire parser implementation file
name can be changed by the `%output' directive or the `-o'/`--output'
option.  The parser implementation file contains a single class for
the parser.

   You can create documentation for generated parsers using Javadoc.

   Contrary to C parsers, Java parsers do not use global variables;
the state of the parser is always local to an instance of the parser
class.  Therefore, all Java parsers are "pure", and the `%pure-parser'
and `%define api.pure' directives do nothing when used in Java.

   Push parsers are currently unsupported in Java and `%define
api.push-pull' have no effect.

   GLR parsers are currently unsupported in Java.  Do not use the
`glr-parser' directive.

   No header file can be generated for Java parsers.  Do not use the
`%defines' directive or the `-d'/`--defines' options.

   Currently, support for tracing is always compiled in.  Thus the
`%define parse.trace' and `%token-table' directives and the
`-t'/`--debug' and `-k'/`--token-table' options have no effect.  This
may change in the future to eliminate unused code in the generated
parser, so use `%define parse.trace' explicitly if needed.  Also, in
the future the `%token-table' directive might enable a public
interface to access the token names and codes.

   Getting a "code too large" error from the Java compiler means the
code hit the 64KB bytecode per method limitation of the Java class
file.  Try reducing the amount of code in actions and static
initializers; otherwise, report a bug so that the parser skeleton
will be improved.


File: bison.info,  Node: Java Semantic Values,  Next: Java Location Values,  Prev: Java Bison Interface,  Up: Java Parsers

10.2.2 Java Semantic Values
---------------------------

There is no `%union' directive in Java parsers.  Instead, the
semantic values' types (class names) should be specified in the
`%type' or `%token' directive:

     %type <Expression> expr assignment_expr term factor
     %type <Integer> number

   By default, the semantic stack is declared to have `Object'
members, which means that the class types you specify can be of any
class.  To improve the type safety of the parser, you can declare the
common superclass of all the semantic values using the `%define
api.value.type' directive.  For example, after the following
declaration:

     %define api.value.type {ASTNode}

any `%type' or `%token' specifying a semantic type which is not a
subclass of ASTNode, will cause a compile-time error.

   Types used in the directives may be qualified with a package name.
Primitive data types are accepted for Java version 1.5 or later.  Note
that in this case the autoboxing feature of Java 1.5 will be used.
Generic types may not be used; this is due to a limitation in the
implementation of Bison, and may change in future releases.

   Java parsers do not support `%destructor', since the language
adopts garbage collection.  The parser will try to hold references to
semantic values for as little time as needed.

   Java parsers do not support `%printer', as `toString()' can be
used to print the semantic values.  This however may change (in a
backwards-compatible way) in future versions of Bison.


File: bison.info,  Node: Java Location Values,  Next: Java Parser Interface,  Prev: Java Semantic Values,  Up: Java Parsers

10.2.3 Java Location Values
---------------------------

When the directive `%locations' is used, the Java parser supports
location tracking, see *Note Tracking Locations::.  An auxiliary
user-defined class defines a "position", a single point in a file;
Bison itself defines a class representing a "location", a range
composed of a pair of positions (possibly spanning several files).
The location class is an inner class of the parser; the name is
`Location' by default, and may also be renamed using `%define
api.location.type {CLASS-NAME}'.

   The location class treats the position as a completely opaque
value.  By default, the class name is `Position', but this can be
changed with `%define api.position.type {CLASS-NAME}'.  This class
must be supplied by the user.

 -- Instance Variable of Location: Position begin
 -- Instance Variable of Location: Position end
     The first, inclusive, position of the range, and the first
     beyond.

 -- Constructor on Location:  Location (Position LOC)
     Create a `Location' denoting an empty range located at a given
     point.

 -- Constructor on Location:  Location (Position BEGIN, Position END)
     Create a `Location' from the endpoints of the range.

 -- Method on Location: String toString ()
     Prints the range represented by the location.  For this to work
     properly, the position class should override the `equals' and
     `toString' methods appropriately.


File: bison.info,  Node: Java Parser Interface,  Next: Java Scanner Interface,  Prev: Java Location Values,  Up: Java Parsers

10.2.4 Java Parser Interface
----------------------------

The name of the generated parser class defaults to `YYParser'.  The
`YY' prefix may be changed using the `%name-prefix' directive or the
`-p'/`--name-prefix' option.  Alternatively, use `%define
parser_class_name {NAME}' to give a custom name to the class.  The
interface of this class is detailed below.

   By default, the parser class has package visibility.  A declaration
`%define public' will change to public visibility.  Remember that,
according to the Java language specification, the name of the `.java'
file should match the name of the class in this case.  Similarly, you
can use `abstract', `final' and `strictfp' with the `%define'
declaration to add other modifiers to the parser class.  A single
`%define annotations {ANNOTATIONS}' directive can be used to add any
number of annotations to the parser class.

   The Java package name of the parser class can be specified using
the `%define package' directive.  The superclass and the implemented
interfaces of the parser class can be specified with the `%define
extends' and `%define implements' directives.

   The parser class defines an inner class, `Location', that is used
for location tracking (see *Note Java Location Values::), and a inner
interface, `Lexer' (see *Note Java Scanner Interface::).  Other than
these inner class/interface, and the members described in the
interface below, all the other members and fields are preceded with a
`yy' or `YY' prefix to avoid clashes with user code.

   The parser class can be extended using the `%parse-param'
directive. Each occurrence of the directive will add a `protected
final' field to the parser class, and an argument to its constructor,
which initialize them automatically.

 -- Constructor on YYParser:  YYParser (LEX_PARAM, ..., PARSE_PARAM,
          ...)
     Build a new parser object with embedded `%code lexer'.  There are
     no parameters, unless `%param's and/or `%parse-param's and/or
     `%lex-param's are used.

     Use `%code init' for code added to the start of the constructor
     body. This is especially useful to initialize superclasses. Use
     `%define init_throws' to specify any uncaught exceptions.

 -- Constructor on YYParser:  YYParser (Lexer LEXER, PARSE_PARAM, ...)
     Build a new parser object using the specified scanner.  There
     are no additional parameters unless `%param's and/or
     `%parse-param's are used.

     If the scanner is defined by `%code lexer', this constructor is
     declared `protected' and is called automatically with a scanner
     created with the correct `%param's and/or `%lex-param's.

     Use `%code init' for code added to the start of the constructor
     body. This is especially useful to initialize superclasses. Use
     `%define init_throws' to specify any uncaught exceptions.

 -- Method on YYParser: boolean parse ()
     Run the syntactic analysis, and return `true' on success,
     `false' otherwise.

 -- Method on YYParser: boolean getErrorVerbose ()
 -- Method on YYParser: void setErrorVerbose (boolean VERBOSE)
     Get or set the option to produce verbose error messages.  These
     are only available with `%define parse.error verbose', which
     also turns on verbose error messages.

 -- Method on YYParser: void yyerror (String MSG)
 -- Method on YYParser: void yyerror (Position POS, String MSG)
 -- Method on YYParser: void yyerror (Location LOC, String MSG)
     Print an error message using the `yyerror' method of the scanner
     instance in use. The `Location' and `Position' parameters are
     available only if location tracking is active.

 -- Method on YYParser: boolean recovering ()
     During the syntactic analysis, return `true' if recovering from
     a syntax error.  *Note Error Recovery::.

 -- Method on YYParser: java.io.PrintStream getDebugStream ()
 -- Method on YYParser: void setDebugStream (java.io.printStream O)
     Get or set the stream used for tracing the parsing.  It defaults
     to `System.err'.

 -- Method on YYParser: int getDebugLevel ()
 -- Method on YYParser: void setDebugLevel (int L)
     Get or set the tracing level.  Currently its value is either 0,
     no trace, or nonzero, full tracing.

 -- Constant of YYParser: String bisonVersion
 -- Constant of YYParser: String bisonSkeleton
     Identify the Bison version and skeleton used to generate this
     parser.


File: bison.info,  Node: Java Scanner Interface,  Next: Java Action Features,  Prev: Java Parser Interface,  Up: Java Parsers

10.2.5 Java Scanner Interface
-----------------------------

There are two possible ways to interface a Bison-generated Java parser
with a scanner: the scanner may be defined by `%code lexer', or
defined elsewhere.  In either case, the scanner has to implement the
`Lexer' inner interface of the parser class.  This interface also
contain constants for all user-defined token names and the predefined
`EOF' token.

   In the first case, the body of the scanner class is placed in
`%code lexer' blocks.  If you want to pass parameters from the parser
constructor to the scanner constructor, specify them with
`%lex-param'; they are passed before `%parse-param's to the
constructor.

   In the second case, the scanner has to implement the `Lexer'
interface, which is defined within the parser class (e.g.,
`YYParser.Lexer').  The constructor of the parser object will then
accept an object implementing the interface; `%lex-param' is not used
in this case.

   In both cases, the scanner has to implement the following methods.

 -- Method on Lexer: void yyerror (Location LOC, String MSG)
     This method is defined by the user to emit an error message.
     The first parameter is omitted if location tracking is not
     active.  Its type can be changed using `%define
     api.location.type {CLASS-NAME}'.

 -- Method on Lexer: int yylex ()
     Return the next token.  Its type is the return value, its
     semantic value and location are saved and returned by the their
     methods in the interface.

     Use `%define lex_throws' to specify any uncaught exceptions.
     Default is `java.io.IOException'.

 -- Method on Lexer: Position getStartPos ()
 -- Method on Lexer: Position getEndPos ()
     Return respectively the first position of the last token that
     `yylex' returned, and the first position beyond it.  These
     methods are not needed unless location tracking is active.

     The return type can be changed using `%define api.position.type
     {CLASS-NAME}'.

 -- Method on Lexer: Object getLVal ()
     Return the semantic value of the last token that yylex returned.

     The return type can be changed using `%define api.value.type
     {CLASS-NAME}'.


File: bison.info,  Node: Java Action Features,  Next: Java Push Parser Interface,  Prev: Java Scanner Interface,  Up: Java Parsers

10.2.6 Special Features for Use in Java Actions
-----------------------------------------------

The following special constructs can be uses in Java actions.  Other
analogous C action features are currently unavailable for Java.

   Use `%define throws' to specify any uncaught exceptions from parser
actions, and initial actions specified by `%initial-action'.

 -- Variable: $N
     The semantic value for the Nth component of the current rule.
     This may not be assigned to.  *Note Java Semantic Values::.

 -- Variable: $<TYPEALT>N
     Like `$N' but specifies a alternative type TYPEALT.  *Note Java
     Semantic Values::.

 -- Variable: $$
     The semantic value for the grouping made by the current rule.
     As a value, this is in the base type (`Object' or as specified by
     `%define api.value.type') as in not cast to the declared subtype
     because casts are not allowed on the left-hand side of Java
     assignments.  Use an explicit Java cast if the correct subtype
     is needed.  *Note Java Semantic Values::.

 -- Variable: $<TYPEALT>$
     Same as `$$' since Java always allow assigning to the base type.
     Perhaps we should use this and `$<>$' for the value and `$$' for
     setting the value but there is currently no easy way to
     distinguish these constructs.  *Note Java Semantic Values::.

 -- Variable: @N
     The location information of the Nth component of the current
     rule.  This may not be assigned to.  *Note Java Location
     Values::.

 -- Variable: @$
     The location information of the grouping made by the current
     rule.  *Note Java Location Values::.

 -- Statement: return YYABORT `;'
     Return immediately from the parser, indicating failure.  *Note
     Java Parser Interface::.

 -- Statement: return YYACCEPT `;'
     Return immediately from the parser, indicating success.  *Note
     Java Parser Interface::.

 -- Statement: return YYERROR `;'
     Start error recovery (without printing an error message).  *Note
     Error Recovery::.

 -- Function: boolean recovering ()
     Return whether error recovery is being done. In this state, the
     parser reads token until it reaches a known state, and then
     restarts normal operation.  *Note Error Recovery::.

 -- Function: void yyerror (String MSG)
 -- Function: void yyerror (Position LOC, String MSG)
 -- Function: void yyerror (Location LOC, String MSG)
     Print an error message using the `yyerror' method of the scanner
     instance in use. The `Location' and `Position' parameters are
     available only if location tracking is active.


File: bison.info,  Node: Java Push Parser Interface,  Next: Java Differences,  Prev: Java Action Features,  Up: Java Parsers

10.2.7 Java Push Parser Interface
---------------------------------

(The current push parsing interface is experimental and may evolve.
More user feedback will help to stabilize it.)

   Normally, Bison generates a pull parser for Java.  The following
Bison declaration says that you want the parser to be a push parser
(*note api.push-pull: %define Summary.):

     %define api.push-pull push

   Most of the discussion about the Java pull Parser Interface,
(*note Java Parser Interface::) applies to the push parser interface
as well.

   When generating a push parser, the method `push_parse' is created
with the following signature (depending on if locations are enabled).

 -- Method on YYParser: void push_parse (int TOKEN, Object YYLVAL)
 -- Method on YYParser: void push_parse (int TOKEN, Object YYLVAL,
          Location YYLOC)
 -- Method on YYParser: void push_parse (int TOKEN, Object YYLVAL,
          Position YYPOS)

   The primary difference with respect to a pull parser is that the
parser method `push_parse' is invoked repeatedly to parse each token.
This function is available if either the "%define api.push-pull
push" or "%define api.push-pull both" declaration is used (*note
api.push-pull: %define Summary.).  The `Location' and `Position'
parameters are available only if location tracking is active.

   The value returned by the `push_parse' method is one of the
following four constants: `YYABORT', `YYACCEPT', `YYERROR', or
`YYPUSH_MORE'.  This new value, `YYPUSH_MORE', may be returned if
more input is required to finish parsing the grammar.

   If api.push-pull is declared as `both', then the generated parser
class will also implement the `parse' method. This method's body is a
loop that repeatedly invokes the scanner and then passes the values
obtained from the scanner to the `push_parse' method.

   There is one additional complication.  Technically, the push
parser does not need to know about the scanner (i.e. an object
implementing the `YYParser.Lexer' interface), but it does need access
to the `yyerror' method.  Currently, the `yyerror' method is defined
in the `YYParser.Lexer' interface. Hence, an implementation of that
interface is still required in order to provide an implementation of
`yyerror'.  The current approach (and subject to change) is to require
the `YYParser' constructor to be given an object implementing the
`YYParser.Lexer' interface. This object need only implement the
`yyerror' method; the other methods can be stubbed since they will
never be invoked.  The simplest way to do this is to add a trivial
scanner implementation to your grammar file using whatever
implementation of `yyerror' is desired. The following code sample
shows a simple way to accomplish this.

     %code lexer
     {
       public Object getLVal () {return null;}
       public int yylex () {return 0;}
       public void yyerror (String s) {System.err.println(s);}
     }


File: bison.info,  Node: Java Differences,  Next: Java Declarations Summary,  Prev: Java Push Parser Interface,  Up: Java Parsers

10.2.8 Differences between C/C++ and Java Grammars
--------------------------------------------------

The different structure of the Java language forces several
differences between C/C++ grammars, and grammars designed for Java
parsers.  This section summarizes these differences.

   * Java lacks a preprocessor, so the `YYERROR', `YYACCEPT',
     `YYABORT' symbols (*note Table of Symbols::) cannot obviously be
     macros.  Instead, they should be preceded by `return' when they
     appear in an action.  The actual definition of these symbols is
     opaque to the Bison grammar, and it might change in the future.
     The only meaningful operation that you can do, is to return them.
     *Note Java Action Features::.

     Note that of these three symbols, only `YYACCEPT' and `YYABORT'
     will cause a return from the `yyparse' method(1).

   * Java lacks unions, so `%union' has no effect.  Instead, semantic
     values have a common base type: `Object' or as specified by
     `%define api.value.type'.  Angle brackets on `%token', `type',
     `$N' and `$$' specify subtypes rather than fields of an union.
     The type of `$$', even with angle brackets, is the base type
     since Java casts are not allow on the left-hand side of
     assignments.  Also, `$N' and `@N' are not allowed on the
     left-hand side of assignments. *Note Java Semantic Values::, and
     *Note Java Action Features::.

   * The prologue declarations have a different meaning than in C/C++
     code.
    `%code imports'
          blocks are placed at the beginning of the Java source code.
          They may include copyright notices.  For a `package'
          declarations, it is suggested to use `%define package'
          instead.

    unqualified `%code'
          blocks are placed inside the parser class.

    `%code lexer'
          blocks, if specified, should include the implementation of
          the scanner.  If there is no such block, the scanner can be
          any class that implements the appropriate interface (*note
          Java Scanner Interface::).

     Other `%code' blocks are not supported in Java parsers.  In
     particular, `%{ ... %}' blocks should not be used and may give
     an error in future versions of Bison.

     The epilogue has the same meaning as in C/C++ code and it can be
     used to define other classes used by the parser _outside_ the
     parser class.

   ---------- Footnotes ----------

   (1) Java parsers include the actions in a separate method than
`yyparse' in order to have an intuitive syntax that corresponds to
these C macros.


File: bison.info,  Node: Java Declarations Summary,  Prev: Java Differences,  Up: Java Parsers

10.2.9 Java Declarations Summary
--------------------------------

This summary only include declarations specific to Java or have
special meaning when used in a Java parser.

 -- Directive: %language "Java"
     Generate a Java class for the parser.

 -- Directive: %lex-param {TYPE NAME}
     A parameter for the lexer class defined by `%code lexer' _only_,
     added as parameters to the lexer constructor and the parser
     constructor that _creates_ a lexer.  Default is none.  *Note
     Java Scanner Interface::.

 -- Directive: %name-prefix "PREFIX"
     The prefix of the parser class name `PREFIXParser' if `%define
     parser_class_name' is not used.  Default is `YY'.  *Note Java
     Bison Interface::.

 -- Directive: %parse-param {TYPE NAME}
     A parameter for the parser class added as parameters to
     constructor(s) and as fields initialized by the constructor(s).
     Default is none.  *Note Java Parser Interface::.

 -- Directive: %token <TYPE> TOKEN ...
     Declare tokens.  Note that the angle brackets enclose a Java
     _type_.  *Note Java Semantic Values::.

 -- Directive: %type <TYPE> NONTERMINAL ...
     Declare the type of nonterminals.  Note that the angle brackets
     enclose a Java _type_.  *Note Java Semantic Values::.

 -- Directive: %code { CODE ... }
     Code appended to the inside of the parser class.  *Note Java
     Differences::.

 -- Directive: %code imports { CODE ... }
     Code inserted just after the `package' declaration.  *Note Java
     Differences::.

 -- Directive: %code init { CODE ... }
     Code inserted at the beginning of the parser constructor body.
     *Note Java Parser Interface::.

 -- Directive: %code lexer { CODE ... }
     Code added to the body of a inner lexer class within the parser
     class.  *Note Java Scanner Interface::.

 -- Directive: %% CODE ...
     Code (after the second `%%') appended to the end of the file,
     _outside_ the parser class.  *Note Java Differences::.

 -- Directive: %{ CODE ... %}
     Not supported.  Use `%code imports' instead.  *Note Java
     Differences::.

 -- Directive: %define abstract
     Whether the parser class is declared `abstract'.  Default is
     false.  *Note Java Bison Interface::.

 -- Directive: %define annotations {ANNOTATIONS}
     The Java annotations for the parser class.  Default is none.
     *Note Java Bison Interface::.

 -- Directive: %define extends {SUPERCLASS}
     The superclass of the parser class.  Default is none.  *Note
     Java Bison Interface::.

 -- Directive: %define final
     Whether the parser class is declared `final'.  Default is false.
     *Note Java Bison Interface::.

 -- Directive: %define implements {INTERFACES}
     The implemented interfaces of the parser class, a
     comma-separated list.  Default is none.  *Note Java Bison
     Interface::.

 -- Directive: %define init_throws {EXCEPTIONS}
     The exceptions thrown by `%code init' from the parser class
     constructor.  Default is none.  *Note Java Parser Interface::.

 -- Directive: %define lex_throws {EXCEPTIONS}
     The exceptions thrown by the `yylex' method of the lexer, a
     comma-separated list.  Default is `java.io.IOException'.  *Note
     Java Scanner Interface::.

 -- Directive: %define api.location.type {CLASS}
     The name of the class used for locations (a range between two
     positions).  This class is generated as an inner class of the
     parser class by `bison'.  Default is `Location'.  Formerly named
     `location_type'.  *Note Java Location Values::.

 -- Directive: %define package {PACKAGE}
     The package to put the parser class in.  Default is none.  *Note
     Java Bison Interface::.

 -- Directive: %define parser_class_name {NAME}
     The name of the parser class.  Default is `YYParser' or
     `NAME-PREFIXParser'.  *Note Java Bison Interface::.

 -- Directive: %define api.position.type {CLASS}
     The name of the class used for positions. This class must be
     supplied by the user.  Default is `Position'.  Formerly named
     `position_type'.  *Note Java Location Values::.

 -- Directive: %define public
     Whether the parser class is declared `public'.  Default is false.
     *Note Java Bison Interface::.

 -- Directive: %define api.value.type {CLASS}
     The base type of semantic values.  Default is `Object'.  *Note
     Java Semantic Values::.

 -- Directive: %define strictfp
     Whether the parser class is declared `strictfp'.  Default is
     false.  *Note Java Bison Interface::.

 -- Directive: %define throws {EXCEPTIONS}
     The exceptions thrown by user-supplied parser actions and
     `%initial-action', a comma-separated list.  Default is none.
     *Note Java Parser Interface::.


File: bison.info,  Node: FAQ,  Next: Table of Symbols,  Prev: Other Languages,  Up: Top

11 Frequently Asked Questions
*****************************

Several questions about Bison come up occasionally.  Here some of them
are addressed.

* Menu:

* Memory Exhausted::            Breaking the Stack Limits
* How Can I Reset the Parser::  `yyparse' Keeps some State
* Strings are Destroyed::       `yylval' Loses Track of Strings
* Implementing Gotos/Loops::    Control Flow in the Calculator
* Multiple start-symbols::      Factoring closely related grammars
* Secure?  Conform?::           Is Bison POSIX safe?
* I can't build Bison::         Troubleshooting
* Where can I find help?::      Troubleshouting
* Bug Reports::                 Troublereporting
* More Languages::              Parsers in C++, Java, and so on
* Beta Testing::                Experimenting development versions
* Mailing Lists::               Meeting other Bison users


File: bison.info,  Node: Memory Exhausted,  Next: How Can I Reset the Parser,  Up: FAQ

11.1 Memory Exhausted
=====================

     My parser returns with error with a `memory exhausted' message.
     What can I do?

   This question is already addressed elsewhere, see *Note Recursive
Rules: Recursion.


File: bison.info,  Node: How Can I Reset the Parser,  Next: Strings are Destroyed,  Prev: Memory Exhausted,  Up: FAQ

11.2 How Can I Reset the Parser
===============================

The following phenomenon has several symptoms, resulting in the
following typical questions:

     I invoke `yyparse' several times, and on correct input it works
     properly; but when a parse error is found, all the other calls
     fail too.  How can I reset the error flag of `yyparse'?

or

     My parser includes support for an `#include'-like feature, in
     which case I run `yyparse' from `yyparse'.  This fails although
     I did specify `%define api.pure full'.

   These problems typically come not from Bison itself, but from
Lex-generated scanners.  Because these scanners use large buffers for
speed, they might not notice a change of input file.  As a
demonstration, consider the following source file, `first-line.l':

     %{
     #include <stdio.h>
     #include <stdlib.h>
     %}
     %%
     .*\n    ECHO; return 1;
     %%
     int
     yyparse (char const *file)
     {
       yyin = fopen (file, "r");
       if (!yyin)
         {
           perror ("fopen");
           exit (EXIT_FAILURE);
         }
       /* One token only.  */
       yylex ();
       if (fclose (yyin) != 0)
         {
           perror ("fclose");
           exit (EXIT_FAILURE);
         }
       return 0;
     }

     int
     main (void)
     {
       yyparse ("input");
       yyparse ("input");
       return 0;
     }

If the file `input' contains

     input:1: Hello,
     input:2: World!

then instead of getting the first line twice, you get:

     $ flex -ofirst-line.c first-line.l
     $ gcc  -ofirst-line   first-line.c -ll
     $ ./first-line
     input:1: Hello,
     input:2: World!

   Therefore, whenever you change `yyin', you must tell the
Lex-generated scanner to discard its current buffer and switch to the
new one.  This depends upon your implementation of Lex; see its
documentation for more.  For Flex, it suffices to call
`YY_FLUSH_BUFFER' after each change to `yyin'.  If your
Flex-generated scanner needs to read from several input streams to
handle features like include files, you might consider using Flex
functions like `yy_switch_to_buffer' that manipulate multiple input
buffers.

   If your Flex-generated scanner uses start conditions (*note Start
conditions: (flex)Start conditions.), you might also want to reset
the scanner's state, i.e., go back to the initial start condition,
through a call to `BEGIN (0)'.


File: bison.info,  Node: Strings are Destroyed,  Next: Implementing Gotos/Loops,  Prev: How Can I Reset the Parser,  Up: FAQ

11.3 Strings are Destroyed
==========================

     My parser seems to destroy old strings, or maybe it loses track
     of them.  Instead of reporting `"foo", "bar"', it reports
     `"bar", "bar"', or even `"foo\nbar", "bar"'.

   This error is probably the single most frequent "bug report" sent
to Bison lists, but is only concerned with a misunderstanding of the
role of the scanner.  Consider the following Lex code:

     %{
     #include <stdio.h>
     char *yylval = NULL;
     %}
     %%
     .*    yylval = yytext; return 1;
     \n    /* IGNORE */
     %%
     int
     main ()
     {
       /* Similar to using $1, $2 in a Bison action.  */
       char *fst = (yylex (), yylval);
       char *snd = (yylex (), yylval);
       printf ("\"%s\", \"%s\"\n", fst, snd);
       return 0;
     }

   If you compile and run this code, you get:

     $ flex -osplit-lines.c split-lines.l
     $ gcc  -osplit-lines   split-lines.c -ll
     $ printf 'one\ntwo\n' | ./split-lines
     "one
     two", "two"

this is because `yytext' is a buffer provided for _reading_ in the
action, but if you want to keep it, you have to duplicate it (e.g.,
using `strdup').  Note that the output may depend on how your
implementation of Lex handles `yytext'.  For instance, when given the
Lex compatibility option `-l' (which triggers the option `%array')
Flex generates a different behavior:

     $ flex -l -osplit-lines.c split-lines.l
     $ gcc     -osplit-lines   split-lines.c -ll
     $ printf 'one\ntwo\n' | ./split-lines
     "two", "two"


File: bison.info,  Node: Implementing Gotos/Loops,  Next: Multiple start-symbols,  Prev: Strings are Destroyed,  Up: FAQ

11.4 Implementing Gotos/Loops
=============================

     My simple calculator supports variables, assignments, and
     functions, but how can I implement gotos, or loops?

   Although very pedagogical, the examples included in the document
blur the distinction to make between the parser--whose job is to
recover the structure of a text and to transmit it to subsequent
modules of the program--and the processing (such as the execution) of
this structure.  This works well with so called straight line
programs, i.e., precisely those that have a straightforward execution
model: execute simple instructions one after the others.

   If you want a richer model, you will probably need to use the
parser to construct a tree that does represent the structure it has
recovered; this tree is usually called the "abstract syntax tree", or
"AST" for short.  Then, walking through this tree, traversing it in
various ways, will enable treatments such as its execution or its
translation, which will result in an interpreter or a compiler.

   This topic is way beyond the scope of this manual, and the reader
is invited to consult the dedicated literature.


File: bison.info,  Node: Multiple start-symbols,  Next: Secure? Conform?,  Prev: Implementing Gotos/Loops,  Up: FAQ

11.5 Multiple start-symbols
===========================

     I have several closely related grammars, and I would like to
     share their implementations.  In fact, I could use a single
     grammar but with multiple entry points.

   Bison does not support multiple start-symbols, but there is a very
simple means to simulate them.  If `foo' and `bar' are the two pseudo
start-symbols, then introduce two new tokens, say `START_FOO' and
`START_BAR', and use them as switches from the real start-symbol:

     %token START_FOO START_BAR;
     %start start;
     start:
       START_FOO foo
     | START_BAR bar;

   These tokens prevents the introduction of new conflicts.  As far
as the parser goes, that is all that is needed.

   Now the difficult part is ensuring that the scanner will send these
tokens first.  If your scanner is hand-written, that should be
straightforward.  If your scanner is generated by Lex, them there is
simple means to do it: recall that anything between `%{ ... %}' after
the first `%%' is copied verbatim in the top of the generated `yylex'
function.  Make sure a variable `start_token' is available in the
scanner (e.g., a global variable or using `%lex-param' etc.), and use
the following:

       /* Prologue.  */
     %%
     %{
       if (start_token)
         {
           int t = start_token;
           start_token = 0;
           return t;
         }
     %}
       /* The rules.  */


File: bison.info,  Node: Secure? Conform?,  Next: I can't build Bison,  Prev: Multiple start-symbols,  Up: FAQ

11.6 Secure?  Conform?
======================

     Is Bison secure?  Does it conform to POSIX?

   If you're looking for a guarantee or certification, we don't
provide it.  However, Bison is intended to be a reliable program that
conforms to the POSIX specification for Yacc.  If you run into
problems, please send us a bug report.


File: bison.info,  Node: I can't build Bison,  Next: Where can I find help?,  Prev: Secure? Conform?,  Up: FAQ

11.7 I can't build Bison
========================

     I can't build Bison because `make' complains that `msgfmt' is
     not found.  What should I do?

   Like most GNU packages with internationalization support, that
feature is turned on by default.  If you have problems building in
the `po' subdirectory, it indicates that your system's
internationalization support is lacking.  You can re-configure Bison
with `--disable-nls' to turn off this support, or you can install GNU
gettext from `ftp://ftp.gnu.org/gnu/gettext/' and re-configure Bison.
See the file `ABOUT-NLS' for more information.


File: bison.info,  Node: Where can I find help?,  Next: Bug Reports,  Prev: I can't build Bison,  Up: FAQ

11.8 Where can I find help?
===========================

     I'm having trouble using Bison.  Where can I find help?

   First, read this fine manual.  Beyond that, you can send mail to
<help-bison@gnu.org>.  This mailing list is intended to be populated
with people who are willing to answer questions about using and
installing Bison.  Please keep in mind that (most of) the people on
the list have aspects of their lives which are not related to Bison
(!), so you may not receive an answer to your question right away.
This can be frustrating, but please try not to honk them off;
remember that any help they provide is purely voluntary and out of
the kindness of their hearts.


File: bison.info,  Node: Bug Reports,  Next: More Languages,  Prev: Where can I find help?,  Up: FAQ

11.9 Bug Reports
================

     I found a bug.  What should I include in the bug report?

   Before you send a bug report, make sure you are using the latest
version.  Check `ftp://ftp.gnu.org/pub/gnu/bison/' or one of its
mirrors.  Be sure to include the version number in your bug report.
If the bug is present in the latest version but not in a previous
version, try to determine the most recent version which did not
contain the bug.

   If the bug is parser-related, you should include the smallest
grammar you can which demonstrates the bug.  The grammar file should
also be complete (i.e., I should be able to run it through Bison
without having to edit or add anything).  The smaller and simpler the
grammar, the easier it will be to fix the bug.

   Include information about your compilation environment, including
your operating system's name and version and your compiler's name and
version.  If you have trouble compiling, you should also include a
transcript of the build session, starting with the invocation of
`configure'.  Depending on the nature of the bug, you may be asked to
send additional files as well (such as `config.h' or `config.cache').

   Patches are most welcome, but not required.  That is, do not
hesitate to send a bug report just because you cannot provide a fix.

   Send bug reports to <bug-bison@gnu.org>.


File: bison.info,  Node: More Languages,  Next: Beta Testing,  Prev: Bug Reports,  Up: FAQ

11.10 More Languages
====================

     Will Bison ever have C++ and Java support?  How about INSERT YOUR
     FAVORITE LANGUAGE HERE?

   C++ and Java support is there now, and is documented.  We'd love
to add other languages; contributions are welcome.


File: bison.info,  Node: Beta Testing,  Next: Mailing Lists,  Prev: More Languages,  Up: FAQ

11.11 Beta Testing
==================

     What is involved in being a beta tester?

   It's not terribly involved.  Basically, you would download a test
release, compile it, and use it to build and run a parser or two.
After that, you would submit either a bug report or a message saying
that everything is okay.  It is important to report successes as well
as failures because test releases eventually become mainstream
releases, but only if they are adequately tested.  If no one tests,
development is essentially halted.

   Beta testers are particularly needed for operating systems to
which the developers do not have easy access.  They currently have
easy access to recent GNU/Linux and Solaris versions.  Reports about
other operating systems are especially welcome.


File: bison.info,  Node: Mailing Lists,  Prev: Beta Testing,  Up: FAQ

11.12 Mailing Lists
===================

     How do I join the help-bison and bug-bison mailing lists?

   See `http://lists.gnu.org/'.


File: bison.info,  Node: Table of Symbols,  Next: Glossary,  Prev: FAQ,  Up: Top

Appendix A Bison Symbols
************************

 -- Variable: @$
     In an action, the location of the left-hand side of the rule.
     *Note Tracking Locations::.

 -- Variable: @N
 -- Symbol: @N
     In an action, the location of the N-th symbol of the right-hand
     side of the rule.  *Note Tracking Locations::.

     In a grammar, the Bison-generated nonterminal symbol for a
     mid-rule action with a semantical value.  *Note Mid-Rule Action
     Translation::.

 -- Variable: @NAME
 -- Variable: @[NAME]
     In an action, the location of a symbol addressed by NAME.  *Note
     Tracking Locations::.

 -- Symbol: $@N
     In a grammar, the Bison-generated nonterminal symbol for a
     mid-rule action with no semantical value.  *Note Mid-Rule Action
     Translation::.

 -- Variable: $$
     In an action, the semantic value of the left-hand side of the
     rule.  *Note Actions::.

 -- Variable: $N
     In an action, the semantic value of the N-th symbol of the
     right-hand side of the rule.  *Note Actions::.

 -- Variable: $NAME
 -- Variable: $[NAME]
     In an action, the semantic value of a symbol addressed by NAME.
     *Note Actions::.

 -- Delimiter: %%
     Delimiter used to separate the grammar rule section from the
     Bison declarations section or the epilogue.  *Note The Overall
     Layout of a Bison Grammar: Grammar Layout.

 -- Delimiter: %{CODE%}
     All code listed between `%{' and `%}' is copied verbatim to the
     parser implementation file.  Such code forms the prologue of the
     grammar file.  *Note Outline of a Bison Grammar: Grammar Outline.

 -- Directive: %?{EXPRESSION}
     Predicate actions.  This is a type of action clause that may
     appear in rules. The expression is evaluated, and if false,
     causes a syntax error.  In GLR parsers during nondeterministic
     operation, this silently causes an alternative parse to die.
     During deterministic operation, it is the same as the effect of
     YYERROR.  *Note Semantic Predicates::.

     This feature is experimental.  More user feedback will help to
     determine whether it should become a permanent feature.

 -- Construct: /* ... */
 -- Construct: // ...
     Comments, as in C/C++.

 -- Delimiter: :
     Separates a rule's result from its components.  *Note Syntax of
     Grammar Rules: Rules.

 -- Delimiter: ;
     Terminates a rule.  *Note Syntax of Grammar Rules: Rules.

 -- Delimiter: |
     Separates alternate rules for the same result nonterminal.
     *Note Syntax of Grammar Rules: Rules.

 -- Directive: <*>
     Used to define a default tagged `%destructor' or default tagged
     `%printer'.

     This feature is experimental.  More user feedback will help to
     determine whether it should become a permanent feature.

     *Note Freeing Discarded Symbols: Destructor Decl.

 -- Directive: <>
     Used to define a default tagless `%destructor' or default tagless
     `%printer'.

     This feature is experimental.  More user feedback will help to
     determine whether it should become a permanent feature.

     *Note Freeing Discarded Symbols: Destructor Decl.

 -- Symbol: $accept
     The predefined nonterminal whose only rule is `$accept: START
     $end', where START is the start symbol.  *Note The Start-Symbol:
     Start Decl.  It cannot be used in the grammar.

 -- Directive: %code {CODE}
 -- Directive: %code QUALIFIER {CODE}
     Insert CODE verbatim into the output parser source at the
     default location or at the location specified by QUALIFIER.
     *Note %code Summary::.

 -- Directive: %debug
     Equip the parser for debugging.  *Note Decl Summary::.

 -- Directive: %define VARIABLE
 -- Directive: %define VARIABLE VALUE
 -- Directive: %define VARIABLE {VALUE}
 -- Directive: %define VARIABLE "VALUE"
     Define a variable to adjust Bison's behavior.  *Note %define
     Summary::.

 -- Directive: %defines
     Bison declaration to create a parser header file, which is
     usually meant for the scanner.  *Note Decl Summary::.

 -- Directive: %defines DEFINES-FILE
     Same as above, but save in the file DEFINES-FILE.  *Note Decl
     Summary::.

 -- Directive: %destructor
     Specify how the parser should reclaim the memory associated to
     discarded symbols.  *Note Freeing Discarded Symbols: Destructor
     Decl.

 -- Directive: %dprec
     Bison declaration to assign a precedence to a rule that is used
     at parse time to resolve reduce/reduce conflicts.  *Note Writing
     GLR Parsers: GLR Parsers.

 -- Directive: %empty
     Bison declaration to declare make explicit that a rule has an
     empty right-hand side.  *Note Empty Rules::.

 -- Symbol: $end
     The predefined token marking the end of the token stream.  It
     cannot be used in the grammar.

 -- Symbol: error
     A token name reserved for error recovery.  This token may be
     used in grammar rules so as to allow the Bison parser to
     recognize an error in the grammar without halting the process.
     In effect, a sentence containing an error may be recognized as
     valid.  On a syntax error, the token `error' becomes the current
     lookahead token.  Actions corresponding to `error' are then
     executed, and the lookahead token is reset to the token that
     originally caused the violation.  *Note Error Recovery::.

 -- Directive: %error-verbose
     An obsolete directive standing for `%define parse.error verbose'
     (*note The Error Reporting Function `yyerror': Error Reporting.).

 -- Directive: %file-prefix "PREFIX"
     Bison declaration to set the prefix of the output files.  *Note
     Decl Summary::.

 -- Directive: %glr-parser
     Bison declaration to produce a GLR parser.  *Note Writing GLR
     Parsers: GLR Parsers.

 -- Directive: %initial-action
     Run user code before parsing.  *Note Performing Actions before
     Parsing: Initial Action Decl.

 -- Directive: %language
     Specify the programming language for the generated parser.
     *Note Decl Summary::.

 -- Directive: %left
     Bison declaration to assign precedence and left associativity to
     token(s).  *Note Operator Precedence: Precedence Decl.

 -- Directive: %lex-param {ARGUMENT-DECLARATION} ...
     Bison declaration to specifying additional arguments that
     `yylex' should accept.  *Note Calling Conventions for Pure
     Parsers: Pure Calling.

 -- Directive: %merge
     Bison declaration to assign a merging function to a rule.  If
     there is a reduce/reduce conflict with a rule having the same
     merging function, the function is applied to the two semantic
     values to get a single result.  *Note Writing GLR Parsers: GLR
     Parsers.

 -- Directive: %name-prefix "PREFIX"
     Obsoleted by the `%define' variable `api.prefix' (*note Multiple
     Parsers in the Same Program: Multiple Parsers.).

     Rename the external symbols (variables and functions) used in
     the parser so that they start with PREFIX instead of `yy'.
     Contrary to `api.prefix', do no rename types and macros.

     The precise list of symbols renamed in C parsers is `yyparse',
     `yylex', `yyerror', `yynerrs', `yylval', `yychar', `yydebug',
     and (if locations are used) `yylloc'.  If you use a push parser,
     `yypush_parse', `yypull_parse', `yypstate', `yypstate_new' and
     `yypstate_delete' will also be renamed.  For example, if you use
     `%name-prefix "c_"', the names become `c_parse', `c_lex', and so
     on.  For C++ parsers, see the `%define api.namespace'
     documentation in this section.

 -- Directive: %no-lines
     Bison declaration to avoid generating `#line' directives in the
     parser implementation file.  *Note Decl Summary::.

 -- Directive: %nonassoc
     Bison declaration to assign precedence and nonassociativity to
     token(s).  *Note Operator Precedence: Precedence Decl.

 -- Directive: %output "FILE"
     Bison declaration to set the name of the parser implementation
     file.  *Note Decl Summary::.

 -- Directive: %param {ARGUMENT-DECLARATION} ...
     Bison declaration to specify additional arguments that both
     `yylex' and `yyparse' should accept.  *Note The Parser Function
     `yyparse': Parser Function.

 -- Directive: %parse-param {ARGUMENT-DECLARATION} ...
     Bison declaration to specify additional arguments that `yyparse'
     should accept.  *Note The Parser Function `yyparse': Parser
     Function.

 -- Directive: %prec
     Bison declaration to assign a precedence to a specific rule.
     *Note Context-Dependent Precedence: Contextual Precedence.

 -- Directive: %precedence
     Bison declaration to assign precedence to token(s), but no
     associativity *Note Operator Precedence: Precedence Decl.

 -- Directive: %pure-parser
     Deprecated version of `%define api.pure' (*note api.pure:
     %define Summary.), for which Bison is more careful to warn about
     unreasonable usage.

 -- Directive: %require "VERSION"
     Require version VERSION or higher of Bison.  *Note Require a
     Version of Bison: Require Decl.

 -- Directive: %right
     Bison declaration to assign precedence and right associativity
     to token(s).  *Note Operator Precedence: Precedence Decl.

 -- Directive: %skeleton
     Specify the skeleton to use; usually for development.  *Note
     Decl Summary::.

 -- Directive: %start
     Bison declaration to specify the start symbol.  *Note The
     Start-Symbol: Start Decl.

 -- Directive: %token
     Bison declaration to declare token(s) without specifying
     precedence.  *Note Token Type Names: Token Decl.

 -- Directive: %token-table
     Bison declaration to include a token name table in the parser
     implementation file.  *Note Decl Summary::.

 -- Directive: %type
     Bison declaration to declare nonterminals.  *Note Nonterminal
     Symbols: Type Decl.

 -- Symbol: $undefined
     The predefined token onto which all undefined values returned by
     `yylex' are mapped.  It cannot be used in the grammar, rather,
     use `error'.

 -- Directive: %union
     Bison declaration to specify several possible data types for
     semantic values.  *Note The Union Declaration: Union Decl.

 -- Macro: YYABORT
     Macro to pretend that an unrecoverable syntax error has
     occurred, by making `yyparse' return 1 immediately.  The error
     reporting function `yyerror' is not called.  *Note The Parser
     Function `yyparse': Parser Function.

     For Java parsers, this functionality is invoked using `return
     YYABORT;' instead.

 -- Macro: YYACCEPT
     Macro to pretend that a complete utterance of the language has
     been read, by making `yyparse' return 0 immediately.  *Note The
     Parser Function `yyparse': Parser Function.

     For Java parsers, this functionality is invoked using `return
     YYACCEPT;' instead.

 -- Macro: YYBACKUP
     Macro to discard a value from the parser stack and fake a
     lookahead token.  *Note Special Features for Use in Actions:
     Action Features.

 -- Variable: yychar
     External integer variable that contains the integer value of the
     lookahead token.  (In a pure parser, it is a local variable
     within `yyparse'.)  Error-recovery rule actions may examine this
     variable.  *Note Special Features for Use in Actions: Action
     Features.

 -- Variable: yyclearin
     Macro used in error-recovery rule actions.  It clears the
     previous lookahead token.  *Note Error Recovery::.

 -- Macro: YYDEBUG
     Macro to define to equip the parser with tracing code.  *Note
     Tracing Your Parser: Tracing.

 -- Variable: yydebug
     External integer variable set to zero by default.  If `yydebug'
     is given a nonzero value, the parser will output information on
     input symbols and parser action.  *Note Tracing Your Parser:
     Tracing.

 -- Macro: yyerrok
     Macro to cause parser to recover immediately to its normal mode
     after a syntax error.  *Note Error Recovery::.

 -- Macro: YYERROR
     Cause an immediate syntax error.  This statement initiates error
     recovery just as if the parser itself had detected an error;
     however, it does not call `yyerror', and does not print any
     message.  If you want to print an error message, call `yyerror'
     explicitly before the `YYERROR;' statement.  *Note Error
     Recovery::.

     For Java parsers, this functionality is invoked using `return
     YYERROR;' instead.

 -- Function: yyerror
     User-supplied function to be called by `yyparse' on error.
     *Note The Error Reporting Function `yyerror': Error Reporting.

 -- Macro: YYERROR_VERBOSE
     An obsolete macro used in the `yacc.c' skeleton, that you define
     with `#define' in the prologue to request verbose, specific error
     message strings when `yyerror' is called.  It doesn't matter what
     definition you use for `YYERROR_VERBOSE', just whether you define
     it.  Using `%define parse.error verbose' is preferred (*note The
     Error Reporting Function `yyerror': Error Reporting.).

 -- Macro: YYFPRINTF
     Macro used to output run-time traces.  *Note Enabling Traces::.

 -- Macro: YYINITDEPTH
     Macro for specifying the initial size of the parser stack.
     *Note Memory Management::.

 -- Function: yylex
     User-supplied lexical analyzer function, called with no
     arguments to get the next token.  *Note The Lexical Analyzer
     Function `yylex': Lexical.

 -- Variable: yylloc
     External variable in which `yylex' should place the line and
     column numbers associated with a token.  (In a pure parser, it
     is a local variable within `yyparse', and its address is passed
     to `yylex'.)  You can ignore this variable if you don't use the
     `@' feature in the grammar actions.  *Note Textual Locations of
     Tokens: Token Locations.  In semantic actions, it stores the
     location of the lookahead token.  *Note Actions and Locations:
     Actions and Locations.

 -- Type: YYLTYPE
     Data type of `yylloc'; by default, a structure with four
     members.  *Note Data Types of Locations: Location Type.

 -- Variable: yylval
     External variable in which `yylex' should place the semantic
     value associated with a token.  (In a pure parser, it is a local
     variable within `yyparse', and its address is passed to `yylex'.)
     *Note Semantic Values of Tokens: Token Values.  In semantic
     actions, it stores the semantic value of the lookahead token.
     *Note Actions: Actions.

 -- Macro: YYMAXDEPTH
     Macro for specifying the maximum size of the parser stack.
     *Note Memory Management::.

 -- Variable: yynerrs
     Global variable which Bison increments each time it reports a
     syntax error.  (In a pure parser, it is a local variable within
     `yyparse'. In a pure push parser, it is a member of `yypstate'.)
     *Note The Error Reporting Function `yyerror': Error Reporting.

 -- Function: yyparse
     The parser function produced by Bison; call this function to
     start parsing.  *Note The Parser Function `yyparse': Parser
     Function.

 -- Macro: YYPRINT
     Macro used to output token semantic values.  For `yacc.c' only.
     Obsoleted by `%printer'.  *Note The `YYPRINT' Macro: The YYPRINT
     Macro.

 -- Function: yypstate_delete
     The function to delete a parser instance, produced by Bison in
     push mode; call this function to delete the memory associated
     with a parser.  *Note The Parser Delete Function
     `yypstate_delete': Parser Delete Function.  (The current push
     parsing interface is experimental and may evolve.  More user
     feedback will help to stabilize it.)

 -- Function: yypstate_new
     The function to create a parser instance, produced by Bison in
     push mode; call this function to create a new parser.  *Note The
     Parser Create Function `yypstate_new': Parser Create Function.
     (The current push parsing interface is experimental and may
     evolve.  More user feedback will help to stabilize it.)

 -- Function: yypull_parse
     The parser function produced by Bison in push mode; call this
     function to parse the rest of the input stream.  *Note The Pull
     Parser Function `yypull_parse': Pull Parser Function.  (The
     current push parsing interface is experimental and may evolve.
     More user feedback will help to stabilize it.)

 -- Function: yypush_parse
     The parser function produced by Bison in push mode; call this
     function to parse a single token.  *Note The Push Parser
     Function `yypush_parse': Push Parser Function.  (The current
     push parsing interface is experimental and may evolve.  More
     user feedback will help to stabilize it.)

 -- Macro: YYRECOVERING
     The expression `YYRECOVERING ()' yields 1 when the parser is
     recovering from a syntax error, and 0 otherwise.  *Note Special
     Features for Use in Actions: Action Features.

 -- Macro: YYSTACK_USE_ALLOCA
     Macro used to control the use of `alloca' when the deterministic
     parser in C needs to extend its stacks.  If defined to 0, the
     parser will use `malloc' to extend its stacks.  If defined to 1,
     the parser will use `alloca'.  Values other than 0 and 1 are
     reserved for future Bison extensions.  If not defined,
     `YYSTACK_USE_ALLOCA' defaults to 0.

     In the all-too-common case where your code may run on a host
     with a limited stack and with unreliable stack-overflow
     checking, you should set `YYMAXDEPTH' to a value that cannot
     possibly result in unchecked stack overflow on any of your
     target hosts when `alloca' is called.  You can inspect the code
     that Bison generates in order to determine the proper numeric
     values.  This will require some expertise in low-level
     implementation details.

 -- Type: YYSTYPE
     Deprecated in favor of the `%define' variable `api.value.type'.
     Data type of semantic values; `int' by default.  *Note Data
     Types of Semantic Values: Value Type.


File: bison.info,  Node: Glossary,  Next: Copying This Manual,  Prev: Table of Symbols,  Up: Top

Appendix B Glossary
*******************

Accepting state
     A state whose only action is the accept action.  The accepting
     state is thus a consistent state.  *Note Understanding Your
     Parser: Understanding.

Backus-Naur Form (BNF; also called "Backus Normal Form")
     Formal method of specifying context-free grammars originally
     proposed by John Backus, and slightly improved by Peter Naur in
     his 1960-01-02 committee document contributing to what became
     the Algol 60 report.  *Note Languages and Context-Free Grammars:
     Language and Grammar.

Consistent state
     A state containing only one possible action.  *Note Default
     Reductions::.

Context-free grammars
     Grammars specified as rules that can be applied regardless of
     context.  Thus, if there is a rule which says that an integer
     can be used as an expression, integers are allowed _anywhere_ an
     expression is permitted.  *Note Languages and Context-Free
     Grammars: Language and Grammar.

Default reduction
     The reduction that a parser should perform if the current parser
     state contains no other action for the lookahead token.  In
     permitted parser states, Bison declares the reduction with the
     largest lookahead set to be the default reduction and removes
     that lookahead set.  *Note Default Reductions::.

Defaulted state
     A consistent state with a default reduction.  *Note Default
     Reductions::.

Dynamic allocation
     Allocation of memory that occurs during execution, rather than at
     compile time or on entry to a function.

Empty string
     Analogous to the empty set in set theory, the empty string is a
     character string of length zero.

Finite-state stack machine
     A "machine" that has discrete states in which it is said to
     exist at each instant in time.  As input to the machine is
     processed, the machine moves from state to state as specified by
     the logic of the machine.  In the case of the parser, the input
     is the language being parsed, and the states correspond to
     various stages in the grammar rules.  *Note The Bison Parser
     Algorithm: Algorithm.

Generalized LR (GLR)
     A parsing algorithm that can handle all context-free grammars,
     including those that are not LR(1).  It resolves situations that
     Bison's deterministic parsing algorithm cannot by effectively
     splitting off multiple parsers, trying all possible parsers, and
     discarding those that fail in the light of additional right
     context.  *Note Generalized LR Parsing: Generalized LR Parsing.

Grouping
     A language construct that is (in general) grammatically
     divisible; for example, `expression' or `declaration' in C.
     *Note Languages and Context-Free Grammars: Language and Grammar.

IELR(1) (Inadequacy Elimination LR(1))
     A minimal LR(1) parser table construction algorithm.  That is,
     given any context-free grammar, IELR(1) generates parser tables
     with the full language-recognition power of canonical LR(1) but
     with nearly the same number of parser states as LALR(1).  This
     reduction in parser states is often an order of magnitude.  More
     importantly, because canonical LR(1)'s extra parser states may
     contain duplicate conflicts in the case of non-LR(1) grammars,
     the number of conflicts for IELR(1) is often an order of
     magnitude less as well.  This can significantly reduce the
     complexity of developing a grammar.  *Note LR Table
     Construction::.

Infix operator
     An arithmetic operator that is placed between the operands on
     which it performs some operation.

Input stream
     A continuous flow of data between devices or programs.

LAC (Lookahead Correction)
     A parsing mechanism that fixes the problem of delayed syntax
     error detection, which is caused by LR state merging, default
     reductions, and the use of `%nonassoc'.  Delayed syntax error
     detection results in unexpected semantic actions, initiation of
     error recovery in the wrong syntactic context, and an incorrect
     list of expected tokens in a verbose syntax error message.
     *Note LAC::.

Language construct
     One of the typical usage schemas of the language.  For example,
     one of the constructs of the C language is the `if' statement.
     *Note Languages and Context-Free Grammars: Language and Grammar.

Left associativity
     Operators having left associativity are analyzed from left to
     right: `a+b+c' first computes `a+b' and then combines with `c'.
     *Note Operator Precedence: Precedence.

Left recursion
     A rule whose result symbol is also its first component symbol;
     for example, `expseq1 : expseq1 ',' exp;'.  *Note Recursive
     Rules: Recursion.

Left-to-right parsing
     Parsing a sentence of a language by analyzing it token by token
     from left to right.  *Note The Bison Parser Algorithm: Algorithm.

Lexical analyzer (scanner)
     A function that reads an input stream and returns tokens one by
     one.  *Note The Lexical Analyzer Function `yylex': Lexical.

Lexical tie-in
     A flag, set by actions in the grammar rules, which alters the way
     tokens are parsed.  *Note Lexical Tie-ins::.

Literal string token
     A token which consists of two or more fixed characters.  *Note
     Symbols::.

Lookahead token
     A token already read but not yet shifted.  *Note Lookahead
     Tokens: Lookahead.

LALR(1)
     The class of context-free grammars that Bison (like most other
     parser generators) can handle by default; a subset of LR(1).
     *Note Mysterious Conflicts::.

LR(1)
     The class of context-free grammars in which at most one token of
     lookahead is needed to disambiguate the parsing of any piece of
     input.

Nonterminal symbol
     A grammar symbol standing for a grammatical construct that can
     be expressed through rules in terms of smaller constructs; in
     other words, a construct that is not a token.  *Note Symbols::.

Parser
     A function that recognizes valid sentences of a language by
     analyzing the syntax structure of a set of tokens passed to it
     from a lexical analyzer.

Postfix operator
     An arithmetic operator that is placed after the operands upon
     which it performs some operation.

Reduction
     Replacing a string of nonterminals and/or terminals with a single
     nonterminal, according to a grammar rule.  *Note The Bison
     Parser Algorithm: Algorithm.

Reentrant
     A reentrant subprogram is a subprogram which can be in invoked
     any number of times in parallel, without interference between
     the various invocations.  *Note A Pure (Reentrant) Parser: Pure
     Decl.

Reverse polish notation
     A language in which all operators are postfix operators.

Right recursion
     A rule whose result symbol is also its last component symbol; for
     example, `expseq1: exp ',' expseq1;'.  *Note Recursive Rules:
     Recursion.

Semantics
     In computer languages, the semantics are specified by the actions
     taken for each instance of the language, i.e., the meaning of
     each statement.  *Note Defining Language Semantics: Semantics.

Shift
     A parser is said to shift when it makes the choice of analyzing
     further input from the stream rather than reducing immediately
     some already-recognized rule.  *Note The Bison Parser Algorithm:
     Algorithm.

Single-character literal
     A single character that is recognized and interpreted as is.
     *Note From Formal Rules to Bison Input: Grammar in Bison.

Start symbol
     The nonterminal symbol that stands for a complete valid
     utterance in the language being parsed.  The start symbol is
     usually listed as the first nonterminal symbol in a language
     specification.  *Note The Start-Symbol: Start Decl.

Symbol table
     A data structure where symbol names and associated data are
     stored during parsing to allow for recognition and use of
     existing information in repeated uses of a symbol.  *Note
     Multi-function Calc::.

Syntax error
     An error encountered during parsing of an input stream due to
     invalid syntax.  *Note Error Recovery::.

Token
     A basic, grammatically indivisible unit of a language.  The
     symbol that describes a token in the grammar is a terminal
     symbol.  The input of the Bison parser is a stream of tokens
     which comes from the lexical analyzer.  *Note Symbols::.

Terminal symbol
     A grammar symbol that has no rules in the grammar and therefore
     is grammatically indivisible.  The piece of text it represents
     is a token.  *Note Languages and Context-Free Grammars: Language
     and Grammar.

Unreachable state
     A parser state to which there does not exist a sequence of
     transitions from the parser's start state.  A state can become
     unreachable during conflict resolution.  *Note Unreachable
     States::.


File: bison.info,  Node: Copying This Manual,  Next: Bibliography,  Prev: Glossary,  Up: Top

Appendix C Copying This Manual
******************************

                    Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or
     other functional and useful document "free" in the sense of
     freedom: to assure everyone the effective freedom to copy and
     redistribute it, with or without modifying it, either
     commercially or noncommercially.  Secondarily, this License
     preserves for the author and publisher a way to get credit for
     their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a
     copyleft license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same
     freedoms that the software does.  But this License is not
     limited to software manuals; it can be used for any textual
     work, regardless of subject matter or whether it is published as
     a printed book.  We recommend this License principally for works
     whose purpose is instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a
     notice grants a world-wide, royalty-free license, unlimited in
     duration, to use that work under the conditions stated herein.
     The "Document", below, refers to any such manual or work.  Any
     member of the public is a licensee, and is addressed as "you".
     You accept the license if you copy, modify or distribute the
     work in a way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing
     the Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (Thus, if the Document is in part a textbook of mathematics, a
     Secondary Section may not explain any mathematics.)  The
     relationship could be a matter of historical connection with the
     subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the
     Document does not identify any Invariant Sections then there are
     none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text
     may be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable
     copy, represented in a format whose specification is available
     to the general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings)
     some widely available drawing editor, and that is suitable for
     input to text formatters or for automatic translation to a
     variety of formats suitable for input to text formatters.  A
     copy made in an otherwise Transparent file format whose markup,
     or absence of markup, has been arranged to thwart or discourage
     subsequent modification by readers is not Transparent.  An image
     format is not Transparent if used for any substantial amount of
     text.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats
     include PNG, XCF and JPG.  Opaque formats include proprietary
     formats that can be read and edited only by proprietary word
     processors, SGML or XML for which the DTD and/or processing
     tools are not generally available, and the machine-generated
     HTML, PostScript or PDF produced by some word processors for
     output purposes only.

     The "Title Page" means, for a printed book, the title page
     itself, plus such following pages as are needed to hold,
     legibly, the material this License requires to appear in the
     title page.  For works in formats which do not have any title
     page as such, "Title Page" means the text near the most
     prominent appearance of the work's title, preceding the
     beginning of the body of the text.

     The "publisher" means any person or entity that distributes
     copies of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in
     parentheses following text that translates XYZ in another
     language.  (Here XYZ stands for a specific section name
     mentioned below, such as "Acknowledgements", "Dedications",
     "Endorsements", or "History".)  To "Preserve the Title" of such
     a section when you modify the Document means that it remains a
     section "Entitled XYZ" according to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference
     in this License, but only as regards disclaiming warranties: any
     other implication that these Warranty Disclaimers may have is
     void and has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that
     you add no other conditions whatsoever to those of this License.
     You may not use technical measures to obstruct or control the
     reading or further copying of the copies you make or distribute.
     However, you may accept compensation in exchange for copies.
     If you distribute a large enough number of copies you must also
     follow the conditions in section 3.

     You may also lend copies, under the same conditions stated
     above, and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100,
     and the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also
     clearly and legibly identify you as the publisher of these
     copies.  The front cover must present the full title with all
     words of the title equally prominent and visible.  You may add
     other material on the covers in addition.  Copying with changes
     limited to the covers, as long as they preserve the title of the
     Document and satisfy these conditions, can be treated as
     verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy,
     or state in or with each Opaque copy a computer-network location
     from which the general network-using public has access to
     download using public-standard network protocols a complete
     Transparent copy of the Document, free of added material.  If
     you use the latter option, you must take reasonably prudent
     steps, when you begin distribution of Opaque copies in quantity,
     to ensure that this Transparent copy will remain thus accessible
     at the stated location until at least one year after the last
     time you distribute an Opaque copy (directly or through your
     agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors
     of the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that
     you release the Modified Version under precisely this License,
     with the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version
     to whoever possesses a copy of it.  In addition, you must do
     these things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be
          listed in the History section of the Document).  You may
          use the same title as a previous version if the original
          publisher of that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release
          you from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown
          in the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its
          Title, and add to it an item stating at least the title,
          year, new authors, and publisher of the Modified Version as
          given on the Title Page.  If there is no section Entitled
          "History" in the Document, create one stating the title,
          year, authors, and publisher of the Document as given on
          its Title Page, then add an item describing the Modified
          Version as stated in the previous sentence.

       J. Preserve the network location, if any, given in the
          Document for public access to a Transparent copy of the
          Document, and likewise the network locations given in the
          Document for previous versions it was based on.  These may
          be placed in the "History" section.  You may omit a network
          location for a work that was published at least four years
          before the Document itself, or if the original publisher of
          the version it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or
          "Dedications", Preserve the Title of the section, and
          preserve in the section all the substance and tone of each
          of the contributor acknowledgements and/or dedications
          given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section
          numbers or the equivalent are not considered part of the
          section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do
     this, add their titles to the list of Invariant Sections in the
     Modified Version's license notice.  These titles must be
     distinct from any other section titles.

     You may add a section Entitled "Endorsements", provided it
     contains nothing but endorsements of your Modified Version by
     various parties--for example, statements of peer review or that
     the text has been approved by an organization as the
     authoritative definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If
     the Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same
     entity you are acting on behalf of, you may not add another; but
     you may replace the old one, on explicit permission from the
     previous publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or
     to assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a
     single copy.  If there are multiple Invariant Sections with the
     same name but different contents, make the title of each such
     section unique by adding at the end of it, in parentheses, the
     name of the original author or publisher of that section if
     known, or else a unique number.  Make the same adjustment to the
     section titles in the list of Invariant Sections in the license
     notice of the combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".
     You must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the
     individual copies of this License in the various documents with
     a single copy that is included in the collection, provided that
     you follow the rules of this License for verbatim copying of
     each of the documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you
     insert a copy of this License into the extracted document, and
     follow this License in all other respects regarding verbatim
     copying of that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume
     of a storage or distribution medium, is called an "aggregate" if
     the copyright resulting from the compilation is not used to
     limit the legal rights of the compilation's users beyond what
     the individual works permit.  When the Document is included in
     an aggregate, this License does not apply to the other works in
     the aggregate which are not themselves derivative works of the
     Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     half of the entire aggregate, the Document's Cover Texts may be
     placed on covers that bracket the Document within the aggregate,
     or the electronic equivalent of covers if the Document is in
     electronic form.  Otherwise they must appear on printed covers
     that bracket the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of
     section 4.  Replacing Invariant Sections with translations
     requires special permission from their copyright holders, but
     you may include translations of some or all Invariant Sections
     in addition to the original versions of these Invariant
     Sections.  You may include a translation of this License, and
     all the license notices in the Document, and any Warranty
     Disclaimers, provided that you also include the original English
     version of this License and the original versions of those
     notices and disclaimers.  In case of a disagreement between the
     translation and the original version of this License or a notice
     or disclaimer, the original version will prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing
     the actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of
     the violation by some reasonable means, this is the first time
     you have received notice of violation of this License (for any
     work) from that copyright holder, and you cure the violation
     prior to 30 days after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, receipt of a copy of some or all of
     the same material does not give you any rights to use it.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions
     of the GNU Free Documentation License from time to time.  Such
     new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.
     See `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it,
     you have the option of following the terms and conditions either
     of that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by
     the Free Software Foundation.  If the Document specifies that a
     proxy can decide which future versions of this License can be
     used, that proxy's public statement of acceptance of a version
     permanently authorizes you to choose that version for the
     Document.

 11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means
     any World Wide Web server that publishes copyrightable works and
     also provides prominent facilities for anybody to edit those
     works.  A public wiki that anybody can edit is an example of
     such a server.  A "Massive Multiauthor Collaboration" (or "MMC")
     contained in the site means any set of copyrightable works thus
     published on the MMC site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a
     not-for-profit corporation with a principal place of business in
     San Francisco, California, as well as future copyleft versions
     of that license published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole
     or in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated
     prior to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in
     the site under CC-BY-SA on the same site at any time before
     August 1, 2009, provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: bison.info,  Node: Bibliography,  Next: Index of Terms,  Prev: Copying This Manual,  Up: Top

Bibliography
************

[Denny 2008]
     Joel E. Denny and Brian A. Malloy, IELR(1): Practical LR(1)
     Parser Tables for Non-LR(1) Grammars with Conflict Resolution,
     in `Proceedings of the 2008 ACM Symposium on Applied Computing'
     (SAC'08), ACM, New York, NY, USA, pp. 240-245.
     `http://dx.doi.org/10.1145/1363686.1363747'

[Denny 2010 May]
     Joel E. Denny, PSLR(1): Pseudo-Scannerless Minimal LR(1) for the
     Deterministic Parsing of Composite Languages, Ph.D.
     Dissertation, Clemson University, Clemson, SC, USA (May 2010).
     `http://proquest.umi.com/pqdlink?did=2041473591&Fmt=7&clientId=79356&RQT=309&VName=PQD'

[Denny 2010 November]
     Joel E. Denny and Brian A. Malloy, The IELR(1) Algorithm for
     Generating Minimal LR(1) Parser Tables for Non-LR(1) Grammars
     with Conflict Resolution, in `Science of Computer Programming',
     Vol. 75, Issue 11 (November 2010), pp. 943-979.
     `http://dx.doi.org/10.1016/j.scico.2009.08.001'

[DeRemer 1982]
     Frank DeRemer and Thomas Pennello, Efficient Computation of
     LALR(1) Look-Ahead Sets, in `ACM Transactions on Programming
     Languages and Systems', Vol. 4, No. 4 (October 1982), pp.
     615-649. `http://dx.doi.org/10.1145/69622.357187'

[Knuth 1965]
     Donald E. Knuth, On the Translation of Languages from Left to
     Right, in `Information and Control', Vol. 8, Issue 6 (December
     1965), pp.  607-639.
     `http://dx.doi.org/10.1016/S0019-9958(65)90426-2'

[Scott 2000]
     Elizabeth Scott, Adrian Johnstone, and Shamsa Sadaf Hussain,
     `Tomita-Style Generalised LR Parsers', Royal Holloway,
     University of London, Department of Computer Science, TR-00-12
     (December 2000).
     `http://www.cs.rhul.ac.uk/research/languages/publications/tomita_style_1.ps'


File: bison.info,  Node: Index of Terms,  Prev: Bibliography,  Up: Top

Index of Terms
**************

 [index ]
* Menu:

* $ <1>:                                 Table of Symbols.  (line  39)
* $ <2>:                                 Java Action Features.
                                                            (line  13)
* $ <3>:                                 Table of Symbols.  (line  34)
* $ <4>:                                 Action Features.   (line  14)
* $:                                     Table of Symbols.  (line  38)
* $$ <1>:                                Table of Symbols.  (line  30)
* $$ <2>:                                Actions.           (line   6)
* $$ <3>:                                Action Features.   (line  10)
* $$:                                    Java Action Features.
                                                            (line  21)
* $< <1>:                                Action Features.   (line  23)
* $< <2>:                                Java Action Features.
                                                            (line  17)
* $< <3>:                                Action Features.   (line  18)
* $<:                                    Java Action Features.
                                                            (line  29)
* $@N:                                   Mid-Rule Action Translation.
                                                            (line   6)
* $[NAME]:                               Actions.           (line   6)
* $accept:                               Table of Symbols.  (line  97)
* $end:                                  Table of Symbols.  (line 140)
* $N:                                    Actions.           (line   6)
* $NAME:                                 Actions.           (line   6)
* $undefined:                            Table of Symbols.  (line 270)
* % <1>:                                 Table of Symbols.  (line  48)
* %:                                     Java Declarations Summary.
                                                            (line  57)
* %% <1>:                                Table of Symbols.  (line  43)
* %%:                                    Java Declarations Summary.
                                                            (line  53)
* %? <1>:                                Semantic Predicates.
                                                            (line   6)
* %?:                                    Table of Symbols.  (line  53)
* %code <1>:                             %code Summary.     (line  16)
* %code <2>:                             Calc++ Parser.     (line  68)
* %code <3>:                             %code Summary.     (line   6)
* %code <4>:                             Decl Summary.      (line  47)
* %code <5>:                             Java Declarations Summary.
                                                            (line  37)
* %code <6>:                             Prologue Alternatives.
                                                            (line   6)
* %code:                                 Table of Symbols.  (line 102)
* %code imports <1>:                     %code Summary.     (line  85)
* %code imports:                         Java Declarations Summary.
                                                            (line  41)
* %code init:                            Java Declarations Summary.
                                                            (line  45)
* %code lexer:                           Java Declarations Summary.
                                                            (line  49)
* %code provides <1>:                    Decl Summary.      (line  93)
* %code provides <2>:                    %code Summary.     (line  59)
* %code provides:                        Prologue Alternatives.
                                                            (line   6)
* %code requires <1>:                    Decl Summary.      (line  93)
* %code requires <2>:                    Calc++ Parser.     (line  27)
* %code requires <3>:                    Prologue Alternatives.
                                                            (line   6)
* %code requires:                        %code Summary.     (line  44)
* %code top <1>:                         Prologue Alternatives.
                                                            (line   6)
* %code top:                             %code Summary.     (line  70)
* %debug <1>:                            Table of Symbols.  (line 108)
* %debug <2>:                            Enabling Traces.   (line  28)
* %debug:                                Decl Summary.      (line  52)
* %define <1>:                           Decl Summary.      (line  57)
* %define <2>:                           %define Summary.   (line 341)
* %define <3>:                           Table of Symbols.  (line 111)
* %define <4>:                           Decl Summary.      (line  56)
* %define <5>:                           %define Summary.   (line  17)
* %define:                               Table of Symbols.  (line 113)
* %define abstract:                      Java Declarations Summary.
                                                            (line  61)
* %define annotations:                   Java Declarations Summary.
                                                            (line  65)
* %define api.location.type <1>:         %define Summary.   (line  91)
* %define api.location.type <2>:         User Defined Location Type.
                                                            (line   6)
* %define api.location.type:             Java Declarations Summary.
                                                            (line  91)
* %define api.namespace <1>:             C++ Bison Interface.
                                                            (line  11)
* %define api.namespace:                 %define Summary.   (line  52)
* %define api.position.type:             Java Declarations Summary.
                                                            (line 105)
* %define api.prefix:                    %define Summary.   (line 105)
* %define api.pure <1>:                  %define Summary.   (line 117)
* %define api.pure:                      Pure Decl.         (line   6)
* %define api.push-pull <1>:             Push Decl.         (line   6)
* %define api.push-pull <2>:             %define Summary.   (line 156)
* %define api.push-pull:                 Java Push Parser Interface.
                                                            (line   6)
* %define api.token.constructor <1>:     Calc++ Parser.     (line  17)
* %define api.token.constructor:         %define Summary.   (line 168)
* %define api.token.prefix:              %define Summary.   (line 182)
* %define api.value.type <1>:            %define Summary.   (line 218)
* %define api.value.type <2>:            Java Declarations Summary.
                                                            (line 114)
* %define api.value.type:                %define Summary.   (line 217)
* %define api.value.type union:          Type Generation.   (line   6)
* %define api.value.type variant:        Calc++ Parser.     (line  17)
* %define extends:                       Java Declarations Summary.
                                                            (line  69)
* %define final:                         Java Declarations Summary.
                                                            (line  73)
* %define implements:                    Java Declarations Summary.
                                                            (line  77)
* %define init_throws:                   Java Declarations Summary.
                                                            (line  82)
* %define lex_throws:                    Java Declarations Summary.
                                                            (line  86)
* %define location_type:                 %define Summary.   (line 293)
* %define lr.default-reduction <1>:      Default Reductions.
                                                            (line   6)
* %define lr.default-reduction:          %define Summary.   (line 296)
* %define lr.keep-unreachable-state <1>: %define Summary.   (line 315)
* %define lr.keep-unreachable-state:     Unreachable States.
                                                            (line   6)
* %define lr.type <1>:                   %define Summary.   (line 329)
* %define lr.type:                       LR Table Construction.
                                                            (line  25)
* %define package:                       Java Declarations Summary.
                                                            (line  97)
* %define parse.assert:                  %define Summary.   (line 344)
* %define parse.error <1>:               Error Reporting.   (line  18)
* %define parse.error:                   %define Summary.   (line 356)
* %define parse.lac <1>:                 %define Summary.   (line 374)
* %define parse.lac:                     LAC.               (line  29)
* %define parse.trace <1>:               Enabling Traces.   (line  33)
* %define parse.trace:                   %define Summary.   (line 384)
* %define parser_class_name:             Java Declarations Summary.
                                                            (line 101)
* %define public:                        Java Declarations Summary.
                                                            (line 110)
* %define strictfp:                      Java Declarations Summary.
                                                            (line 118)
* %define throws:                        Java Declarations Summary.
                                                            (line 122)
* %defines <1>:                          Table of Symbols.  (line 122)
* %defines <2>:                          Decl Summary.      (line  63)
* %defines <3>:                          Table of Symbols.  (line 118)
* %defines:                              Decl Summary.      (line 111)
* %destructor <1>:                       Table of Symbols.  (line 126)
* %destructor <2>:                       Destructor Decl.   (line  23)
* %destructor <3>:                       Decl Summary.      (line 114)
* %destructor <4>:                       Destructor Decl.   (line   6)
* %destructor:                           Using Mid-Rule Actions.
                                                            (line  77)
* %dprec <1>:                            Merging GLR Parses.
                                                            (line   6)
* %dprec:                                Table of Symbols.  (line 131)
* %empty <1>:                            Table of Symbols.  (line 136)
* %empty:                                Empty Rules.       (line   6)
* %error-verbose:                        Table of Symbols.  (line 154)
* %expect <1>:                           Expect Decl.       (line   6)
* %expect:                               Decl Summary.      (line  38)
* %expect-rr <1>:                        Expect Decl.       (line   6)
* %expect-rr:                            Simple GLR Parsers.
                                                            (line   6)
* %file-prefix <1>:                      Table of Symbols.  (line 158)
* %file-prefix:                          Decl Summary.      (line 119)
* %glr-parser <1>:                       Simple GLR Parsers.
                                                            (line   6)
* %glr-parser <2>:                       Table of Symbols.  (line 162)
* %glr-parser:                           GLR Parsers.       (line   6)
* %initial-action <1>:                   Initial Action Decl.
                                                            (line  11)
* %initial-action:                       Table of Symbols.  (line 166)
* %language <1>:                         Table of Symbols.  (line 170)
* %language:                             Decl Summary.      (line 123)
* %language "Java":                      Java Declarations Summary.
                                                            (line  10)
* %left <1>:                             Using Precedence.  (line   6)
* %left <2>:                             Table of Symbols.  (line 174)
* %left:                                 Decl Summary.      (line  21)
* %lex-param <1>:                        Table of Symbols.  (line 178)
* %lex-param <2>:                        Java Declarations Summary.
                                                            (line  13)
* %lex-param:                            Pure Calling.      (line  33)
* %locations:                            Decl Summary.      (line 129)
* %merge <1>:                            Table of Symbols.  (line 183)
* %merge:                                Merging GLR Parses.
                                                            (line   6)
* %name-prefix <1>:                      Decl Summary.      (line 136)
* %name-prefix <2>:                      Table of Symbols.  (line 190)
* %name-prefix:                          Java Declarations Summary.
                                                            (line  19)
* %no-lines <1>:                         Decl Summary.      (line 149)
* %no-lines:                             Table of Symbols.  (line 207)
* %nonassoc <1>:                         Decl Summary.      (line  25)
* %nonassoc <2>:                         Table of Symbols.  (line 211)
* %nonassoc <3>:                         Using Precedence.  (line   6)
* %nonassoc <4>:                         Default Reductions.
                                                            (line   6)
* %nonassoc:                             LR Table Construction.
                                                            (line 105)
* %output <1>:                           Table of Symbols.  (line 215)
* %output:                               Decl Summary.      (line 158)
* %param <1>:                            Pure Calling.      (line  38)
* %param <2>:                            Table of Symbols.  (line 219)
* %param:                                Pure Calling.      (line  38)
* %parse-param <1>:                      Parser Function.   (line  36)
* %parse-param <2>:                      Java Declarations Summary.
                                                            (line  24)
* %parse-param:                          Table of Symbols.  (line 224)
* %prec <1>:                             Contextual Precedence.
                                                            (line   6)
* %prec:                                 Table of Symbols.  (line 229)
* %precedence <1>:                       Using Precedence.  (line   6)
* %precedence <2>:                       Table of Symbols.  (line 233)
* %precedence:                           Precedence Only.   (line   6)
* %printer:                              Printer Decl.      (line  17)
* %pure-parser <1>:                      Decl Summary.      (line 161)
* %pure-parser:                          Table of Symbols.  (line 237)
* %require <1>:                          Require Decl.      (line   6)
* %require <2>:                          Table of Symbols.  (line 242)
* %require:                              Decl Summary.      (line 166)
* %right <1>:                            Table of Symbols.  (line 246)
* %right <2>:                            Using Precedence.  (line   6)
* %right:                                Decl Summary.      (line  17)
* %skeleton <1>:                         Decl Summary.      (line 170)
* %skeleton:                             Table of Symbols.  (line 250)
* %start <1>:                            Decl Summary.      (line  34)
* %start <2>:                            Table of Symbols.  (line 254)
* %start:                                Start Decl.        (line   6)
* %token <1>:                            Table of Symbols.  (line 258)
* %token <2>:                            Java Declarations Summary.
                                                            (line  29)
* %token <3>:                            Token Decl.        (line   6)
* %token:                                Decl Summary.      (line  13)
* %token-table <1>:                      Table of Symbols.  (line 262)
* %token-table:                          Decl Summary.      (line 179)
* %type <1>:                             Decl Summary.      (line  30)
* %type <2>:                             Type Decl.         (line   6)
* %type <3>:                             Table of Symbols.  (line 266)
* %type:                                 Java Declarations Summary.
                                                            (line  33)
* %union <1>:                            Table of Symbols.  (line 275)
* %union <2>:                            Structured Value Type.
                                                            (line   6)
* %union <3>:                            Union Decl.        (line   6)
* %union:                                Decl Summary.      (line   9)
* %verbose:                              Decl Summary.      (line 212)
* %yacc:                                 Decl Summary.      (line 218)
* /*:                                    Table of Symbols.  (line  64)
* /* ... */:                             Grammar Outline.   (line   6)
* //:                                    Table of Symbols.  (line  65)
* // ...:                                Grammar Outline.   (line   6)
* ::                                     Table of Symbols.  (line  68)
* ;:                                     Table of Symbols.  (line  72)
* <*> <1>:                               Printer Decl.      (line   6)
* <*> <2>:                               Destructor Decl.   (line   6)
* <*>:                                   Table of Symbols.  (line  79)
* <> <1>:                                Destructor Decl.   (line   6)
* <> <2>:                                Printer Decl.      (line   6)
* <>:                                    Table of Symbols.  (line  88)
* @$ <1>:                                Java Action Features.
                                                            (line  40)
* @$ <2>:                                Action Features.   (line  99)
* @$ <3>:                                Table of Symbols.  (line   7)
* @$:                                    Actions and Locations.
                                                            (line   6)
* @[:                                    Table of Symbols.  (line  21)
* @[NAME]:                               Actions and Locations.
                                                            (line   6)
* @N <1>:                                Actions and Locations.
                                                            (line   6)
* @N <2>:                                Table of Symbols.  (line  11)
* @N <3>:                                Mid-Rule Action Translation.
                                                            (line   6)
* @N <4>:                                Java Action Features.
                                                            (line  35)
* @N <5>:                                Table of Symbols.  (line  12)
* @N:                                    Action Features.   (line 105)
* @NAME <1>:                             Table of Symbols.  (line  20)
* @NAME:                                 Actions and Locations.
                                                            (line   6)
* abstract syntax tree:                  Implementing Gotos/Loops.
                                                            (line  17)
* accepting state:                       Understanding.     (line 177)
* action:                                Actions.           (line   6)
* action data types:                     Action Types.      (line   6)
* action features summary:               Action Features.   (line   6)
* actions in mid-rule <1>:               Destructor Decl.   (line  88)
* actions in mid-rule:                   Mid-Rule Actions.  (line   6)
* actions, location:                     Actions and Locations.
                                                            (line   6)
* actions, semantic:                     Semantic Actions.  (line   6)
* additional C code section:             Epilogue.          (line   6)
* algorithm of parser:                   Algorithm.         (line   6)
* ambiguous grammars <1>:                Language and Grammar.
                                                            (line  34)
* ambiguous grammars:                    Generalized LR Parsing.
                                                            (line   6)
* associativity:                         Why Precedence.    (line  34)
* AST:                                   Implementing Gotos/Loops.
                                                            (line  17)
* Backus-Naur form:                      Language and Grammar.
                                                            (line  16)
* begin of Location:                     Java Location Values.
                                                            (line  21)
* begin of location:                     C++ location.      (line  22)
* Bison declaration summary:             Decl Summary.      (line   6)
* Bison declarations:                    Declarations.      (line   6)
* Bison declarations (introduction):     Bison Declarations.
                                                            (line   6)
* Bison grammar:                         Grammar in Bison.  (line   6)
* Bison invocation:                      Invocation.        (line   6)
* Bison parser:                          Bison Parser.      (line   6)
* Bison parser algorithm:                Algorithm.         (line   6)
* Bison symbols, table of:               Table of Symbols.  (line   6)
* Bison utility:                         Bison Parser.      (line   6)
* bison-i18n.m4:                         Internationalization.
                                                            (line  20)
* bison-po:                              Internationalization.
                                                            (line   6)
* BISON_I18N:                            Internationalization.
                                                            (line  27)
* BISON_LOCALEDIR:                       Internationalization.
                                                            (line  27)
* bisonSkeleton:                         Java Parser Interface.
                                                            (line  94)
* bisonVersion:                          Java Parser Interface.
                                                            (line  93)
* BNF:                                   Language and Grammar.
                                                            (line  16)
* braced code:                           Rules Syntax.      (line  29)
* build<T> on semantic_type:             C++ Variants.      (line  45)
* C code, section for additional:        Epilogue.          (line   6)
* C-language interface:                  Interface.         (line   6)
* calc:                                  Infix Calc.        (line   6)
* calculator, infix notation:            Infix Calc.        (line   6)
* calculator, location tracking:         Location Tracking Calc.
                                                            (line   6)
* calculator, multi-function:            Multi-function Calc.
                                                            (line   6)
* calculator, simple:                    RPN Calc.          (line   6)
* canonical LR <1>:                      Mysterious Conflicts.
                                                            (line  46)
* canonical LR:                          LR Table Construction.
                                                            (line   6)
* character token:                       Symbols.           (line  37)
* column of position:                    C++ position.      (line  30)
* columns on location:                   C++ location.      (line  27)
* columns on position:                   C++ position.      (line  33)
* comment:                               Grammar Outline.   (line   6)
* compiling the parser:                  Rpcalc Compile.    (line   6)
* conflicts <1>:                         Simple GLR Parsers.
                                                            (line   6)
* conflicts <2>:                         Shift/Reduce.      (line   6)
* conflicts <3>:                         Merging GLR Parses.
                                                            (line   6)
* conflicts:                             GLR Parsers.       (line   6)
* conflicts, reduce/reduce:              Reduce/Reduce.     (line   6)
* conflicts, suppressing warnings of:    Expect Decl.       (line   6)
* consistent states:                     Default Reductions.
                                                            (line  17)
* context-dependent precedence:          Contextual Precedence.
                                                            (line   6)
* context-free grammar:                  Language and Grammar.
                                                            (line   6)
* controlling function:                  Rpcalc Main.       (line   6)
* core, item set:                        Understanding.     (line 124)
* dangling else:                         Shift/Reduce.      (line   6)
* data type of locations:                Location Type.     (line   6)
* data types in actions:                 Action Types.      (line   6)
* data types of semantic values:         Value Type.        (line   6)
* debug_level on parser:                 C++ Parser Interface.
                                                            (line  58)
* debug_stream on parser:                C++ Parser Interface.
                                                            (line  53)
* debugging:                             Tracing.           (line   6)
* declaration summary:                   Decl Summary.      (line   6)
* declarations:                          Prologue.          (line   6)
* declarations section:                  Prologue.          (line   6)
* declarations, Bison:                   Declarations.      (line   6)
* declarations, Bison (introduction):    Bison Declarations.
                                                            (line   6)
* declaring literal string tokens:       Token Decl.        (line   6)
* declaring operator precedence:         Precedence Decl.   (line   6)
* declaring the start symbol:            Start Decl.        (line   6)
* declaring token type names:            Token Decl.        (line   6)
* declaring value types <1>:             Structured Value Type.
                                                            (line   6)
* declaring value types <2>:             Union Decl.        (line   6)
* declaring value types:                 Type Generation.   (line   6)
* declaring value types, nonterminals:   Type Decl.         (line   6)
* default action:                        Actions.           (line  63)
* default data type:                     Value Type.        (line   6)
* default location type:                 Location Type.     (line   6)
* default reductions:                    Default Reductions.
                                                            (line   6)
* default stack limit:                   Memory Management. (line  30)
* default start symbol:                  Start Decl.        (line   6)
* defaulted states:                      Default Reductions.
                                                            (line  17)
* deferred semantic actions:             GLR Semantic Actions.
                                                            (line  12)
* defining language semantics:           Semantics.         (line   6)
* delayed syntax error detection <1>:    Default Reductions.
                                                            (line  44)
* delayed syntax error detection:        LR Table Construction.
                                                            (line 105)
* delayed yylex invocations:             Default Reductions.
                                                            (line  17)
* discarded symbols:                     Destructor Decl.   (line  98)
* discarded symbols, mid-rule actions:   Using Mid-Rule Actions.
                                                            (line  77)
* dot:                                   Graphviz.          (line   6)
* else, dangling:                        Shift/Reduce.      (line   6)
* empty rule:                            Empty Rules.       (line   6)
* end of Location:                       Java Location Values.
                                                            (line  22)
* end of location:                       C++ location.      (line  23)
* epilogue:                              Epilogue.          (line   6)
* error <1>:                             Error Recovery.    (line  20)
* error:                                 Table of Symbols.  (line 144)
* error on parser:                       C++ Parser Interface.
                                                            (line  64)
* error recovery:                        Error Recovery.    (line   6)
* error recovery, mid-rule actions:      Using Mid-Rule Actions.
                                                            (line  77)
* error recovery, simple:                Simple Error Recovery.
                                                            (line   6)
* error reporting function:              Error Reporting.   (line   6)
* error reporting routine:               Rpcalc Error.      (line   6)
* examples, simple:                      Examples.          (line   6)
* exceptions:                            C++ Parser Interface.
                                                            (line  47)
* exercises:                             Exercises.         (line   6)
* file format:                           Grammar Layout.    (line   6)
* file of position:                      C++ position.      (line  17)
* finite-state machine:                  Parser States.     (line   6)
* formal grammar:                        Grammar in Bison.  (line   6)
* format of grammar file:                Grammar Layout.    (line   6)
* freeing discarded symbols:             Destructor Decl.   (line   6)
* frequently asked questions:            FAQ.               (line   6)
* generalized LR (GLR) parsing <1>:      Language and Grammar.
                                                            (line  34)
* generalized LR (GLR) parsing <2>:      Generalized LR Parsing.
                                                            (line   6)
* generalized LR (GLR) parsing:          GLR Parsers.       (line   6)
* generalized LR (GLR) parsing, ambiguous grammars: Merging GLR Parses.
                                                            (line   6)
* generalized LR (GLR) parsing, unambiguous grammars: Simple GLR Parsers.
                                                            (line   6)
* getDebugLevel on YYParser:             Java Parser Interface.
                                                            (line  88)
* getDebugStream on YYParser:            Java Parser Interface.
                                                            (line  83)
* getEndPos on Lexer:                    Java Scanner Interface.
                                                            (line  43)
* getErrorVerbose on YYParser:           Java Parser Interface.
                                                            (line  66)
* getLVal on Lexer:                      Java Scanner Interface.
                                                            (line  51)
* getStartPos on Lexer:                  Java Scanner Interface.
                                                            (line  42)
* gettext:                               Internationalization.
                                                            (line   6)
* glossary:                              Glossary.          (line   6)
* GLR parsers and inline:                Compiler Requirements.
                                                            (line   6)
* GLR parsers and yychar:                GLR Semantic Actions.
                                                            (line  17)
* GLR parsers and yyclearin:             GLR Semantic Actions.
                                                            (line  26)
* GLR parsers and YYERROR:               GLR Semantic Actions.
                                                            (line  39)
* GLR parsers and yylloc:                GLR Semantic Actions.
                                                            (line  17)
* GLR parsers and YYLLOC_DEFAULT:        Location Default Action.
                                                            (line   6)
* GLR parsers and yylval:                GLR Semantic Actions.
                                                            (line  17)
* GLR parsing <1>:                       Generalized LR Parsing.
                                                            (line   6)
* GLR parsing <2>:                       Language and Grammar.
                                                            (line  34)
* GLR parsing:                           GLR Parsers.       (line   6)
* GLR parsing, ambiguous grammars:       Merging GLR Parses.
                                                            (line   6)
* GLR parsing, unambiguous grammars:     Simple GLR Parsers.
                                                            (line   6)
* GLR with LALR:                         LR Table Construction.
                                                            (line  66)
* grammar file:                          Grammar Layout.    (line   6)
* grammar rule syntax:                   Rules Syntax.      (line   6)
* grammar rules section:                 Grammar Rules.     (line   6)
* grammar, Bison:                        Grammar in Bison.  (line   6)
* grammar, context-free:                 Language and Grammar.
                                                            (line   6)
* grouping, syntactic:                   Language and Grammar.
                                                            (line  48)
* Header guard:                          Decl Summary.      (line  96)
* i18n:                                  Internationalization.
                                                            (line   6)
* IELR <1>:                              Mysterious Conflicts.
                                                            (line  46)
* IELR:                                  LR Table Construction.
                                                            (line   6)
* IELR grammars:                         Language and Grammar.
                                                            (line  22)
* infix notation calculator:             Infix Calc.        (line   6)
* initialize on location:                C++ location.      (line  19)
* initialize on position:                C++ position.      (line  14)
* inline:                                Compiler Requirements.
                                                            (line   6)
* interface:                             Interface.         (line   6)
* internationalization:                  Internationalization.
                                                            (line   6)
* introduction:                          Introduction.      (line   6)
* invoking Bison:                        Invocation.        (line   6)
* item:                                  Understanding.     (line 102)
* item set core:                         Understanding.     (line 124)
* kernel, item set:                      Understanding.     (line 124)
* LAC <1>:                               LR Table Construction.
                                                            (line 105)
* LAC <2>:                               Default Reductions.
                                                            (line  55)
* LAC:                                   LAC.               (line   6)
* LALR <1>:                              Mysterious Conflicts.
                                                            (line  34)
* LALR:                                  LR Table Construction.
                                                            (line   6)
* LALR grammars:                         Language and Grammar.
                                                            (line  22)
* language semantics, defining:          Semantics.         (line   6)
* layout of Bison grammar:               Grammar Layout.    (line   6)
* left recursion:                        Recursion.         (line  17)
* lexical analyzer:                      Lexical.           (line   6)
* lexical analyzer, purpose:             Bison Parser.      (line   6)
* lexical analyzer, writing:             Rpcalc Lexer.      (line   6)
* lexical tie-in:                        Lexical Tie-ins.   (line   6)
* line of position:                      C++ position.      (line  23)
* lines on location:                     C++ location.      (line  28)
* lines on position:                     C++ position.      (line  26)
* literal string token:                  Symbols.           (line  59)
* literal token:                         Symbols.           (line  37)
* location <1>:                          Locations.         (line   6)
* location:                              Tracking Locations.
                                                            (line   6)
* location actions:                      Actions and Locations.
                                                            (line   6)
* Location on Location:                  Java Location Values.
                                                            (line  26)
* location on location:                  C++ location.      (line   8)
* location tracking calculator:          Location Tracking Calc.
                                                            (line   6)
* location, textual <1>:                 Locations.         (line   6)
* location, textual:                     Tracking Locations.
                                                            (line   6)
* location_type:                         C++ Parser Interface.
                                                            (line  16)
* lookahead correction:                  LAC.               (line   6)
* lookahead token:                       Lookahead.         (line   6)
* LR:                                    Mysterious Conflicts.
                                                            (line  34)
* LR grammars:                           Language and Grammar.
                                                            (line  22)
* ltcalc:                                Location Tracking Calc.
                                                            (line   6)
* main function in simple example:       Rpcalc Main.       (line   6)
* make_ on symbol_type:                  Complete Symbols.  (line  30)
* memory exhaustion:                     Memory Management. (line   6)
* memory management:                     Memory Management. (line   6)
* mfcalc:                                Multi-function Calc.
                                                            (line   6)
* mid-rule actions <1>:                  Destructor Decl.   (line  88)
* mid-rule actions:                      Mid-Rule Actions.  (line   6)
* multi-function calculator:             Multi-function Calc.
                                                            (line   6)
* multicharacter literal:                Symbols.           (line  59)
* mutual recursion:                      Recursion.         (line  35)
* Mysterious Conflict:                   LR Table Construction.
                                                            (line   6)
* Mysterious Conflicts:                  Mysterious Conflicts.
                                                            (line   6)
* named references:                      Named References.  (line   6)
* NLS:                                   Internationalization.
                                                            (line   6)
* nondeterministic parsing <1>:          Language and Grammar.
                                                            (line  34)
* nondeterministic parsing:              Generalized LR Parsing.
                                                            (line   6)
* nonterminal symbol:                    Symbols.           (line   6)
* nonterminal, useless:                  Understanding.     (line  48)
* operator precedence:                   Precedence.        (line   6)
* operator precedence, declaring:        Precedence Decl.   (line   6)
* operator!= on location:                C++ location.      (line  42)
* operator!= on position:                C++ position.      (line  44)
* operator+ on location:                 C++ location.      (line  32)
* operator+ on position:                 C++ position.      (line  38)
* operator+= on location:                C++ location.      (line  33)
* operator+= on position:                C++ position.      (line  37)
* operator- on location:                 C++ location.      (line  34)
* operator- on position:                 C++ position.      (line  40)
* operator-= on location:                C++ location.      (line  35)
* operator-= on position:                C++ position.      (line  39)
* operator<< <1>:                        C++ position.      (line  48)
* operator<<:                            C++ location.      (line  47)
* operator== on location:                C++ location.      (line  41)
* operator== on position:                C++ position.      (line  43)
* options for invoking Bison:            Invocation.        (line   6)
* overflow of parser stack:              Memory Management. (line   6)
* parse error:                           Error Reporting.   (line   6)
* parse on parser:                       C++ Parser Interface.
                                                            (line  45)
* parse on YYParser:                     Java Parser Interface.
                                                            (line  62)
* parser:                                Bison Parser.      (line   6)
* parser on parser:                      C++ Parser Interface.
                                                            (line  36)
* parser stack:                          Algorithm.         (line   6)
* parser stack overflow:                 Memory Management. (line   6)
* parser state:                          Parser States.     (line   6)
* pointed rule:                          Understanding.     (line 102)
* polish notation calculator:            RPN Calc.          (line   6)
* position on position:                  C++ position.      (line   8)
* precedence declarations:               Precedence Decl.   (line   6)
* precedence of operators:               Precedence.        (line   6)
* precedence, context-dependent:         Contextual Precedence.
                                                            (line   6)
* precedence, unary operator:            Contextual Precedence.
                                                            (line   6)
* preventing warnings about conflicts:   Expect Decl.       (line   6)
* printing semantic values:              Printer Decl.      (line   6)
* Prologue <1>:                          Prologue.          (line   6)
* Prologue:                              %code Summary.     (line   6)
* Prologue Alternatives:                 Prologue Alternatives.
                                                            (line   6)
* pure parser:                           Pure Decl.         (line   6)
* push parser:                           Push Decl.         (line   6)
* push_parse on YYParser:                Java Push Parser Interface.
                                                            (line  27)
* questions:                             FAQ.               (line   6)
* recovering:                            Java Action Features.
                                                            (line  56)
* recovering on YYParser:                Java Parser Interface.
                                                            (line  79)
* recovery from errors:                  Error Recovery.    (line   6)
* recursive rule:                        Recursion.         (line   6)
* reduce/reduce conflict:                Reduce/Reduce.     (line   6)
* reduce/reduce conflicts <1>:           Simple GLR Parsers.
                                                            (line   6)
* reduce/reduce conflicts <2>:           GLR Parsers.       (line   6)
* reduce/reduce conflicts:               Merging GLR Parses.
                                                            (line   6)
* reduction:                             Algorithm.         (line   6)
* reentrant parser:                      Pure Decl.         (line   6)
* requiring a version of Bison:          Require Decl.      (line   6)
* reverse polish notation:               RPN Calc.          (line   6)
* right recursion:                       Recursion.         (line  17)
* rpcalc:                                RPN Calc.          (line   6)
* rule syntax:                           Rules Syntax.      (line   6)
* rule, empty:                           Empty Rules.       (line   6)
* rule, pointed:                         Understanding.     (line 102)
* rule, recursive:                       Recursion.         (line   6)
* rule, useless:                         Understanding.     (line  48)
* rules section for grammar:             Grammar Rules.     (line   6)
* running Bison (introduction):          Rpcalc Generate.   (line   6)
* semantic actions:                      Semantic Actions.  (line   6)
* Semantic predicates in GLR parsers:    Semantic Predicates.
                                                            (line   6)
* semantic value:                        Semantic Values.   (line   6)
* semantic value type:                   Value Type.        (line   6)
* semantic_type:                         C++ Parser Interface.
                                                            (line  15)
* set_debug_level on parser:             C++ Parser Interface.
                                                            (line  59)
* set_debug_stream on parser:            C++ Parser Interface.
                                                            (line  54)
* setDebugLevel on YYParser:             Java Parser Interface.
                                                            (line  89)
* setDebugStream on YYParser:            Java Parser Interface.
                                                            (line  84)
* setErrorVerbose on YYParser:           Java Parser Interface.
                                                            (line  67)
* shift/reduce conflicts <1>:            Shift/Reduce.      (line   6)
* shift/reduce conflicts <2>:            Simple GLR Parsers.
                                                            (line   6)
* shift/reduce conflicts:                GLR Parsers.       (line   6)
* shifting:                              Algorithm.         (line   6)
* simple examples:                       Examples.          (line   6)
* single-character literal:              Symbols.           (line  37)
* stack overflow:                        Memory Management. (line   6)
* stack, parser:                         Algorithm.         (line   6)
* stages in using Bison:                 Stages.            (line   6)
* start symbol:                          Language and Grammar.
                                                            (line  97)
* start symbol, declaring:               Start Decl.        (line   6)
* state (of parser):                     Parser States.     (line   6)
* step on location:                      C++ location.      (line  38)
* string token:                          Symbols.           (line  59)
* summary, action features:              Action Features.   (line   6)
* summary, Bison declaration:            Decl Summary.      (line   6)
* suppressing conflict warnings:         Expect Decl.       (line   6)
* symbol:                                Symbols.           (line   6)
* symbol table example:                  Mfcalc Symbol Table.
                                                            (line   6)
* symbol_type on symbol_type:            Complete Symbols.  (line  15)
* symbols (abstract):                    Language and Grammar.
                                                            (line  48)
* symbols in Bison, table of:            Table of Symbols.  (line   6)
* syntactic grouping:                    Language and Grammar.
                                                            (line  48)
* syntax error:                          Error Reporting.   (line   6)
* syntax of grammar rules:               Rules Syntax.      (line   6)
* syntax_error:                          C++ Parser Interface.
                                                            (line  26)
* syntax_error on syntax_error:          C++ Parser Interface.
                                                            (line  41)
* terminal symbol:                       Symbols.           (line   6)
* textual location <1>:                  Locations.         (line   6)
* textual location:                      Tracking Locations.
                                                            (line   6)
* token <1>:                             C++ Parser Interface.
                                                            (line  19)
* token:                                 Language and Grammar.
                                                            (line  48)
* token type:                            Symbols.           (line   6)
* token type names, declaring:           Token Decl.        (line   6)
* token, useless:                        Understanding.     (line  48)
* toString on Location:                  Java Location Values.
                                                            (line  33)
* tracing the parser:                    Tracing.           (line   6)
* uint:                                  C++ Location Values.
                                                            (line  15)
* unary operator precedence:             Contextual Precedence.
                                                            (line   6)
* unreachable states:                    Unreachable States.
                                                            (line   6)
* useless nonterminal:                   Understanding.     (line  48)
* useless rule:                          Understanding.     (line  48)
* useless token:                         Understanding.     (line  48)
* using Bison:                           Stages.            (line   6)
* value type, semantic:                  Value Type.        (line   6)
* value types, declaring <1>:            Union Decl.        (line   6)
* value types, declaring <2>:            Structured Value Type.
                                                            (line   6)
* value types, declaring:                Type Generation.   (line   6)
* value types, nonterminals, declaring:  Type Decl.         (line   6)
* value, semantic:                       Semantic Values.   (line   6)
* version requirement:                   Require Decl.      (line   6)
* warnings, preventing:                  Expect Decl.       (line   6)
* writing a lexical analyzer:            Rpcalc Lexer.      (line   6)
* xml:                                   Xml.               (line   6)
* YYABORT <1>:                           Parser Function.   (line  29)
* YYABORT <2>:                           Action Features.   (line  28)
* YYABORT <3>:                           Java Action Features.
                                                            (line  44)
* YYABORT <4>:                           Parser Function.   (line  29)
* YYABORT:                               Table of Symbols.  (line 279)
* YYACCEPT <1>:                          Java Action Features.
                                                            (line  48)
* YYACCEPT <2>:                          Action Features.   (line  32)
* YYACCEPT <3>:                          Parser Function.   (line  26)
* YYACCEPT <4>:                          Table of Symbols.  (line 288)
* YYACCEPT:                              Parser Function.   (line  26)
* YYBACKUP <1>:                          Table of Symbols.  (line 296)
* YYBACKUP:                              Action Features.   (line  36)
* yychar <1>:                            Table of Symbols.  (line 301)
* yychar <2>:                            Lookahead.         (line  50)
* yychar <3>:                            Action Features.   (line  69)
* yychar:                                GLR Semantic Actions.
                                                            (line  17)
* yyclearin <1>:                         Action Features.   (line  77)
* yyclearin <2>:                         Error Recovery.    (line 100)
* yyclearin <3>:                         Table of Symbols.  (line 308)
* yyclearin:                             GLR Semantic Actions.
                                                            (line  26)
* yydebug <1>:                           Tracing.           (line   6)
* yydebug:                               Table of Symbols.  (line 316)
* YYDEBUG <1>:                           Table of Symbols.  (line 312)
* YYDEBUG:                               Enabling Traces.   (line   9)
* YYEMPTY:                               Action Features.   (line  49)
* YYENABLE_NLS:                          Internationalization.
                                                            (line  27)
* YYEOF:                                 Action Features.   (line  52)
* yyerrok <1>:                           Table of Symbols.  (line 322)
* yyerrok <2>:                           Action Features.   (line  82)
* yyerrok:                               Error Recovery.    (line  95)
* YYERROR:                               Action Features.   (line  56)
* yyerror <1>:                           Java Action Features.
                                                            (line  61)
* yyerror:                               Table of Symbols.  (line 337)
* YYERROR <1>:                           Table of Symbols.  (line 326)
* YYERROR:                               GLR Semantic Actions.
                                                            (line  39)
* yyerror <1>:                           Error Reporting.   (line   6)
* yyerror:                               Java Action Features.
                                                            (line  63)
* YYERROR:                               Java Action Features.
                                                            (line  52)
* yyerror on Lexer:                      Java Scanner Interface.
                                                            (line  28)
* yyerror on YYParser:                   Java Parser Interface.
                                                            (line  73)
* YYERROR_VERBOSE:                       Table of Symbols.  (line 341)
* YYFPRINTF <1>:                         Table of Symbols.  (line 349)
* YYFPRINTF:                             Enabling Traces.   (line  43)
* YYINITDEPTH <1>:                       Memory Management. (line  33)
* YYINITDEPTH:                           Table of Symbols.  (line 352)
* yylex <1>:                             Table of Symbols.  (line 356)
* yylex:                                 Lexical.           (line   6)
* yylex on Lexer:                        Java Scanner Interface.
                                                            (line  34)
* yylex on parser:                       Split Symbols.     (line  10)
* yylloc <1>:                            Actions and Locations.
                                                            (line  65)
* yylloc <2>:                            Lookahead.         (line  50)
* yylloc <3>:                            Token Locations.   (line   6)
* yylloc <4>:                            GLR Semantic Actions.
                                                            (line  17)
* yylloc <5>:                            Table of Symbols.  (line 361)
* yylloc:                                Action Features.   (line  87)
* YYLLOC_DEFAULT:                        Location Default Action.
                                                            (line   6)
* YYLTYPE <1>:                           Token Locations.   (line  19)
* YYLTYPE:                               Table of Symbols.  (line 371)
* yylval <1>:                            Token Values.      (line   6)
* yylval <2>:                            Table of Symbols.  (line 375)
* yylval <3>:                            Lookahead.         (line  50)
* yylval <4>:                            Actions.           (line  89)
* yylval <5>:                            Action Features.   (line  93)
* yylval:                                GLR Semantic Actions.
                                                            (line  17)
* YYMAXDEPTH <1>:                        Memory Management. (line  14)
* YYMAXDEPTH:                            Table of Symbols.  (line 383)
* yynerrs <1>:                           Error Reporting.   (line  71)
* yynerrs:                               Table of Symbols.  (line 387)
* yyoutput:                              Printer Decl.      (line  17)
* yyparse <1>:                           Table of Symbols.  (line 393)
* yyparse:                               Parser Function.   (line   6)
* YYParser on YYParser:                  Java Parser Interface.
                                                            (line  40)
* YYPRINT <1>:                           The YYPRINT Macro. (line  11)
* YYPRINT <2>:                           Table of Symbols.  (line 398)
* YYPRINT:                               The YYPRINT Macro. (line  11)
* yypstate_delete <1>:                   Parser Delete Function.
                                                            (line  15)
* yypstate_delete <2>:                   Table of Symbols.  (line 403)
* yypstate_delete:                       Parser Delete Function.
                                                            (line   6)
* yypstate_new <1>:                      Parser Create Function.
                                                            (line  15)
* yypstate_new <2>:                      Table of Symbols.  (line 411)
* yypstate_new:                          Parser Create Function.
                                                            (line   6)
* yypull_parse <1>:                      Table of Symbols.  (line 418)
* yypull_parse:                          Pull Parser Function.
                                                            (line   6)
* yypush_parse <1>:                      Push Parser Function.
                                                            (line   6)
* yypush_parse <2>:                      Table of Symbols.  (line 425)
* yypush_parse:                          Push Parser Function.
                                                            (line  15)
* YYRECOVERING <1>:                      Error Recovery.    (line 112)
* YYRECOVERING <2>:                      Action Features.   (line  64)
* YYRECOVERING:                          Table of Symbols.  (line 432)
* YYSTACK_USE_ALLOCA:                    Table of Symbols.  (line 437)
* YYSTYPE:                               Table of Symbols.  (line 454)
* | <1>:                                 Rules Syntax.      (line  48)
* |:                                     Table of Symbols.  (line  75)


